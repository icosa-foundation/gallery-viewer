/*!
 * Icosa Viewer
 * https://github.com/icosa-gallery/icosa-viewer
 * Copyright (c) 2021-2022 Icosa Gallery
 * Released under the Apache 2.0 Licence.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.IcosaViewer = {}));
})(this, (function (exports) { 'use strict';

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */

	function __awaiter(thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	/*!
	 * camera-controls
	 * https://github.com/yomotsu/camera-controls
	 * (c) 2017 @yomotsu
	 * Released under the MIT License.
	 */
	var ACTION;
	(function (ACTION) {
	    ACTION[ACTION["NONE"] = 0] = "NONE";
	    ACTION[ACTION["ROTATE"] = 1] = "ROTATE";
	    ACTION[ACTION["TRUCK"] = 2] = "TRUCK";
	    ACTION[ACTION["OFFSET"] = 3] = "OFFSET";
	    ACTION[ACTION["DOLLY"] = 4] = "DOLLY";
	    ACTION[ACTION["ZOOM"] = 5] = "ZOOM";
	    ACTION[ACTION["TOUCH_ROTATE"] = 6] = "TOUCH_ROTATE";
	    ACTION[ACTION["TOUCH_TRUCK"] = 7] = "TOUCH_TRUCK";
	    ACTION[ACTION["TOUCH_OFFSET"] = 8] = "TOUCH_OFFSET";
	    ACTION[ACTION["TOUCH_DOLLY"] = 9] = "TOUCH_DOLLY";
	    ACTION[ACTION["TOUCH_ZOOM"] = 10] = "TOUCH_ZOOM";
	    ACTION[ACTION["TOUCH_DOLLY_TRUCK"] = 11] = "TOUCH_DOLLY_TRUCK";
	    ACTION[ACTION["TOUCH_DOLLY_OFFSET"] = 12] = "TOUCH_DOLLY_OFFSET";
	    ACTION[ACTION["TOUCH_ZOOM_TRUCK"] = 13] = "TOUCH_ZOOM_TRUCK";
	    ACTION[ACTION["TOUCH_ZOOM_OFFSET"] = 14] = "TOUCH_ZOOM_OFFSET";
	})(ACTION || (ACTION = {}));
	function isPerspectiveCamera(camera) {
	    return camera.isPerspectiveCamera;
	}
	function isOrthographicCamera(camera) {
	    return camera.isOrthographicCamera;
	}

	const PI_2 = Math.PI * 2;
	const PI_HALF = Math.PI / 2;

	const EPSILON = 1e-5;
	function approxZero(number, error = EPSILON) {
	    return Math.abs(number) < error;
	}
	function approxEquals(a, b, error = EPSILON) {
	    return approxZero(a - b, error);
	}
	function roundToStep(value, step) {
	    return Math.round(value / step) * step;
	}
	function infinityToMaxNumber(value) {
	    if (isFinite(value))
	        return value;
	    if (value < 0)
	        return -Number.MAX_VALUE;
	    return Number.MAX_VALUE;
	}
	function maxNumberToInfinity(value) {
	    if (Math.abs(value) < Number.MAX_VALUE)
	        return value;
	    return value * Infinity;
	}

	function extractClientCoordFromEvent(pointers, out) {
	    out.set(0, 0);
	    pointers.forEach((pointer) => {
	        out.x += pointer.clientX;
	        out.y += pointer.clientY;
	    });
	    out.x /= pointers.length;
	    out.y /= pointers.length;
	}

	function notSupportedInOrthographicCamera(camera, message) {
	    if (isOrthographicCamera(camera)) {
	        console.warn(`${message} is not supported in OrthographicCamera`);
	        return true;
	    }
	    return false;
	}

	function quatInvertCompat(target) {
	    if (target.invert) {
	        target.invert();
	    }
	    else {
	        target.inverse();
	    }
	    return target;
	}

	class EventDispatcher$2 {
	    constructor() {
	        this._listeners = {};
	    }
	    addEventListener(type, listener) {
	        const listeners = this._listeners;
	        if (listeners[type] === undefined)
	            listeners[type] = [];
	        if (listeners[type].indexOf(listener) === -1)
	            listeners[type].push(listener);
	    }
	    removeEventListener(type, listener) {
	        const listeners = this._listeners;
	        const listenerArray = listeners[type];
	        if (listenerArray !== undefined) {
	            const index = listenerArray.indexOf(listener);
	            if (index !== -1)
	                listenerArray.splice(index, 1);
	        }
	    }
	    removeAllEventListeners(type) {
	        if (!type) {
	            this._listeners = {};
	            return;
	        }
	        if (Array.isArray(this._listeners[type]))
	            this._listeners[type].length = 0;
	    }
	    dispatchEvent(event) {
	        const listeners = this._listeners;
	        const listenerArray = listeners[event.type];
	        if (listenerArray !== undefined) {
	            event.target = this;
	            const array = listenerArray.slice(0);
	            for (let i = 0, l = array.length; i < l; i++) {
	                array[i].call(this, event);
	            }
	        }
	    }
	}

	const isBrowser = typeof window !== 'undefined';
	const isMac = isBrowser && /Mac/.test(navigator.platform);
	const isPointerEventsNotSupported = !(isBrowser && 'PointerEvent' in window);
	const readonlyACTION = Object.freeze(ACTION);
	const TOUCH_DOLLY_FACTOR = 1 / 8;
	let THREE;
	let _ORIGIN;
	let _AXIS_Y;
	let _AXIS_Z;
	let _v2;
	let _v3A;
	let _v3B;
	let _v3C;
	let _xColumn;
	let _yColumn;
	let _zColumn;
	let _sphericalA;
	let _sphericalB;
	let _box3A;
	let _box3B;
	let _sphere$4;
	let _quaternionA;
	let _quaternionB;
	let _rotationMatrix;
	let _raycaster;
	class CameraControls extends EventDispatcher$2 {
	    constructor(camera, domElement) {
	        super();
	        this.minPolarAngle = 0;
	        this.maxPolarAngle = Math.PI;
	        this.minAzimuthAngle = -Infinity;
	        this.maxAzimuthAngle = Infinity;
	        this.minDistance = 0;
	        this.maxDistance = Infinity;
	        this.infinityDolly = false;
	        this.minZoom = 0.01;
	        this.maxZoom = Infinity;
	        this.dampingFactor = 0.05;
	        this.draggingDampingFactor = 0.25;
	        this.azimuthRotateSpeed = 1.0;
	        this.polarRotateSpeed = 1.0;
	        this.dollySpeed = 1.0;
	        this.truckSpeed = 2.0;
	        this.dollyToCursor = false;
	        this.dragToOffset = false;
	        this.verticalDragToForward = false;
	        this.boundaryFriction = 0.0;
	        this.restThreshold = 0.01;
	        this.colliderMeshes = [];
	        this.cancel = () => { };
	        this._enabled = true;
	        this._state = ACTION.NONE;
	        this._viewport = null;
	        this._dollyControlAmount = 0;
	        this._hasRested = true;
	        this._boundaryEnclosesCamera = false;
	        this._needsUpdate = true;
	        this._updatedLastTime = false;
	        this._elementRect = new DOMRect();
	        this._activePointers = [];
	        this._truckInternal = (deltaX, deltaY, dragToOffset) => {
	            if (isPerspectiveCamera(this._camera)) {
	                const offset = _v3A.copy(this._camera.position).sub(this._target);
	                const fov = this._camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD;
	                const targetDistance = offset.length() * Math.tan(fov * 0.5);
	                const truckX = (this.truckSpeed * deltaX * targetDistance / this._elementRect.height);
	                const pedestalY = (this.truckSpeed * deltaY * targetDistance / this._elementRect.height);
	                if (this.verticalDragToForward) {
	                    dragToOffset ?
	                        this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) :
	                        this.truck(truckX, 0, true);
	                    this.forward(-pedestalY, true);
	                }
	                else {
	                    dragToOffset ?
	                        this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) :
	                        this.truck(truckX, pedestalY, true);
	                }
	            }
	            else if (isOrthographicCamera(this._camera)) {
	                const camera = this._camera;
	                const truckX = deltaX * (camera.right - camera.left) / camera.zoom / this._elementRect.width;
	                const pedestalY = deltaY * (camera.top - camera.bottom) / camera.zoom / this._elementRect.height;
	                dragToOffset ?
	                    this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) :
	                    this.truck(truckX, pedestalY, true);
	            }
	        };
	        this._rotateInternal = (deltaX, deltaY) => {
	            const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height;
	            const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;
	            this.rotate(theta, phi, true);
	        };
	        this._dollyInternal = (delta, x, y) => {
	            const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);
	            const distance = this._sphericalEnd.radius * dollyScale;
	            const prevRadius = this._sphericalEnd.radius;
	            const signedPrevRadius = prevRadius * (delta >= 0 ? -1 : 1);
	            this.dollyTo(distance);
	            if (this.infinityDolly && (distance < this.minDistance || this.maxDistance === this.minDistance)) {
	                this._camera.getWorldDirection(_v3A);
	                this._targetEnd.add(_v3A.normalize().multiplyScalar(signedPrevRadius));
	                this._target.add(_v3A.normalize().multiplyScalar(signedPrevRadius));
	            }
	            if (this.dollyToCursor) {
	                this._dollyControlAmount += this._sphericalEnd.radius - prevRadius;
	                if (this.infinityDolly && (distance < this.minDistance || this.maxDistance === this.minDistance)) {
	                    this._dollyControlAmount -= signedPrevRadius;
	                }
	                this._dollyControlCoord.set(x, y);
	            }
	            return;
	        };
	        this._zoomInternal = (delta, x, y) => {
	            const zoomScale = Math.pow(0.95, delta * this.dollySpeed);
	            this.zoomTo(this._zoom * zoomScale);
	            if (this.dollyToCursor) {
	                this._dollyControlAmount = this._zoomEnd;
	                this._dollyControlCoord.set(x, y);
	            }
	            return;
	        };
	        if (typeof THREE === 'undefined') {
	            console.error('camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.');
	        }
	        this._camera = camera;
	        this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);
	        this._yAxisUpSpaceInverse = quatInvertCompat(this._yAxisUpSpace.clone());
	        this._state = ACTION.NONE;
	        this._domElement = domElement;
	        this._domElement.style.touchAction = 'none';
	        this._domElement.style.userSelect = 'none';
	        this._domElement.style.webkitUserSelect = 'none';
	        this._target = new THREE.Vector3();
	        this._targetEnd = this._target.clone();
	        this._focalOffset = new THREE.Vector3();
	        this._focalOffsetEnd = this._focalOffset.clone();
	        this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));
	        this._sphericalEnd = this._spherical.clone();
	        this._zoom = this._camera.zoom;
	        this._zoomEnd = this._zoom;
	        this._nearPlaneCorners = [
	            new THREE.Vector3(),
	            new THREE.Vector3(),
	            new THREE.Vector3(),
	            new THREE.Vector3(),
	        ];
	        this._updateNearPlaneCorners();
	        this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));
	        this._target0 = this._target.clone();
	        this._position0 = this._camera.position.clone();
	        this._zoom0 = this._zoom;
	        this._focalOffset0 = this._focalOffset.clone();
	        this._dollyControlAmount = 0;
	        this._dollyControlCoord = new THREE.Vector2();
	        this.mouseButtons = {
	            left: ACTION.ROTATE,
	            middle: ACTION.DOLLY,
	            right: ACTION.TRUCK,
	            wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY :
	                isOrthographicCamera(this._camera) ? ACTION.ZOOM :
	                    ACTION.NONE,
	            shiftLeft: ACTION.NONE,
	        };
	        this.touches = {
	            one: ACTION.TOUCH_ROTATE,
	            two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK :
	                isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK :
	                    ACTION.NONE,
	            three: ACTION.TOUCH_TRUCK,
	        };
	        if (this._domElement) {
	            const dragStartPosition = new THREE.Vector2();
	            const lastDragPosition = new THREE.Vector2();
	            const dollyStart = new THREE.Vector2();
	            const onPointerDown = (event) => {
	                if (!this._enabled)
	                    return;
	                const pointer = {
	                    pointerId: event.pointerId,
	                    clientX: event.clientX,
	                    clientY: event.clientY,
	                };
	                this._activePointers.push(pointer);
	                switch (event.button) {
	                    case THREE.MOUSE.LEFT:
	                        this._state = event.shiftKey ? this.mouseButtons.shiftLeft : this.mouseButtons.left;
	                        break;
	                    case THREE.MOUSE.MIDDLE:
	                        this._state = this.mouseButtons.middle;
	                        break;
	                    case THREE.MOUSE.RIGHT:
	                        this._state = this.mouseButtons.right;
	                        break;
	                }
	                if (event.pointerType === 'touch') {
	                    switch (this._activePointers.length) {
	                        case 1:
	                            this._state = this.touches.one;
	                            break;
	                        case 2:
	                            this._state = this.touches.two;
	                            break;
	                        case 3:
	                            this._state = this.touches.three;
	                            break;
	                    }
	                }
	                this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });
	                this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);
	                this._domElement.ownerDocument.addEventListener('pointermove', onPointerMove, { passive: false });
	                this._domElement.ownerDocument.addEventListener('pointerup', onPointerUp);
	                startDragging();
	            };
	            const onMouseDown = (event) => {
	                if (!this._enabled)
	                    return;
	                const pointer = {
	                    pointerId: 0,
	                    clientX: event.clientX,
	                    clientY: event.clientY,
	                };
	                this._activePointers.push(pointer);
	                switch (event.button) {
	                    case THREE.MOUSE.LEFT:
	                        this._state = event.shiftKey ? this.mouseButtons.shiftLeft : this.mouseButtons.left;
	                        break;
	                    case THREE.MOUSE.MIDDLE:
	                        this._state = this.mouseButtons.middle;
	                        break;
	                    case THREE.MOUSE.RIGHT:
	                        this._state = this.mouseButtons.right;
	                        break;
	                }
	                this._domElement.ownerDocument.removeEventListener('mousemove', onMouseMove);
	                this._domElement.ownerDocument.removeEventListener('mouseup', onMouseUp);
	                this._domElement.ownerDocument.addEventListener('mousemove', onMouseMove);
	                this._domElement.ownerDocument.addEventListener('mouseup', onMouseUp);
	                startDragging();
	            };
	            const onTouchStart = (event) => {
	                if (!this._enabled)
	                    return;
	                event.preventDefault();
	                Array.prototype.forEach.call(event.changedTouches, (touch) => {
	                    const pointer = {
	                        pointerId: touch.identifier,
	                        clientX: touch.clientX,
	                        clientY: touch.clientY,
	                    };
	                    this._activePointers.push(pointer);
	                });
	                switch (this._activePointers.length) {
	                    case 1:
	                        this._state = this.touches.one;
	                        break;
	                    case 2:
	                        this._state = this.touches.two;
	                        break;
	                    case 3:
	                        this._state = this.touches.three;
	                        break;
	                }
	                this._domElement.ownerDocument.removeEventListener('touchmove', onTouchMove, { passive: false });
	                this._domElement.ownerDocument.removeEventListener('touchend', onTouchEnd);
	                this._domElement.ownerDocument.addEventListener('touchmove', onTouchMove, { passive: false });
	                this._domElement.ownerDocument.addEventListener('touchend', onTouchEnd);
	                startDragging();
	            };
	            const onPointerMove = (event) => {
	                if (event.cancelable)
	                    event.preventDefault();
	                const pointerId = event.pointerId;
	                const pointer = this._findPointerById(pointerId);
	                if (!pointer)
	                    return;
	                pointer.clientX = event.clientX;
	                pointer.clientY = event.clientY;
	                dragging();
	            };
	            const onMouseMove = (event) => {
	                const pointer = this._findPointerById(0);
	                if (!pointer)
	                    return;
	                pointer.clientX = event.clientX;
	                pointer.clientY = event.clientY;
	                dragging();
	            };
	            const onTouchMove = (event) => {
	                if (event.cancelable)
	                    event.preventDefault();
	                Array.prototype.forEach.call(event.changedTouches, (touch) => {
	                    const pointerId = touch.identifier;
	                    const pointer = this._findPointerById(pointerId);
	                    if (!pointer)
	                        return;
	                    pointer.clientX = touch.clientX;
	                    pointer.clientY = touch.clientY;
	                });
	                dragging();
	            };
	            const onPointerUp = (event) => {
	                const pointerId = event.pointerId;
	                const pointer = this._findPointerById(pointerId);
	                pointer && this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
	                if (event.pointerType === 'touch') {
	                    switch (this._activePointers.length) {
	                        case 0:
	                            this._state = ACTION.NONE;
	                            break;
	                        case 1:
	                            this._state = this.touches.one;
	                            break;
	                        case 2:
	                            this._state = this.touches.two;
	                            break;
	                        case 3:
	                            this._state = this.touches.three;
	                            break;
	                    }
	                }
	                else {
	                    this._state = ACTION.NONE;
	                }
	                endDragging();
	            };
	            const onMouseUp = () => {
	                const pointer = this._findPointerById(0);
	                pointer && this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
	                this._state = ACTION.NONE;
	                endDragging();
	            };
	            const onTouchEnd = (event) => {
	                Array.prototype.forEach.call(event.changedTouches, (touch) => {
	                    const pointerId = touch.identifier;
	                    const pointer = this._findPointerById(pointerId);
	                    pointer && this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
	                });
	                switch (this._activePointers.length) {
	                    case 0:
	                        this._state = ACTION.NONE;
	                        break;
	                    case 1:
	                        this._state = this.touches.one;
	                        break;
	                    case 2:
	                        this._state = this.touches.two;
	                        break;
	                    case 3:
	                        this._state = this.touches.three;
	                        break;
	                }
	                endDragging();
	            };
	            let lastScrollTimeStamp = -1;
	            const onMouseWheel = (event) => {
	                if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)
	                    return;
	                event.preventDefault();
	                if (this.dollyToCursor ||
	                    this.mouseButtons.wheel === ACTION.ROTATE ||
	                    this.mouseButtons.wheel === ACTION.TRUCK) {
	                    const now = performance.now();
	                    if (lastScrollTimeStamp - now < 1000)
	                        this._getClientRect(this._elementRect);
	                    lastScrollTimeStamp = now;
	                }
	                const deltaYFactor = isMac ? -1 : -3;
	                const delta = (event.deltaMode === 1) ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);
	                const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
	                const y = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
	                switch (this.mouseButtons.wheel) {
	                    case ACTION.ROTATE: {
	                        this._rotateInternal(event.deltaX, event.deltaY);
	                        break;
	                    }
	                    case ACTION.TRUCK: {
	                        this._truckInternal(event.deltaX, event.deltaY, false);
	                        break;
	                    }
	                    case ACTION.OFFSET: {
	                        this._truckInternal(event.deltaX, event.deltaY, true);
	                        break;
	                    }
	                    case ACTION.DOLLY: {
	                        this._dollyInternal(-delta, x, y);
	                        break;
	                    }
	                    case ACTION.ZOOM: {
	                        this._zoomInternal(-delta, x, y);
	                        break;
	                    }
	                }
	                this.dispatchEvent({ type: 'control' });
	            };
	            const onContextMenu = (event) => {
	                if (!this._enabled)
	                    return;
	                event.preventDefault();
	            };
	            const startDragging = () => {
	                if (!this._enabled)
	                    return;
	                extractClientCoordFromEvent(this._activePointers, _v2);
	                this._getClientRect(this._elementRect);
	                dragStartPosition.copy(_v2);
	                lastDragPosition.copy(_v2);
	                const isMultiTouch = this._activePointers.length >= 2;
	                if (isMultiTouch) {
	                    const dx = _v2.x - this._activePointers[1].clientX;
	                    const dy = _v2.y - this._activePointers[1].clientY;
	                    const distance = Math.sqrt(dx * dx + dy * dy);
	                    dollyStart.set(0, distance);
	                    const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;
	                    const y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
	                    lastDragPosition.set(x, y);
	                }
	                this.dispatchEvent({ type: 'controlstart' });
	            };
	            const dragging = () => {
	                if (!this._enabled)
	                    return;
	                extractClientCoordFromEvent(this._activePointers, _v2);
	                const deltaX = lastDragPosition.x - _v2.x;
	                const deltaY = lastDragPosition.y - _v2.y;
	                lastDragPosition.copy(_v2);
	                switch (this._state) {
	                    case ACTION.ROTATE:
	                    case ACTION.TOUCH_ROTATE: {
	                        this._rotateInternal(deltaX, deltaY);
	                        break;
	                    }
	                    case ACTION.DOLLY:
	                    case ACTION.ZOOM: {
	                        const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
	                        const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
	                        this._state === ACTION.DOLLY ?
	                            this._dollyInternal(deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY) :
	                            this._zoomInternal(deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
	                        break;
	                    }
	                    case ACTION.TOUCH_DOLLY:
	                    case ACTION.TOUCH_ZOOM:
	                    case ACTION.TOUCH_DOLLY_TRUCK:
	                    case ACTION.TOUCH_ZOOM_TRUCK:
	                    case ACTION.TOUCH_DOLLY_OFFSET:
	                    case ACTION.TOUCH_ZOOM_OFFSET: {
	                        const dx = _v2.x - this._activePointers[1].clientX;
	                        const dy = _v2.y - this._activePointers[1].clientY;
	                        const distance = Math.sqrt(dx * dx + dy * dy);
	                        const dollyDelta = dollyStart.y - distance;
	                        dollyStart.set(0, distance);
	                        const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
	                        const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
	                        this._state === ACTION.TOUCH_DOLLY ||
	                            this._state === ACTION.TOUCH_DOLLY_TRUCK ||
	                            this._state === ACTION.TOUCH_DOLLY_OFFSET ?
	                            this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY) :
	                            this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
	                        if (this._state === ACTION.TOUCH_DOLLY_TRUCK ||
	                            this._state === ACTION.TOUCH_ZOOM_TRUCK) {
	                            this._truckInternal(deltaX, deltaY, false);
	                        }
	                        else if (this._state === ACTION.TOUCH_DOLLY_OFFSET ||
	                            this._state === ACTION.TOUCH_ZOOM_OFFSET) {
	                            this._truckInternal(deltaX, deltaY, true);
	                        }
	                        break;
	                    }
	                    case ACTION.TRUCK:
	                    case ACTION.TOUCH_TRUCK: {
	                        this._truckInternal(deltaX, deltaY, false);
	                        break;
	                    }
	                    case ACTION.OFFSET:
	                    case ACTION.TOUCH_OFFSET: {
	                        this._truckInternal(deltaX, deltaY, true);
	                        break;
	                    }
	                }
	                this.dispatchEvent({ type: 'control' });
	            };
	            const endDragging = () => {
	                extractClientCoordFromEvent(this._activePointers, _v2);
	                lastDragPosition.copy(_v2);
	                if (this._activePointers.length === 0) {
	                    this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });
	                    this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);
	                    this._domElement.ownerDocument.removeEventListener('touchmove', onTouchMove, { passive: false });
	                    this._domElement.ownerDocument.removeEventListener('touchend', onTouchEnd);
	                    this.dispatchEvent({ type: 'controlend' });
	                }
	            };
	            this._domElement.addEventListener('pointerdown', onPointerDown);
	            isPointerEventsNotSupported && this._domElement.addEventListener('mousedown', onMouseDown);
	            isPointerEventsNotSupported && this._domElement.addEventListener('touchstart', onTouchStart);
	            this._domElement.addEventListener('pointercancel', onPointerUp);
	            this._domElement.addEventListener('wheel', onMouseWheel, { passive: false });
	            this._domElement.addEventListener('contextmenu', onContextMenu);
	            this._removeAllEventListeners = () => {
	                this._domElement.removeEventListener('pointerdown', onPointerDown);
	                this._domElement.removeEventListener('mousedown', onMouseDown);
	                this._domElement.removeEventListener('touchstart', onTouchStart);
	                this._domElement.removeEventListener('pointercancel', onPointerUp);
	                this._domElement.removeEventListener('wheel', onMouseWheel, { passive: false });
	                this._domElement.removeEventListener('contextmenu', onContextMenu);
	                this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });
	                this._domElement.ownerDocument.removeEventListener('mousemove', onMouseMove);
	                this._domElement.ownerDocument.removeEventListener('touchmove', onTouchMove, { passive: false });
	                this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);
	                this._domElement.ownerDocument.removeEventListener('mouseup', onMouseUp);
	                this._domElement.ownerDocument.removeEventListener('touchend', onTouchEnd);
	            };
	            this.cancel = () => {
	                if (this._state === ACTION.NONE)
	                    return;
	                this._state = ACTION.NONE;
	                this._activePointers.length = 0;
	                endDragging();
	            };
	        }
	        this.update(0);
	    }
	    static install(libs) {
	        THREE = libs.THREE;
	        _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));
	        _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));
	        _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));
	        _v2 = new THREE.Vector2();
	        _v3A = new THREE.Vector3();
	        _v3B = new THREE.Vector3();
	        _v3C = new THREE.Vector3();
	        _xColumn = new THREE.Vector3();
	        _yColumn = new THREE.Vector3();
	        _zColumn = new THREE.Vector3();
	        _sphericalA = new THREE.Spherical();
	        _sphericalB = new THREE.Spherical();
	        _box3A = new THREE.Box3();
	        _box3B = new THREE.Box3();
	        _sphere$4 = new THREE.Sphere();
	        _quaternionA = new THREE.Quaternion();
	        _quaternionB = new THREE.Quaternion();
	        _rotationMatrix = new THREE.Matrix4();
	        _raycaster = new THREE.Raycaster();
	    }
	    static get ACTION() {
	        return readonlyACTION;
	    }
	    get camera() {
	        return this._camera;
	    }
	    set camera(camera) {
	        this._camera = camera;
	        this.updateCameraUp();
	        this._camera.updateProjectionMatrix();
	        this._updateNearPlaneCorners();
	        this._needsUpdate = true;
	    }
	    get enabled() {
	        return this._enabled;
	    }
	    set enabled(enabled) {
	        this._enabled = enabled;
	        if (enabled) {
	            this._domElement.style.touchAction = 'none';
	            this._domElement.style.userSelect = 'none';
	            this._domElement.style.webkitUserSelect = 'none';
	        }
	        else {
	            this.cancel();
	            this._domElement.style.touchAction = '';
	            this._domElement.style.userSelect = '';
	            this._domElement.style.webkitUserSelect = '';
	        }
	    }
	    get active() {
	        return !this._hasRested;
	    }
	    get currentAction() {
	        return this._state;
	    }
	    get distance() {
	        return this._spherical.radius;
	    }
	    set distance(distance) {
	        if (this._spherical.radius === distance &&
	            this._sphericalEnd.radius === distance)
	            return;
	        this._spherical.radius = distance;
	        this._sphericalEnd.radius = distance;
	        this._needsUpdate = true;
	    }
	    get azimuthAngle() {
	        return this._spherical.theta;
	    }
	    set azimuthAngle(azimuthAngle) {
	        if (this._spherical.theta === azimuthAngle &&
	            this._sphericalEnd.theta === azimuthAngle)
	            return;
	        this._spherical.theta = azimuthAngle;
	        this._sphericalEnd.theta = azimuthAngle;
	        this._needsUpdate = true;
	    }
	    get polarAngle() {
	        return this._spherical.phi;
	    }
	    set polarAngle(polarAngle) {
	        if (this._spherical.phi === polarAngle &&
	            this._sphericalEnd.phi === polarAngle)
	            return;
	        this._spherical.phi = polarAngle;
	        this._sphericalEnd.phi = polarAngle;
	        this._needsUpdate = true;
	    }
	    get boundaryEnclosesCamera() {
	        return this._boundaryEnclosesCamera;
	    }
	    set boundaryEnclosesCamera(boundaryEnclosesCamera) {
	        this._boundaryEnclosesCamera = boundaryEnclosesCamera;
	        this._needsUpdate = true;
	    }
	    addEventListener(type, listener) {
	        super.addEventListener(type, listener);
	    }
	    removeEventListener(type, listener) {
	        super.removeEventListener(type, listener);
	    }
	    rotate(azimuthAngle, polarAngle, enableTransition = false) {
	        return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);
	    }
	    rotateAzimuthTo(azimuthAngle, enableTransition = false) {
	        return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);
	    }
	    rotatePolarTo(polarAngle, enableTransition = false) {
	        return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);
	    }
	    rotateTo(azimuthAngle, polarAngle, enableTransition = false) {
	        const theta = THREE.MathUtils.clamp(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);
	        const phi = THREE.MathUtils.clamp(polarAngle, this.minPolarAngle, this.maxPolarAngle);
	        this._sphericalEnd.theta = theta;
	        this._sphericalEnd.phi = phi;
	        this._sphericalEnd.makeSafe();
	        this._needsUpdate = true;
	        if (!enableTransition) {
	            this._spherical.theta = this._sphericalEnd.theta;
	            this._spherical.phi = this._sphericalEnd.phi;
	        }
	        const resolveImmediately = !enableTransition ||
	            approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&
	                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
	        return this._createOnRestPromise(resolveImmediately);
	    }
	    dolly(distance, enableTransition = false) {
	        return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);
	    }
	    dollyTo(distance, enableTransition = false) {
	        const lastRadius = this._sphericalEnd.radius;
	        const newRadius = THREE.MathUtils.clamp(distance, this.minDistance, this.maxDistance);
	        const hasCollider = this.colliderMeshes.length >= 1;
	        if (hasCollider) {
	            const maxDistanceByCollisionTest = this._collisionTest();
	            const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);
	            const isDollyIn = lastRadius > newRadius;
	            if (!isDollyIn && isCollided)
	                return Promise.resolve();
	            this._sphericalEnd.radius = Math.min(newRadius, maxDistanceByCollisionTest);
	        }
	        else {
	            this._sphericalEnd.radius = newRadius;
	        }
	        this._needsUpdate = true;
	        if (!enableTransition) {
	            this._spherical.radius = this._sphericalEnd.radius;
	        }
	        const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
	        return this._createOnRestPromise(resolveImmediately);
	    }
	    zoom(zoomStep, enableTransition = false) {
	        return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);
	    }
	    zoomTo(zoom, enableTransition = false) {
	        this._zoomEnd = THREE.MathUtils.clamp(zoom, this.minZoom, this.maxZoom);
	        this._needsUpdate = true;
	        if (!enableTransition) {
	            this._zoom = this._zoomEnd;
	        }
	        const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);
	        return this._createOnRestPromise(resolveImmediately);
	    }
	    pan(x, y, enableTransition = false) {
	        console.warn('`pan` has been renamed to `truck`');
	        return this.truck(x, y, enableTransition);
	    }
	    truck(x, y, enableTransition = false) {
	        this._camera.updateMatrix();
	        _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
	        _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
	        _xColumn.multiplyScalar(x);
	        _yColumn.multiplyScalar(-y);
	        const offset = _v3A.copy(_xColumn).add(_yColumn);
	        const to = _v3B.copy(this._targetEnd).add(offset);
	        return this.moveTo(to.x, to.y, to.z, enableTransition);
	    }
	    forward(distance, enableTransition = false) {
	        _v3A.setFromMatrixColumn(this._camera.matrix, 0);
	        _v3A.crossVectors(this._camera.up, _v3A);
	        _v3A.multiplyScalar(distance);
	        const to = _v3B.copy(this._targetEnd).add(_v3A);
	        return this.moveTo(to.x, to.y, to.z, enableTransition);
	    }
	    moveTo(x, y, z, enableTransition = false) {
	        const offset = _v3A.set(x, y, z).sub(this._targetEnd);
	        this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);
	        this._needsUpdate = true;
	        if (!enableTransition) {
	            this._target.copy(this._targetEnd);
	        }
	        const resolveImmediately = !enableTransition ||
	            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&
	                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&
	                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
	        return this._createOnRestPromise(resolveImmediately);
	    }
	    fitToBox(box3OrObject, enableTransition, { paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {
	        const promises = [];
	        const aabb = box3OrObject.isBox3
	            ? _box3A.copy(box3OrObject)
	            : _box3A.setFromObject(box3OrObject);
	        if (aabb.isEmpty()) {
	            console.warn('camera-controls: fitTo() cannot be used with an empty box. Aborting');
	            Promise.resolve();
	        }
	        const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);
	        const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);
	        promises.push(this.rotateTo(theta, phi, enableTransition));
	        const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();
	        const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);
	        const viewFromPolar = approxEquals(Math.abs(normal.y), 1);
	        if (viewFromPolar) {
	            rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));
	        }
	        const bb = _box3B.makeEmpty();
	        _v3B.copy(aabb.min).applyQuaternion(rotation);
	        bb.expandByPoint(_v3B);
	        _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation);
	        bb.expandByPoint(_v3B);
	        _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation);
	        bb.expandByPoint(_v3B);
	        _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation);
	        bb.expandByPoint(_v3B);
	        _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation);
	        bb.expandByPoint(_v3B);
	        _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation);
	        bb.expandByPoint(_v3B);
	        _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation);
	        bb.expandByPoint(_v3B);
	        _v3B.copy(aabb.max).applyQuaternion(rotation);
	        bb.expandByPoint(_v3B);
	        rotation.setFromUnitVectors(_AXIS_Z, normal);
	        bb.min.x -= paddingLeft;
	        bb.min.y -= paddingBottom;
	        bb.max.x += paddingRight;
	        bb.max.y += paddingTop;
	        const bbSize = bb.getSize(_v3A);
	        const center = bb.getCenter(_v3B).applyQuaternion(rotation);
	        if (isPerspectiveCamera(this._camera)) {
	            const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z);
	            promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
	            promises.push(this.dollyTo(distance, enableTransition));
	            promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
	        }
	        else if (isOrthographicCamera(this._camera)) {
	            const camera = this._camera;
	            const width = camera.right - camera.left;
	            const height = camera.top - camera.bottom;
	            const zoom = Math.min(width / bbSize.x, height / bbSize.y);
	            promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
	            promises.push(this.zoomTo(zoom, enableTransition));
	            promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
	        }
	        return Promise.all(promises);
	    }
	    fitTo(box3OrObject, enableTransition, fitToOptions = {}) {
	        console.warn('camera-controls: fitTo() has been renamed to fitToBox()');
	        return this.fitToBox(box3OrObject, enableTransition, fitToOptions);
	    }
	    fitToSphere(sphereOrMesh, enableTransition) {
	        const promises = [];
	        const isSphere = sphereOrMesh instanceof THREE.Sphere;
	        const boundingSphere = isSphere ?
	            _sphere$4.copy(sphereOrMesh) :
	            createBoundingSphere(sphereOrMesh, _sphere$4);
	        promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));
	        if (isPerspectiveCamera(this._camera)) {
	            const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);
	            promises.push(this.dollyTo(distanceToFit, enableTransition));
	        }
	        else if (isOrthographicCamera(this._camera)) {
	            const width = this._camera.right - this._camera.left;
	            const height = this._camera.top - this._camera.bottom;
	            const diameter = 2 * boundingSphere.radius;
	            const zoom = Math.min(width / diameter, height / diameter);
	            promises.push(this.zoomTo(zoom, enableTransition));
	        }
	        promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
	        return Promise.all(promises);
	    }
	    setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {
	        const target = _v3B.set(targetX, targetY, targetZ);
	        const position = _v3A.set(positionX, positionY, positionZ);
	        this._targetEnd.copy(target);
	        this._sphericalEnd.setFromVector3(position.sub(target).applyQuaternion(this._yAxisUpSpace));
	        this.normalizeRotations();
	        this._needsUpdate = true;
	        if (!enableTransition) {
	            this._target.copy(this._targetEnd);
	            this._spherical.copy(this._sphericalEnd);
	        }
	        const resolveImmediately = !enableTransition ||
	            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&
	                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&
	                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) &&
	                approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&
	                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) &&
	                approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
	        return this._createOnRestPromise(resolveImmediately);
	    }
	    lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t, enableTransition = false) {
	        const targetA = _v3A.set(targetAX, targetAY, targetAZ);
	        const positionA = _v3B.set(positionAX, positionAY, positionAZ);
	        _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));
	        const targetB = _v3C.set(targetBX, targetBY, targetBZ);
	        const positionB = _v3B.set(positionBX, positionBY, positionBZ);
	        _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));
	        this._targetEnd.copy(targetA.lerp(targetB, t));
	        const deltaTheta = _sphericalB.theta - _sphericalA.theta;
	        const deltaPhi = _sphericalB.phi - _sphericalA.phi;
	        const deltaRadius = _sphericalB.radius - _sphericalA.radius;
	        this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t, _sphericalA.phi + deltaPhi * t, _sphericalA.theta + deltaTheta * t);
	        this.normalizeRotations();
	        this._needsUpdate = true;
	        if (!enableTransition) {
	            this._target.copy(this._targetEnd);
	            this._spherical.copy(this._sphericalEnd);
	        }
	        const resolveImmediately = !enableTransition ||
	            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&
	                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&
	                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) &&
	                approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&
	                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) &&
	                approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
	        return this._createOnRestPromise(resolveImmediately);
	    }
	    setPosition(positionX, positionY, positionZ, enableTransition = false) {
	        return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);
	    }
	    setTarget(targetX, targetY, targetZ, enableTransition = false) {
	        const pos = this.getPosition(_v3A);
	        return this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);
	    }
	    setFocalOffset(x, y, z, enableTransition = false) {
	        this._focalOffsetEnd.set(x, y, z);
	        this._needsUpdate = true;
	        if (!enableTransition) {
	            this._focalOffset.copy(this._focalOffsetEnd);
	        }
	        const resolveImmediately = !enableTransition ||
	            approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) &&
	                approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) &&
	                approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
	        return this._createOnRestPromise(resolveImmediately);
	    }
	    setOrbitPoint(targetX, targetY, targetZ) {
	        _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);
	        _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);
	        _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
	        const position = _v3A.set(targetX, targetY, targetZ);
	        const distance = position.distanceTo(this._camera.position);
	        const cameraToPoint = position.sub(this._camera.position);
	        _xColumn.multiplyScalar(cameraToPoint.x);
	        _yColumn.multiplyScalar(cameraToPoint.y);
	        _zColumn.multiplyScalar(cameraToPoint.z);
	        _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
	        _v3A.z = _v3A.z + distance;
	        this.dollyTo(distance, false);
	        this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);
	        this.moveTo(targetX, targetY, targetZ, false);
	    }
	    setBoundary(box3) {
	        if (!box3) {
	            this._boundary.min.set(-Infinity, -Infinity, -Infinity);
	            this._boundary.max.set(Infinity, Infinity, Infinity);
	            this._needsUpdate = true;
	            return;
	        }
	        this._boundary.copy(box3);
	        this._boundary.clampPoint(this._targetEnd, this._targetEnd);
	        this._needsUpdate = true;
	    }
	    setViewport(viewportOrX, y, width, height) {
	        if (viewportOrX === null) {
	            this._viewport = null;
	            return;
	        }
	        this._viewport = this._viewport || new THREE.Vector4();
	        if (typeof viewportOrX === 'number') {
	            this._viewport.set(viewportOrX, y, width, height);
	        }
	        else {
	            this._viewport.copy(viewportOrX);
	        }
	    }
	    getDistanceToFitBox(width, height, depth) {
	        if (notSupportedInOrthographicCamera(this._camera, 'getDistanceToFitBox'))
	            return this._spherical.radius;
	        const boundingRectAspect = width / height;
	        const fov = this._camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD;
	        const aspect = this._camera.aspect;
	        const heightToFit = boundingRectAspect < aspect ? height : width / aspect;
	        return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;
	    }
	    getDistanceToFit(width, height, depth) {
	        console.warn('camera-controls: getDistanceToFit() has been renamed to getDistanceToFitBox()');
	        return this.getDistanceToFitBox(width, height, depth);
	    }
	    getDistanceToFitSphere(radius) {
	        if (notSupportedInOrthographicCamera(this._camera, 'getDistanceToFitSphere'))
	            return this._spherical.radius;
	        const vFOV = this._camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD;
	        const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;
	        const fov = 1 < this._camera.aspect ? vFOV : hFOV;
	        return radius / (Math.sin(fov * 0.5));
	    }
	    getTarget(out) {
	        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
	        return _out.copy(this._targetEnd);
	    }
	    getPosition(out) {
	        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
	        return _out.setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).add(this._targetEnd);
	    }
	    getFocalOffset(out) {
	        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
	        return _out.copy(this._focalOffsetEnd);
	    }
	    normalizeRotations() {
	        this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;
	        if (this._sphericalEnd.theta < 0)
	            this._sphericalEnd.theta += PI_2;
	        this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);
	    }
	    reset(enableTransition = false) {
	        const promises = [
	            this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),
	            this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),
	            this.zoomTo(this._zoom0, enableTransition),
	        ];
	        return Promise.all(promises);
	    }
	    saveState() {
	        this._target0.copy(this._target);
	        this._position0.copy(this._camera.position);
	        this._zoom0 = this._zoom;
	    }
	    updateCameraUp() {
	        this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);
	        quatInvertCompat(this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace));
	    }
	    update(delta) {
	        const dampingFactor = this._state === ACTION.NONE ? this.dampingFactor : this.draggingDampingFactor;
	        const lerpRatio = Math.min(dampingFactor * delta * 60, 1);
	        const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;
	        const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;
	        const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;
	        const deltaTarget = _v3A.subVectors(this._targetEnd, this._target);
	        const deltaOffset = _v3B.subVectors(this._focalOffsetEnd, this._focalOffset);
	        if (!approxZero(deltaTheta) ||
	            !approxZero(deltaPhi) ||
	            !approxZero(deltaRadius) ||
	            !approxZero(deltaTarget.x) ||
	            !approxZero(deltaTarget.y) ||
	            !approxZero(deltaTarget.z) ||
	            !approxZero(deltaOffset.x) ||
	            !approxZero(deltaOffset.y) ||
	            !approxZero(deltaOffset.z)) {
	            this._spherical.set(this._spherical.radius + deltaRadius * lerpRatio, this._spherical.phi + deltaPhi * lerpRatio, this._spherical.theta + deltaTheta * lerpRatio);
	            this._target.add(deltaTarget.multiplyScalar(lerpRatio));
	            this._focalOffset.add(deltaOffset.multiplyScalar(lerpRatio));
	            this._needsUpdate = true;
	        }
	        else {
	            this._spherical.copy(this._sphericalEnd);
	            this._target.copy(this._targetEnd);
	            this._focalOffset.copy(this._focalOffsetEnd);
	        }
	        if (this._dollyControlAmount !== 0) {
	            if (isPerspectiveCamera(this._camera)) {
	                const camera = this._camera;
	                const direction = _v3A.setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate();
	                const planeX = _v3B.copy(direction).cross(camera.up).normalize();
	                if (planeX.lengthSq() === 0)
	                    planeX.x = 1.0;
	                const planeY = _v3C.crossVectors(planeX, direction);
	                const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD * 0.5);
	                const prevRadius = this._sphericalEnd.radius - this._dollyControlAmount;
	                const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;
	                const cursor = _v3A.copy(this._targetEnd)
	                    .add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect))
	                    .add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));
	                this._targetEnd.lerp(cursor, lerpRatio);
	                this._target.copy(this._targetEnd);
	            }
	            else if (isOrthographicCamera(this._camera)) {
	                const camera = this._camera;
	                const worldPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
	                const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);
	                const divisor = quaternion.dot(camera.up);
	                const distance = approxZero(divisor) ? -worldPosition.dot(camera.up) : -worldPosition.dot(camera.up) / divisor;
	                const cursor = _v3C.copy(worldPosition).add(quaternion.multiplyScalar(distance));
	                this._targetEnd.lerp(cursor, 1 - camera.zoom / this._dollyControlAmount);
	                this._target.copy(this._targetEnd);
	            }
	            this._dollyControlAmount = 0;
	        }
	        const maxDistance = this._collisionTest();
	        this._spherical.radius = Math.min(this._spherical.radius, maxDistance);
	        this._spherical.makeSafe();
	        this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);
	        this._camera.lookAt(this._target);
	        const affectOffset = !approxZero(this._focalOffset.x) ||
	            !approxZero(this._focalOffset.y) ||
	            !approxZero(this._focalOffset.z);
	        if (affectOffset) {
	            this._camera.updateMatrix();
	            _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
	            _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
	            _zColumn.setFromMatrixColumn(this._camera.matrix, 2);
	            _xColumn.multiplyScalar(this._focalOffset.x);
	            _yColumn.multiplyScalar(-this._focalOffset.y);
	            _zColumn.multiplyScalar(this._focalOffset.z);
	            _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
	            this._camera.position.add(_v3A);
	        }
	        if (this._boundaryEnclosesCamera) {
	            this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1.0);
	        }
	        const zoomDelta = this._zoomEnd - this._zoom;
	        this._zoom += zoomDelta * lerpRatio;
	        if (this._camera.zoom !== this._zoom) {
	            if (approxZero(zoomDelta))
	                this._zoom = this._zoomEnd;
	            this._camera.zoom = this._zoom;
	            this._camera.updateProjectionMatrix();
	            this._updateNearPlaneCorners();
	            this._needsUpdate = true;
	        }
	        const updated = this._needsUpdate;
	        if (updated && !this._updatedLastTime) {
	            this._hasRested = false;
	            this.dispatchEvent({ type: 'wake' });
	            this.dispatchEvent({ type: 'update' });
	        }
	        else if (updated) {
	            this.dispatchEvent({ type: 'update' });
	            if (approxZero(deltaTheta, this.restThreshold) &&
	                approxZero(deltaPhi, this.restThreshold) &&
	                approxZero(deltaRadius, this.restThreshold) &&
	                approxZero(deltaTarget.x, this.restThreshold) &&
	                approxZero(deltaTarget.y, this.restThreshold) &&
	                approxZero(deltaTarget.z, this.restThreshold) &&
	                approxZero(deltaOffset.x, this.restThreshold) &&
	                approxZero(deltaOffset.y, this.restThreshold) &&
	                approxZero(deltaOffset.z, this.restThreshold) &&
	                !this._hasRested) {
	                this._hasRested = true;
	                this.dispatchEvent({ type: 'rest' });
	            }
	        }
	        else if (!updated && this._updatedLastTime) {
	            this.dispatchEvent({ type: 'sleep' });
	        }
	        this._updatedLastTime = updated;
	        this._needsUpdate = false;
	        return updated;
	    }
	    toJSON() {
	        return JSON.stringify({
	            enabled: this._enabled,
	            minDistance: this.minDistance,
	            maxDistance: infinityToMaxNumber(this.maxDistance),
	            minZoom: this.minZoom,
	            maxZoom: infinityToMaxNumber(this.maxZoom),
	            minPolarAngle: this.minPolarAngle,
	            maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),
	            minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),
	            maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),
	            dampingFactor: this.dampingFactor,
	            draggingDampingFactor: this.draggingDampingFactor,
	            dollySpeed: this.dollySpeed,
	            truckSpeed: this.truckSpeed,
	            dollyToCursor: this.dollyToCursor,
	            verticalDragToForward: this.verticalDragToForward,
	            target: this._targetEnd.toArray(),
	            position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
	            zoom: this._zoomEnd,
	            focalOffset: this._focalOffsetEnd.toArray(),
	            target0: this._target0.toArray(),
	            position0: this._position0.toArray(),
	            zoom0: this._zoom0,
	            focalOffset0: this._focalOffset0.toArray(),
	        });
	    }
	    fromJSON(json, enableTransition = false) {
	        const obj = JSON.parse(json);
	        const position = _v3A.fromArray(obj.position);
	        this.enabled = obj.enabled;
	        this.minDistance = obj.minDistance;
	        this.maxDistance = maxNumberToInfinity(obj.maxDistance);
	        this.minZoom = obj.minZoom;
	        this.maxZoom = maxNumberToInfinity(obj.maxZoom);
	        this.minPolarAngle = obj.minPolarAngle;
	        this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);
	        this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);
	        this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);
	        this.dampingFactor = obj.dampingFactor;
	        this.draggingDampingFactor = obj.draggingDampingFactor;
	        this.dollySpeed = obj.dollySpeed;
	        this.truckSpeed = obj.truckSpeed;
	        this.dollyToCursor = obj.dollyToCursor;
	        this.verticalDragToForward = obj.verticalDragToForward;
	        this._target0.fromArray(obj.target0);
	        this._position0.fromArray(obj.position0);
	        this._zoom0 = obj.zoom0;
	        this._focalOffset0.fromArray(obj.focalOffset0);
	        this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);
	        _sphericalA.setFromVector3(position.sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));
	        this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);
	        this.zoomTo(obj.zoom, enableTransition);
	        this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);
	        this._needsUpdate = true;
	    }
	    dispose() {
	        this._removeAllEventListeners();
	    }
	    _findPointerById(pointerId) {
	        let pointer = null;
	        this._activePointers.some((activePointer) => {
	            if (activePointer.pointerId === pointerId) {
	                pointer = activePointer;
	                return true;
	            }
	            return false;
	        });
	        return pointer;
	    }
	    _encloseToBoundary(position, offset, friction) {
	        const offsetLength2 = offset.lengthSq();
	        if (offsetLength2 === 0.0) {
	            return position;
	        }
	        const newTarget = _v3B.copy(offset).add(position);
	        const clampedTarget = this._boundary.clampPoint(newTarget, _v3C);
	        const deltaClampedTarget = clampedTarget.sub(newTarget);
	        const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq();
	        if (deltaClampedTargetLength2 === 0.0) {
	            return position.add(offset);
	        }
	        else if (deltaClampedTargetLength2 === offsetLength2) {
	            return position;
	        }
	        else if (friction === 0.0) {
	            return position.add(offset).add(deltaClampedTarget);
	        }
	        else {
	            const offsetFactor = 1.0 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);
	            return position
	                .add(_v3B.copy(offset).multiplyScalar(offsetFactor))
	                .add(deltaClampedTarget.multiplyScalar(1.0 - friction));
	        }
	    }
	    _updateNearPlaneCorners() {
	        if (isPerspectiveCamera(this._camera)) {
	            const camera = this._camera;
	            const near = camera.near;
	            const fov = camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD;
	            const heightHalf = Math.tan(fov * 0.5) * near;
	            const widthHalf = heightHalf * camera.aspect;
	            this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);
	            this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);
	            this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);
	            this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);
	        }
	        else if (isOrthographicCamera(this._camera)) {
	            const camera = this._camera;
	            const zoomInv = 1 / camera.zoom;
	            const left = camera.left * zoomInv;
	            const right = camera.right * zoomInv;
	            const top = camera.top * zoomInv;
	            const bottom = camera.bottom * zoomInv;
	            this._nearPlaneCorners[0].set(left, top, 0);
	            this._nearPlaneCorners[1].set(right, top, 0);
	            this._nearPlaneCorners[2].set(right, bottom, 0);
	            this._nearPlaneCorners[3].set(left, bottom, 0);
	        }
	    }
	    _collisionTest() {
	        let distance = Infinity;
	        const hasCollider = this.colliderMeshes.length >= 1;
	        if (!hasCollider)
	            return distance;
	        if (notSupportedInOrthographicCamera(this._camera, '_collisionTest'))
	            return distance;
	        const direction = _v3A.setFromSpherical(this._spherical).divideScalar(this._spherical.radius);
	        _rotationMatrix.lookAt(_ORIGIN, direction, this._camera.up);
	        for (let i = 0; i < 4; i++) {
	            const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i]);
	            nearPlaneCorner.applyMatrix4(_rotationMatrix);
	            const origin = _v3C.addVectors(this._target, nearPlaneCorner);
	            _raycaster.set(origin, direction);
	            _raycaster.far = this._spherical.radius + 1;
	            const intersects = _raycaster.intersectObjects(this.colliderMeshes);
	            if (intersects.length !== 0 && intersects[0].distance < distance) {
	                distance = intersects[0].distance;
	            }
	        }
	        return distance;
	    }
	    _getClientRect(target) {
	        const rect = this._domElement.getBoundingClientRect();
	        target.x = rect.left;
	        target.y = rect.top;
	        if (this._viewport) {
	            target.x += this._viewport.x;
	            target.y += rect.height - this._viewport.w - this._viewport.y;
	            target.width = this._viewport.z;
	            target.height = this._viewport.w;
	        }
	        else {
	            target.width = rect.width;
	            target.height = rect.height;
	        }
	        return target;
	    }
	    _createOnRestPromise(resolveImmediately) {
	        if (resolveImmediately)
	            return Promise.resolve();
	        this._hasRested = false;
	        this.dispatchEvent({ type: 'transitionstart' });
	        return new Promise((resolve) => {
	            const onResolve = () => {
	                this.removeEventListener('rest', onResolve);
	                resolve();
	            };
	            this.addEventListener('rest', onResolve);
	        });
	    }
	    _removeAllEventListeners() { }
	}
	function createBoundingSphere(object3d, out) {
	    const boundingSphere = out;
	    const center = boundingSphere.center;
	    _box3A.makeEmpty();
	    object3d.traverseVisible((object) => {
	        if (!object.isMesh)
	            return;
	        _box3A.expandByObject(object);
	    });
	    _box3A.getCenter(center);
	    let maxRadiusSq = 0;
	    object3d.traverseVisible((object) => {
	        if (!object.isMesh)
	            return;
	        const mesh = object;
	        const geometry = mesh.geometry.clone();
	        geometry.applyMatrix4(mesh.matrixWorld);
	        if (geometry.isBufferGeometry) {
	            const bufferGeometry = geometry;
	            const position = bufferGeometry.attributes.position;
	            for (let i = 0, l = position.count; i < l; i++) {
	                _v3A.fromBufferAttribute(position, i);
	                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));
	            }
	        }
	        else {
	            const position = geometry.attributes.position;
	            const vector = new THREE.Vector3();
	            for (let i = 0, l = position.count; i < l; i++) {
	                vector.fromBufferAttribute(position, i);
	                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
	            }
	        }
	    });
	    boundingSphere.radius = Math.sqrt(maxRadiusSq);
	    return boundingSphere;
	}

	/**
	 * @license
	 * Copyright 2010-2022 Three.js Authors
	 * SPDX-License-Identifier: MIT
	 */
	const REVISION = '139';
	const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
	const CullFaceNone = 0;
	const CullFaceBack = 1;
	const CullFaceFront = 2;
	const PCFShadowMap = 1;
	const PCFSoftShadowMap = 2;
	const VSMShadowMap = 3;
	const FrontSide = 0;
	const BackSide = 1;
	const DoubleSide = 2;
	const FlatShading = 1;
	const NoBlending = 0;
	const NormalBlending = 1;
	const AdditiveBlending = 2;
	const SubtractiveBlending = 3;
	const MultiplyBlending = 4;
	const CustomBlending = 5;
	const AddEquation = 100;
	const SubtractEquation = 101;
	const ReverseSubtractEquation = 102;
	const MinEquation = 103;
	const MaxEquation = 104;
	const ZeroFactor = 200;
	const OneFactor = 201;
	const SrcColorFactor = 202;
	const OneMinusSrcColorFactor = 203;
	const SrcAlphaFactor = 204;
	const OneMinusSrcAlphaFactor = 205;
	const DstAlphaFactor = 206;
	const OneMinusDstAlphaFactor = 207;
	const DstColorFactor = 208;
	const OneMinusDstColorFactor = 209;
	const SrcAlphaSaturateFactor = 210;
	const NeverDepth = 0;
	const AlwaysDepth = 1;
	const LessDepth = 2;
	const LessEqualDepth = 3;
	const EqualDepth = 4;
	const GreaterEqualDepth = 5;
	const GreaterDepth = 6;
	const NotEqualDepth = 7;
	const MultiplyOperation = 0;
	const MixOperation = 1;
	const AddOperation = 2;
	const NoToneMapping = 0;
	const LinearToneMapping = 1;
	const ReinhardToneMapping = 2;
	const CineonToneMapping = 3;
	const ACESFilmicToneMapping = 4;
	const CustomToneMapping = 5;

	const UVMapping = 300;
	const CubeReflectionMapping = 301;
	const CubeRefractionMapping = 302;
	const EquirectangularReflectionMapping = 303;
	const EquirectangularRefractionMapping = 304;
	const CubeUVReflectionMapping = 306;
	const RepeatWrapping = 1000;
	const ClampToEdgeWrapping = 1001;
	const MirroredRepeatWrapping = 1002;
	const NearestFilter = 1003;
	const NearestMipmapNearestFilter = 1004;
	const NearestMipmapLinearFilter = 1005;
	const LinearFilter = 1006;
	const LinearMipmapNearestFilter = 1007;
	const LinearMipmapLinearFilter = 1008;
	const UnsignedByteType = 1009;
	const ByteType = 1010;
	const ShortType = 1011;
	const UnsignedShortType = 1012;
	const IntType = 1013;
	const UnsignedIntType = 1014;
	const FloatType = 1015;
	const HalfFloatType = 1016;
	const UnsignedShort4444Type = 1017;
	const UnsignedShort5551Type = 1018;
	const UnsignedInt248Type = 1020;
	const AlphaFormat = 1021;
	const RGBFormat = 1022;
	const RGBAFormat = 1023;
	const LuminanceFormat = 1024;
	const LuminanceAlphaFormat = 1025;
	const DepthFormat = 1026;
	const DepthStencilFormat = 1027;
	const RedFormat = 1028;
	const RedIntegerFormat = 1029;
	const RGFormat = 1030;
	const RGIntegerFormat = 1031;
	const RGBAIntegerFormat = 1033;

	const RGB_S3TC_DXT1_Format = 33776;
	const RGBA_S3TC_DXT1_Format = 33777;
	const RGBA_S3TC_DXT3_Format = 33778;
	const RGBA_S3TC_DXT5_Format = 33779;
	const RGB_PVRTC_4BPPV1_Format = 35840;
	const RGB_PVRTC_2BPPV1_Format = 35841;
	const RGBA_PVRTC_4BPPV1_Format = 35842;
	const RGBA_PVRTC_2BPPV1_Format = 35843;
	const RGB_ETC1_Format = 36196;
	const RGB_ETC2_Format = 37492;
	const RGBA_ETC2_EAC_Format = 37496;
	const RGBA_ASTC_4x4_Format = 37808;
	const RGBA_ASTC_5x4_Format = 37809;
	const RGBA_ASTC_5x5_Format = 37810;
	const RGBA_ASTC_6x5_Format = 37811;
	const RGBA_ASTC_6x6_Format = 37812;
	const RGBA_ASTC_8x5_Format = 37813;
	const RGBA_ASTC_8x6_Format = 37814;
	const RGBA_ASTC_8x8_Format = 37815;
	const RGBA_ASTC_10x5_Format = 37816;
	const RGBA_ASTC_10x6_Format = 37817;
	const RGBA_ASTC_10x8_Format = 37818;
	const RGBA_ASTC_10x10_Format = 37819;
	const RGBA_ASTC_12x10_Format = 37820;
	const RGBA_ASTC_12x12_Format = 37821;
	const RGBA_BPTC_Format = 36492;
	const LoopOnce = 2200;
	const LoopRepeat = 2201;
	const LoopPingPong = 2202;
	const InterpolateDiscrete = 2300;
	const InterpolateLinear = 2301;
	const InterpolateSmooth = 2302;
	const ZeroCurvatureEnding = 2400;
	const ZeroSlopeEnding = 2401;
	const WrapAroundEnding = 2402;
	const NormalAnimationBlendMode = 2500;
	const AdditiveAnimationBlendMode = 2501;
	const TrianglesDrawMode = 0;
	const TriangleStripDrawMode = 1;
	const TriangleFanDrawMode = 2;
	const LinearEncoding = 3000;
	const sRGBEncoding = 3001;
	const BasicDepthPacking = 3200;
	const RGBADepthPacking = 3201;
	const TangentSpaceNormalMap = 0;
	const ObjectSpaceNormalMap = 1;
	const SRGBColorSpace = 'srgb';
	const LinearSRGBColorSpace = 'srgb-linear';
	const KeepStencilOp = 7680;
	const AlwaysStencilFunc = 519;

	const StaticDrawUsage = 35044;
	const DynamicDrawUsage = 35048;
	const GLSL3 = '300 es';

	const _SRGBAFormat = 1035; // fallback for WebGL 1

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	class EventDispatcher$1 {

		addEventListener( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			const listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		}

		hasEventListener( type, listener ) {

			if ( this._listeners === undefined ) return false;

			const listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		}

		removeEventListener( type, listener ) {

			if ( this._listeners === undefined ) return;

			const listeners = this._listeners;
			const listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				const index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		}

		dispatchEvent( event ) {

			if ( this._listeners === undefined ) return;

			const listeners = this._listeners;
			const listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				// Make a copy, in case listeners are removed while iterating.
				const array = listenerArray.slice( 0 );

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

				event.target = null;

			}

		}

	}

	const _lut = [];

	for ( let i = 0; i < 256; i ++ ) {

		_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

	}

	let _seed = 1234567;


	const DEG2RAD = Math.PI / 180;
	const RAD2DEG = 180 / Math.PI;

	// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
	function generateUUID() {

		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
				_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
				_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
				_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

		// .toLowerCase() here flattens concatenated strings to save heap memory space.
		return uuid.toLowerCase();

	}

	function clamp( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	}

	// compute euclidean modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation
	function euclideanModulo( n, m ) {

		return ( ( n % m ) + m ) % m;

	}

	// Linear mapping from range <a1, a2> to range <b1, b2>
	function mapLinear( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	}

	// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
	function inverseLerp( x, y, value ) {

		if ( x !== y ) {

			return ( value - x ) / ( y - x );

		} else {

			return 0;

		}

	}

	// https://en.wikipedia.org/wiki/Linear_interpolation
	function lerp( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	}

	// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
	function damp( x, y, lambda, dt ) {

		return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

	}

	// https://www.desmos.com/calculator/vcsjnyz7x4
	function pingpong( x, length = 1 ) {

		return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

	}

	// http://en.wikipedia.org/wiki/Smoothstep
	function smoothstep( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	}

	function smootherstep( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	}

	// Random integer from <low, high> interval
	function randInt( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	}

	// Random float from <low, high> interval
	function randFloat( low, high ) {

		return low + Math.random() * ( high - low );

	}

	// Random float from <-range/2, range/2> interval
	function randFloatSpread( range ) {

		return range * ( 0.5 - Math.random() );

	}

	// Deterministic pseudo-random float in the interval [ 0, 1 ]
	function seededRandom( s ) {

		if ( s !== undefined ) _seed = s;

		// Mulberry32 generator

		let t = _seed += 0x6D2B79F5;

		t = Math.imul( t ^ t >>> 15, t | 1 );

		t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

		return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

	}

	function degToRad( degrees ) {

		return degrees * DEG2RAD;

	}

	function radToDeg( radians ) {

		return radians * RAD2DEG;

	}

	function isPowerOfTwo( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	}

	function ceilPowerOfTwo( value ) {

		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

	}

	function floorPowerOfTwo( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	}

	function setQuaternionFromProperEuler( q, a, b, c, order ) {

		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians

		const cos = Math.cos;
		const sin = Math.sin;

		const c2 = cos( b / 2 );
		const s2 = sin( b / 2 );

		const c13 = cos( ( a + c ) / 2 );
		const s13 = sin( ( a + c ) / 2 );

		const c1_3 = cos( ( a - c ) / 2 );
		const s1_3 = sin( ( a - c ) / 2 );

		const c3_1 = cos( ( c - a ) / 2 );
		const s3_1 = sin( ( c - a ) / 2 );

		switch ( order ) {

			case 'XYX':
				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
				break;

			case 'YZY':
				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
				break;

			case 'ZXZ':
				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
				break;

			case 'XZX':
				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
				break;

			case 'YXY':
				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
				break;

			case 'ZYZ':
				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
				break;

			default:
				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

		}

	}

	function denormalize$1( value, array ) {

		switch ( array.constructor ) {

			case Float32Array:

				return value;

			case Uint16Array:

				return value / 65535.0;

			case Uint8Array:

				return value / 255.0;

			case Int16Array:

				return Math.max( value / 32767.0, - 1.0 );

			case Int8Array:

				return Math.max( value / 127.0, - 1.0 );

			default:

				throw new Error( 'Invalid component type.' );

		}

	}

	function normalize( value, array ) {

		switch ( array.constructor ) {

			case Float32Array:

				return value;

			case Uint16Array:

				return Math.round( value * 65535.0 );

			case Uint8Array:

				return Math.round( value * 255.0 );

			case Int16Array:

				return Math.round( value * 32767.0 );

			case Int8Array:

				return Math.round( value * 127.0 );

			default:

				throw new Error( 'Invalid component type.' );

		}

	}

	var MathUtils = /*#__PURE__*/Object.freeze({
		__proto__: null,
		DEG2RAD: DEG2RAD,
		RAD2DEG: RAD2DEG,
		generateUUID: generateUUID,
		clamp: clamp,
		euclideanModulo: euclideanModulo,
		mapLinear: mapLinear,
		inverseLerp: inverseLerp,
		lerp: lerp,
		damp: damp,
		pingpong: pingpong,
		smoothstep: smoothstep,
		smootherstep: smootherstep,
		randInt: randInt,
		randFloat: randFloat,
		randFloatSpread: randFloatSpread,
		seededRandom: seededRandom,
		degToRad: degToRad,
		radToDeg: radToDeg,
		isPowerOfTwo: isPowerOfTwo,
		ceilPowerOfTwo: ceilPowerOfTwo,
		floorPowerOfTwo: floorPowerOfTwo,
		setQuaternionFromProperEuler: setQuaternionFromProperEuler,
		normalize: normalize,
		denormalize: denormalize$1
	});

	class Vector2 {

		constructor( x = 0, y = 0 ) {

			this.x = x;
			this.y = y;

		}

		get width() {

			return this.x;

		}

		set width( value ) {

			this.x = value;

		}

		get height() {

			return this.y;

		}

		set height( value ) {

			this.y = value;

		}

		set( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		}

		add( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		}

		sub( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		}

		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		applyMatrix3( m ) {

			const x = this.x, y = this.y;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y;

		}

		cross( v ) {

			return this.x * v.y - this.y * v.x;

		}

		lengthSq() {

			return this.x * this.x + this.y * this.y;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		angle() {

			// computes the angle in radians with respect to the positive x-axis

			const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

			return angle;

		}

		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		}

		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		}

		fromBufferAttribute( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		}

		rotateAround( center, angle ) {

			const c = Math.cos( angle ), s = Math.sin( angle );

			const x = this.x - center.x;
			const y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;

		}

	}

	Vector2.prototype.isVector2 = true;

	class Matrix3 {

		constructor() {

			this.elements = [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		}

		identity() {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		}

		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		}

		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrix3Column( this, 0 );
			yAxis.setFromMatrix3Column( this, 1 );
			zAxis.setFromMatrix3Column( this, 2 );

			return this;

		}

		setFromMatrix4( m ) {

			const me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		}

		multiply( m ) {

			return this.multiplyMatrices( this, m );

		}

		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		}

		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		}

		determinant() {

			const te = this.elements;

			const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		}

		invert() {

			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
				n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
				n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		}

		transpose() {

			let tmp;
			const m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		}

		getNormalMatrix( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).invert().transpose();

		}

		transposeIntoArray( r ) {

			const m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		}

		setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

			const c = Math.cos( rotation );
			const s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

			return this;

		}

		scale( sx, sy ) {

			const te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		}

		rotate( theta ) {

			const c = Math.cos( theta );
			const s = Math.sin( theta );

			const te = this.elements;

			const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		}

		translate( tx, ty ) {

			const te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		}

		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

		clone() {

			return new this.constructor().fromArray( this.elements );

		}

	}

	Matrix3.prototype.isMatrix3 = true;

	function arrayNeedsUint32( array ) {

		// assumes larger values usually on last

		for ( let i = array.length - 1; i >= 0; -- i ) {

			if ( array[ i ] > 65535 ) return true;

		}

		return false;

	}

	function createElementNS( name ) {

		return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

	}

	function SRGBToLinear( c ) {

		return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

	}

	function LinearToSRGB( c ) {

		return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

	}

	// JavaScript RGB-to-RGB transforms, defined as
	// FN[InputColorSpace][OutputColorSpace] callback functions.
	const FN = {
		[ SRGBColorSpace ]: { [ LinearSRGBColorSpace ]: SRGBToLinear },
		[ LinearSRGBColorSpace ]: { [ SRGBColorSpace ]: LinearToSRGB },
	};

	const ColorManagement = {

		legacyMode: true,

		get workingColorSpace() {

			return LinearSRGBColorSpace;

		},

		set workingColorSpace( colorSpace ) {

			console.warn( 'THREE.ColorManagement: .workingColorSpace is readonly.' );

		},

		convert: function ( color, sourceColorSpace, targetColorSpace ) {

			if ( this.legacyMode || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

				return color;

			}

			if ( FN[ sourceColorSpace ] && FN[ sourceColorSpace ][ targetColorSpace ] !== undefined ) {

				const fn = FN[ sourceColorSpace ][ targetColorSpace ];

				color.r = fn( color.r );
				color.g = fn( color.g );
				color.b = fn( color.b );

				return color;

			}

			throw new Error( 'Unsupported color space conversion.' );

		},

		fromWorkingColorSpace: function ( color, targetColorSpace ) {

			return this.convert( color, this.workingColorSpace, targetColorSpace );

		},

		toWorkingColorSpace: function ( color, sourceColorSpace ) {

			return this.convert( color, sourceColorSpace, this.workingColorSpace );

		},

	};

	const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	const _rgb = { r: 0, g: 0, b: 0 };
	const _hslA = { h: 0, s: 0, l: 0 };
	const _hslB = { h: 0, s: 0, l: 0 };

	function hue2rgb( p, q, t ) {

		if ( t < 0 ) t += 1;
		if ( t > 1 ) t -= 1;
		if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
		if ( t < 1 / 2 ) return q;
		if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
		return p;

	}

	function toComponents( source, target ) {

		target.r = source.r;
		target.g = source.g;
		target.b = source.b;

		return target;

	}

	class Color {

		constructor( r, g, b ) {

			if ( g === undefined && b === undefined ) {

				// r is THREE.Color, hex or string
				return this.set( r );

			}

			return this.setRGB( r, g, b );

		}

		set( value ) {

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		}

		setScalar( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		}

		setHex( hex, colorSpace = SRGBColorSpace ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			ColorManagement.toWorkingColorSpace( this, colorSpace );

			return this;

		}

		setRGB( r, g, b, colorSpace = LinearSRGBColorSpace ) {

			this.r = r;
			this.g = g;
			this.b = b;

			ColorManagement.toWorkingColorSpace( this, colorSpace );

			return this;

		}

		setHSL( h, s, l, colorSpace = LinearSRGBColorSpace ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = euclideanModulo( h, 1 );
			s = clamp( s, 0, 1 );
			l = clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				const q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			ColorManagement.toWorkingColorSpace( this, colorSpace );

			return this;

		}

		setStyle( style, colorSpace = SRGBColorSpace ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			let m;

			if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				let color;
				const name = m[ 1 ];
				const components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							ColorManagement.toWorkingColorSpace( this, colorSpace );

							handleAlpha( color[ 4 ] );

							return this;

						}

						if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							ColorManagement.toWorkingColorSpace( this, colorSpace );

							handleAlpha( color[ 4 ] );

							return this;

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							const h = parseFloat( color[ 1 ] ) / 360;
							const s = parseInt( color[ 2 ], 10 ) / 100;
							const l = parseInt( color[ 3 ], 10 ) / 100;

							handleAlpha( color[ 4 ] );

							return this.setHSL( h, s, l, colorSpace );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

				// hex color

				const hex = m[ 1 ];
				const size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					ColorManagement.toWorkingColorSpace( this, colorSpace );

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					ColorManagement.toWorkingColorSpace( this, colorSpace );

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				return this.setColorName( style, colorSpace );

			}

			return this;

		}

		setColorName( style, colorSpace = SRGBColorSpace ) {

			// color keywords
			const hex = _colorKeywords[ style.toLowerCase() ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex, colorSpace );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

			return this;

		}

		clone() {

			return new this.constructor( this.r, this.g, this.b );

		}

		copy( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		}

		copySRGBToLinear( color ) {

			this.r = SRGBToLinear( color.r );
			this.g = SRGBToLinear( color.g );
			this.b = SRGBToLinear( color.b );

			return this;

		}

		copyLinearToSRGB( color ) {

			this.r = LinearToSRGB( color.r );
			this.g = LinearToSRGB( color.g );
			this.b = LinearToSRGB( color.b );

			return this;

		}

		convertSRGBToLinear() {

			this.copySRGBToLinear( this );

			return this;

		}

		convertLinearToSRGB() {

			this.copyLinearToSRGB( this );

			return this;

		}

		getHex( colorSpace = SRGBColorSpace ) {

			ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

			return clamp( _rgb.r * 255, 0, 255 ) << 16 ^ clamp( _rgb.g * 255, 0, 255 ) << 8 ^ clamp( _rgb.b * 255, 0, 255 ) << 0;

		}

		getHexString( colorSpace = SRGBColorSpace ) {

			return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

		}

		getHSL( target, colorSpace = LinearSRGBColorSpace ) {

			// h,s,l ranges are in 0.0 - 1.0

			ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

			const r = _rgb.r, g = _rgb.g, b = _rgb.b;

			const max = Math.max( r, g, b );
			const min = Math.min( r, g, b );

			let hue, saturation;
			const lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				const delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;

			return target;

		}

		getRGB( target, colorSpace = LinearSRGBColorSpace ) {

			ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

			target.r = _rgb.r;
			target.g = _rgb.g;
			target.b = _rgb.b;

			return target;

		}

		getStyle( colorSpace = SRGBColorSpace ) {

			ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

			if ( colorSpace !== SRGBColorSpace ) {

				// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
				return `color(${ colorSpace } ${ _rgb.r } ${ _rgb.g } ${ _rgb.b })`;

			}

			return `rgb(${( _rgb.r * 255 ) | 0},${( _rgb.g * 255 ) | 0},${( _rgb.b * 255 ) | 0})`;

		}

		offsetHSL( h, s, l ) {

			this.getHSL( _hslA );

			_hslA.h += h; _hslA.s += s; _hslA.l += l;

			this.setHSL( _hslA.h, _hslA.s, _hslA.l );

			return this;

		}

		add( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		}

		addColors( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		}

		addScalar( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		}

		sub( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		}

		multiply( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		}

		multiplyScalar( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		}

		lerp( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		}

		lerpColors( color1, color2, alpha ) {

			this.r = color1.r + ( color2.r - color1.r ) * alpha;
			this.g = color1.g + ( color2.g - color1.g ) * alpha;
			this.b = color1.b + ( color2.b - color1.b ) * alpha;

			return this;

		}

		lerpHSL( color, alpha ) {

			this.getHSL( _hslA );
			color.getHSL( _hslB );

			const h = lerp( _hslA.h, _hslB.h, alpha );
			const s = lerp( _hslA.s, _hslB.s, alpha );
			const l = lerp( _hslA.l, _hslB.l, alpha );

			this.setHSL( h, s, l );

			return this;

		}

		equals( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		}

		fromArray( array, offset = 0 ) {

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.r = attribute.getX( index );
			this.g = attribute.getY( index );
			this.b = attribute.getZ( index );

			if ( attribute.normalized === true ) {

				// assuming Uint8Array

				this.r /= 255;
				this.g /= 255;
				this.b /= 255;

			}

			return this;

		}

		toJSON() {

			return this.getHex();

		}

	}

	Color.NAMES = _colorKeywords;

	Color.prototype.isColor = true;
	Color.prototype.r = 1;
	Color.prototype.g = 1;
	Color.prototype.b = 1;

	let _canvas;

	class ImageUtils {

		static getDataURL( image ) {

			if ( /^data:/i.test( image.src ) ) {

				return image.src;

			}

			if ( typeof HTMLCanvasElement == 'undefined' ) {

				return image.src;

			}

			let canvas;

			if ( image instanceof HTMLCanvasElement ) {

				canvas = image;

			} else {

				if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

				_canvas.width = image.width;
				_canvas.height = image.height;

				const context = _canvas.getContext( '2d' );

				if ( image instanceof ImageData ) {

					context.putImageData( image, 0, 0 );

				} else {

					context.drawImage( image, 0, 0, image.width, image.height );

				}

				canvas = _canvas;

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

		static sRGBToLinear( image ) {

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				const canvas = createElementNS( 'canvas' );

				canvas.width = image.width;
				canvas.height = image.height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height );

				const imageData = context.getImageData( 0, 0, image.width, image.height );
				const data = imageData.data;

				for ( let i = 0; i < data.length; i ++ ) {

					data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

				}

				context.putImageData( imageData, 0, 0 );

				return canvas;

			} else if ( image.data ) {

				const data = image.data.slice( 0 );

				for ( let i = 0; i < data.length; i ++ ) {

					if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

						data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

					} else {

						// assuming float

						data[ i ] = SRGBToLinear( data[ i ] );

					}

				}

				return {
					data: data,
					width: image.width,
					height: image.height
				};

			} else {

				console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
				return image;

			}

		}

	}

	class Source {

		constructor( data = null ) {

			this.uuid = generateUUID();

			this.data = data;

			this.version = 0;

		}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

				return meta.images[ this.uuid ];

			}

			const output = {
				uuid: this.uuid,
				url: ''
			};

			const data = this.data;

			if ( data !== null ) {

				let url;

				if ( Array.isArray( data ) ) {

					// cube texture

					url = [];

					for ( let i = 0, l = data.length; i < l; i ++ ) {

						if ( data[ i ].isDataTexture ) {

							url.push( serializeImage( data[ i ].image ) );

						} else {

							url.push( serializeImage( data[ i ] ) );

						}

					}

				} else {

					// texture

					url = serializeImage( data );

				}

				output.url = url;

			}

			if ( ! isRootObject ) {

				meta.images[ this.uuid ] = output;

			}

			return output;

		}

	}

	function serializeImage( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			// default images

			return ImageUtils.getDataURL( image );

		} else {

			if ( image.data ) {

				// images of DataTexture

				return {
					data: Array.prototype.slice.call( image.data ),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};

			} else {

				console.warn( 'THREE.Texture: Unable to serialize Texture.' );
				return {};

			}

		}

	}

	Source.prototype.isSource = true;

	let textureId = 0;

	class Texture extends EventDispatcher$1 {

		constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {

			super();

			Object.defineProperty( this, 'id', { value: textureId ++ } );

			this.uuid = generateUUID();

			this.name = '';

			this.source = new Source( image );
			this.mipmaps = [];

			this.mapping = mapping;

			this.wrapS = wrapS;
			this.wrapT = wrapT;

			this.magFilter = magFilter;
			this.minFilter = minFilter;

			this.anisotropy = anisotropy;

			this.format = format;
			this.internalFormat = null;
			this.type = type;

			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );
			this.center = new Vector2( 0, 0 );
			this.rotation = 0;

			this.matrixAutoUpdate = true;
			this.matrix = new Matrix3();

			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding;

			this.userData = {};

			this.version = 0;
			this.onUpdate = null;

			this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
			this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

		}

		get image() {

			return this.source.data;

		}

		set image( value ) {

			this.source.data = value;

		}

		updateMatrix() {

			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.name = source.name;

			this.source = source.source;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			this.needsUpdate = true;

			return this;

		}

		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			const output = {

				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				image: this.source.toJSON( meta ).uuid,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				format: this.format,
				type: this.type,
				encoding: this.encoding,

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY,

				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment

			};

			if ( JSON.stringify( this.userData ) !== '{}' ) output.userData = this.userData;

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

		transformUv( uv ) {

			if ( this.mapping !== UVMapping ) return uv;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}

						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}

						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

			return uv;

		}

		set needsUpdate( value ) {

			if ( value === true ) {

				this.version ++;
				this.source.needsUpdate = true;

			}

		}

	}

	Texture.DEFAULT_IMAGE = null;
	Texture.DEFAULT_MAPPING = UVMapping;

	Texture.prototype.isTexture = true;

	class Vector4 {

		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

		}

		get width() {

			return this.z;

		}

		set width( value ) {

			this.z = value;

		}

		get height() {

			return this.w;

		}

		set height( value ) {

			this.w = value;

		}

		set( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setZ( z ) {

			this.z = z;

			return this;

		}

		setW( w ) {

			this.w = w;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y, this.z, this.w );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		}

		add( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		}

		sub( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			this.w *= v.w;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		}

		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z, w = this.w;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		setAxisAngleFromQuaternion( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			const s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		}

		setAxisAngleFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			let angle, x, y, z; // variables for result
			const epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				const xx = ( m11 + 1 ) / 2;
				const yy = ( m22 + 1 ) / 2;
				const zz = ( m33 + 1 ) / 2;
				const xy = ( m12 + m21 ) / 4;
				const xz = ( m13 + m31 ) / 4;
				const yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				( m13 - m31 ) * ( m13 - m31 ) +
				( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
			this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		}

		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;
			this.w = v1.w + ( v2.w - v1.w ) * alpha;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		}

		fromBufferAttribute( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			this.w = Math.random();

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;
			yield this.z;
			yield this.w;

		}

	}

	Vector4.prototype.isVector4 = true;

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	class WebGLRenderTarget extends EventDispatcher$1 {

		constructor( width, height, options = {} ) {

			super();

			this.width = width;
			this.height = height;
			this.depth = 1;

			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;

			this.viewport = new Vector4( 0, 0, width, height );

			const image = { width: width, height: height, depth: 1 };

			this.texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
			this.texture.isRenderTargetTexture = true;

			this.texture.flipY = false;
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;

			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

			this.samples = options.samples !== undefined ? options.samples : 0;

		}

		setSize( width, height, depth = 1 ) {

			if ( this.width !== width || this.height !== height || this.depth !== depth ) {

				this.width = width;
				this.height = height;
				this.depth = depth;

				this.texture.image.width = width;
				this.texture.image.height = height;
				this.texture.image.depth = depth;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();
			this.texture.isRenderTargetTexture = true;

			// ensure image object is not shared, see #20328

			this.texture.image = Object.assign( {}, source.texture.image );

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;

			if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

			this.samples = source.samples;

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

	}

	WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

	class DataArrayTexture extends Texture {

		constructor( data = null, width = 1, height = 1, depth = 1 ) {

			super( null );

			this.image = { data, width, height, depth };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

	}

	DataArrayTexture.prototype.isDataArrayTexture = true;

	class WebGLArrayRenderTarget extends WebGLRenderTarget {

		constructor( width, height, depth ) {

			super( width, height );

			this.depth = depth;

			this.texture = new DataArrayTexture( null, width, height, depth );

			this.texture.isRenderTargetTexture = true;

		}

	}

	WebGLArrayRenderTarget.prototype.isWebGLArrayRenderTarget = true;

	class Data3DTexture extends Texture {

		constructor( data = null, width = 1, height = 1, depth = 1 ) {

			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	const texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839

			super( null );

			this.image = { data, width, height, depth };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

	}

	Data3DTexture.prototype.isData3DTexture = true;

	class WebGL3DRenderTarget extends WebGLRenderTarget {

		constructor( width, height, depth ) {

			super( width, height );

			this.depth = depth;

			this.texture = new Data3DTexture( null, width, height, depth );

			this.texture.isRenderTargetTexture = true;

		}

	}

	WebGL3DRenderTarget.prototype.isWebGL3DRenderTarget = true;

	class WebGLMultipleRenderTargets extends WebGLRenderTarget {

		constructor( width, height, count, options = {} ) {

			super( width, height, options );

			const texture = this.texture;

			this.texture = [];

			for ( let i = 0; i < count; i ++ ) {

				this.texture[ i ] = texture.clone();
				this.texture[ i ].isRenderTargetTexture = true;

			}

		}

		setSize( width, height, depth = 1 ) {

			if ( this.width !== width || this.height !== height || this.depth !== depth ) {

				this.width = width;
				this.height = height;
				this.depth = depth;

				for ( let i = 0, il = this.texture.length; i < il; i ++ ) {

					this.texture[ i ].image.width = width;
					this.texture[ i ].image.height = height;
					this.texture[ i ].image.depth = depth;

				}

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

			return this;

		}

		copy( source ) {

			this.dispose();

			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;

			this.viewport.set( 0, 0, this.width, this.height );
			this.scissor.set( 0, 0, this.width, this.height );

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;

			this.texture.length = 0;

			for ( let i = 0, il = source.texture.length; i < il; i ++ ) {

				this.texture[ i ] = source.texture[ i ].clone();

			}

			return this;

		}

	}

	WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;

	class Quaternion {

		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

		}

		static slerp( qa, qb, qm, t ) {

			console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
			return qm.slerpQuaternions( qa, qb, t );

		}

		static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			let x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ];

			const x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( t === 0 ) {

				dst[ dstOffset + 0 ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;
				return;

			}

			if ( t === 1 ) {

				dst[ dstOffset + 0 ] = x1;
				dst[ dstOffset + 1 ] = y1;
				dst[ dstOffset + 2 ] = z1;
				dst[ dstOffset + 3 ] = w1;
				return;

			}

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				let s = 1 - t;
				const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					const sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				const tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

		static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

			const x0 = src0[ srcOffset0 ];
			const y0 = src0[ srcOffset0 + 1 ];
			const z0 = src0[ srcOffset0 + 2 ];
			const w0 = src0[ srcOffset0 + 3 ];

			const x1 = src1[ srcOffset1 ];
			const y1 = src1[ srcOffset1 + 1 ];
			const z1 = src1[ srcOffset1 + 2 ];
			const w1 = src1[ srcOffset1 + 3 ];

			dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

			return dst;

		}

		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		get w() {

			return this._w;

		}

		set w( value ) {

			this._w = value;
			this._onChangeCallback();

		}

		set( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;

		}

		clone() {

			return new this.constructor( this._x, this._y, this._z, this._w );

		}

		copy( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;

		}

		setFromEuler( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			const cos = Math.cos;
			const sin = Math.sin;

			const c1 = cos( x / 2 );
			const c2 = cos( y / 2 );
			const c3 = cos( z / 2 );

			const s1 = sin( x / 2 );
			const s2 = sin( y / 2 );
			const s3 = sin( z / 2 );

			switch ( order ) {

				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				default:
					console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

			}

			if ( update !== false ) this._onChangeCallback();

			return this;

		}

		setFromAxisAngle( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			const halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this._onChangeCallback();

			return this;

		}

		setFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33;

			if ( trace > 0 ) {

				const s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this._onChangeCallback();

			return this;

		}

		setFromUnitVectors( vFrom, vTo ) {

			// assumes direction vectors vFrom and vTo are normalized

			let r = vFrom.dot( vTo ) + 1;

			if ( r < Number.EPSILON ) {

				// vFrom and vTo point in opposite directions

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					this._x = - vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;

				} else {

					this._x = 0;
					this._y = - vFrom.z;
					this._z = vFrom.y;
					this._w = r;

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;

			}

			return this.normalize();

		}

		angleTo( q ) {

			return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

		}

		rotateTowards( q, step ) {

			const angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			const t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		}

		identity() {

			return this.set( 0, 0, 0, 1 );

		}

		invert() {

			// quaternion is assumed to have unit length

			return this.conjugate();

		}

		conjugate() {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this._onChangeCallback();

			return this;

		}

		dot( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		}

		lengthSq() {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		}

		length() {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		}

		normalize() {

			let l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this._onChangeCallback();

			return this;

		}

		multiply( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		}

		premultiply( q ) {

			return this.multiplyQuaternions( q, this );

		}

		multiplyQuaternions( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;

		}

		slerp( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			const x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				const s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				this.normalize();
				this._onChangeCallback();

				return this;

			}

			const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this._onChangeCallback();

			return this;

		}

		slerpQuaternions( qa, qb, t ) {

			return this.copy( qa ).slerp( qb, t );

		}

		random() {

			// Derived from http://planning.cs.uiuc.edu/node198.html
			// Note, this source uses w, x, y, z ordering,
			// so we swap the order below.

			const u1 = Math.random();
			const sqrt1u1 = Math.sqrt( 1 - u1 );
			const sqrtu1 = Math.sqrt( u1 );

			const u2 = 2 * Math.PI * Math.random();

			const u3 = 2 * Math.PI * Math.random();

			return this.set(
				sqrt1u1 * Math.cos( u2 ),
				sqrtu1 * Math.sin( u3 ),
				sqrtu1 * Math.cos( u3 ),
				sqrt1u1 * Math.sin( u2 ),
			);

		}

		equals( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		}

		fromArray( array, offset = 0 ) {

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this._onChangeCallback();

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this._x = attribute.getX( index );
			this._y = attribute.getY( index );
			this._z = attribute.getZ( index );
			this._w = attribute.getW( index );

			return this;

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

	}

	Quaternion.prototype.isQuaternion = true;

	class Vector3 {

		constructor( x = 0, y = 0, z = 0 ) {

			this.x = x;
			this.y = y;
			this.z = z;

		}

		set( x, y, z ) {

			if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setZ( z ) {

			this.z = z;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y, this.z );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		}

		add( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		}

		sub( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		}

		multiply( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		}

		multiplyVectors( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		}

		applyEuler( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

		}

		applyAxisAngle( axis, angle ) {

			return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

		}

		applyMatrix3( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		}

		applyNormalMatrix( m ) {

			return this.applyMatrix3( m ).normalize();

		}

		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		}

		applyQuaternion( q ) {

			const x = this.x, y = this.y, z = this.z;
			const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			const ix = qw * x + qy * z - qz * y;
			const iy = qw * y + qz * x - qx * z;
			const iz = qw * z + qx * y - qy * x;
			const iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		}

		project( camera ) {

			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

		}

		unproject( camera ) {

			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

		}

		transformDirection( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		}

		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		}

		// TODO lengthSquared?

		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;

			return this;

		}

		cross( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			return this.crossVectors( this, v );

		}

		crossVectors( a, b ) {

			const ax = a.x, ay = a.y, az = a.z;
			const bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		}

		projectOnVector( v ) {

			const denominator = v.lengthSq();

			if ( denominator === 0 ) return this.set( 0, 0, 0 );

			const scalar = v.dot( this ) / denominator;

			return this.copy( v ).multiplyScalar( scalar );

		}

		projectOnPlane( planeNormal ) {

			_vector$c.copy( this ).projectOnVector( planeNormal );

			return this.sub( _vector$c );

		}

		reflect( normal ) {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

		angleTo( v ) {

			const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			const theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( clamp( theta, - 1, 1 ) );

		}

		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		}

		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		}

		setFromSpherical( s ) {

			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

		}

		setFromSphericalCoords( radius, phi, theta ) {

			const sinPhiRadius = Math.sin( phi ) * radius;

			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );

			return this;

		}

		setFromCylindrical( c ) {

			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

		}

		setFromCylindricalCoords( radius, theta, y ) {

			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );

			return this;

		}

		setFromMatrixPosition( m ) {

			const e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		}

		setFromMatrixScale( m ) {

			const sx = this.setFromMatrixColumn( m, 0 ).length();
			const sy = this.setFromMatrixColumn( m, 1 ).length();
			const sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		}

		setFromMatrixColumn( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		}

		setFromMatrix3Column( m, index ) {

			return this.fromArray( m.elements, index * 3 );

		}

		setFromEuler( e ) {

			this.x = e._x;
			this.y = e._y;
			this.z = e._z;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		}

		fromBufferAttribute( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();

			return this;

		}

		randomDirection() {

			// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

			const u = ( Math.random() - 0.5 ) * 2;
			const t = Math.random() * Math.PI * 2;
			const f = Math.sqrt( 1 - u ** 2 );

			this.x = f * Math.cos( t );
			this.y = f * Math.sin( t );
			this.z = u;

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;
			yield this.z;

		}

	}

	Vector3.prototype.isVector3 = true;

	const _vector$c = /*@__PURE__*/ new Vector3();
	const _quaternion$4 = /*@__PURE__*/ new Quaternion();

	class Box3 {

		constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

			this.min = min;
			this.max = max;

		}

		set( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		}

		setFromArray( array ) {

			let minX = + Infinity;
			let minY = + Infinity;
			let minZ = + Infinity;

			let maxX = - Infinity;
			let maxY = - Infinity;
			let maxZ = - Infinity;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const x = array[ i ];
				const y = array[ i + 1 ];
				const z = array[ i + 2 ];

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		}

		setFromBufferAttribute( attribute ) {

			let minX = + Infinity;
			let minY = + Infinity;
			let minZ = + Infinity;

			let maxX = - Infinity;
			let maxY = - Infinity;
			let maxZ = - Infinity;

			for ( let i = 0, l = attribute.count; i < l; i ++ ) {

				const x = attribute.getX( i );
				const y = attribute.getY( i );
				const z = attribute.getZ( i );

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		}

		setFromPoints( points ) {

			this.makeEmpty();

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		}

		setFromCenterAndSize( center, size ) {

			const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		}

		setFromObject( object, precise = false ) {

			this.makeEmpty();

			return this.expandByObject( object, precise );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		}

		makeEmpty() {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		}

		isEmpty() {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		}

		getCenter( target ) {

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		}

		getSize( target ) {

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

		}

		expandByPoint( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		}

		expandByVector( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		}

		expandByScalar( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		}

		expandByObject( object, precise = false ) {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			object.updateWorldMatrix( false, false );

			const geometry = object.geometry;

			if ( geometry !== undefined ) {

				if ( precise && geometry.attributes != undefined && geometry.attributes.position !== undefined ) {

					const position = geometry.attributes.position;
					for ( let i = 0, l = position.count; i < l; i ++ ) {

						_vector$b.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );
						this.expandByPoint( _vector$b );

					}

				} else {

					if ( geometry.boundingBox === null ) {

						geometry.computeBoundingBox();

					}

					_box$3.copy( geometry.boundingBox );
					_box$3.applyMatrix4( object.matrixWorld );

					this.union( _box$3 );

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				this.expandByObject( children[ i ], precise );

			}

			return this;

		}

		containsPoint( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;

		}

		containsBox( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		}

		getParameter( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		}

		intersectsBox( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

		}

		intersectsSphere( sphere ) {

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, _vector$b );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		intersectsPlane( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			let min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= - plane.constant && max >= - plane.constant );

		}

		intersectsTriangle( triangle ) {

			if ( this.isEmpty() ) {

				return false;

			}

			// compute box center and extents
			this.getCenter( _center );
			_extents.subVectors( this.max, _center );

			// translate triangle to aabb origin
			_v0$2.subVectors( triangle.a, _center );
			_v1$7.subVectors( triangle.b, _center );
			_v2$3.subVectors( triangle.c, _center );

			// compute edge vectors for triangle
			_f0.subVectors( _v1$7, _v0$2 );
			_f1.subVectors( _v2$3, _v1$7 );
			_f2.subVectors( _v0$2, _v2$3 );

			// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
			let axes = [
				0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
				_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
				- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
			];
			if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

				return false;

			}

			// test 3 face normals from the aabb
			axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
			if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

				return false;

			}

			// finally testing the face normal of the triangle
			// use already existing triangle edge vectors here
			_triangleNormal.crossVectors( _f0, _f1 );
			axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

			return satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents );

		}

		clampPoint( point, target ) {

			return target.copy( point ).clamp( this.min, this.max );

		}

		distanceToPoint( point ) {

			const clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );

			return clampedPoint.sub( point ).length();

		}

		getBoundingSphere( target ) {

			this.getCenter( target.center );

			target.radius = this.getSize( _vector$b ).length() * 0.5;

			return target;

		}

		intersect( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		}

		union( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		}

		applyMatrix4( matrix ) {

			// transform of empty box is an empty box.
			if ( this.isEmpty() ) return this;

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

			this.setFromPoints( _points );

			return this;

		}

		translate( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		}

		equals( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	}

	Box3.prototype.isBox3 = true;

	const _points = [
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3()
	];

	const _vector$b = /*@__PURE__*/ new Vector3();

	const _box$3 = /*@__PURE__*/ new Box3();

	// triangle centered vertices

	const _v0$2 = /*@__PURE__*/ new Vector3();
	const _v1$7 = /*@__PURE__*/ new Vector3();
	const _v2$3 = /*@__PURE__*/ new Vector3();

	// triangle edge vectors

	const _f0 = /*@__PURE__*/ new Vector3();
	const _f1 = /*@__PURE__*/ new Vector3();
	const _f2 = /*@__PURE__*/ new Vector3();

	const _center = /*@__PURE__*/ new Vector3();
	const _extents = /*@__PURE__*/ new Vector3();
	const _triangleNormal = /*@__PURE__*/ new Vector3();
	const _testAxis = /*@__PURE__*/ new Vector3();

	function satForAxes( axes, v0, v1, v2, extents ) {

		for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

			_testAxis.fromArray( axes, i );
			// project the aabb onto the separating axis
			const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
			// project all 3 vertices of the triangle onto the separating axis
			const p0 = v0.dot( _testAxis );
			const p1 = v1.dot( _testAxis );
			const p2 = v2.dot( _testAxis );
			// actual test, basically see if either of the most extreme of the triangle points intersects r
			if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is separating and we can exit
				return false;

			}

		}

		return true;

	}

	const _box$2 = /*@__PURE__*/ new Box3();
	const _v1$6 = /*@__PURE__*/ new Vector3();
	const _toFarthestPoint = /*@__PURE__*/ new Vector3();
	const _toPoint = /*@__PURE__*/ new Vector3();

	class Sphere {

		constructor( center = new Vector3(), radius = - 1 ) {

			this.center = center;
			this.radius = radius;

		}

		set( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		}

		setFromPoints( points, optionalCenter ) {

			const center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				_box$2.setFromPoints( points ).getCenter( center );

			}

			let maxRadiusSq = 0;

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		}

		copy( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		}

		isEmpty() {

			return ( this.radius < 0 );

		}

		makeEmpty() {

			this.center.set( 0, 0, 0 );
			this.radius = - 1;

			return this;

		}

		containsPoint( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		}

		distanceToPoint( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		}

		intersectsSphere( sphere ) {

			const radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		}

		intersectsBox( box ) {

			return box.intersectsSphere( this );

		}

		intersectsPlane( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		}

		clampPoint( point, target ) {

			const deltaLengthSq = this.center.distanceToSquared( point );

			target.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );

			}

			return target;

		}

		getBoundingBox( target ) {

			if ( this.isEmpty() ) {

				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;

			}

			target.set( this.center, this.center );
			target.expandByScalar( this.radius );

			return target;

		}

		applyMatrix4( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		}

		translate( offset ) {

			this.center.add( offset );

			return this;

		}

		expandByPoint( point ) {

			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

			_toPoint.subVectors( point, this.center );

			const lengthSq = _toPoint.lengthSq();

			if ( lengthSq > ( this.radius * this.radius ) ) {

				const length = Math.sqrt( lengthSq );
				const missingRadiusHalf = ( length - this.radius ) * 0.5;

				// Nudge this sphere towards the target point. Add half the missing distance to radius,
				// and the other half to position. This gives a tighter enclosure, instead of if
				// the whole missing distance were just added to radius.

				this.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );
				this.radius += missingRadiusHalf;

			}

			return this;

		}

		union( sphere ) {

			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

			// To enclose another sphere into this sphere, we only need to enclose two points:
			// 1) Enclose the farthest point on the other sphere into this sphere.
			// 2) Enclose the opposite point of the farthest point into this sphere.

			 if ( this.center.equals( sphere.center ) === true ) {

				 _toFarthestPoint.set( 0, 0, 1 ).multiplyScalar( sphere.radius );


			} else {

				_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );

			}

			this.expandByPoint( _v1$6.copy( sphere.center ).add( _toFarthestPoint ) );
			this.expandByPoint( _v1$6.copy( sphere.center ).sub( _toFarthestPoint ) );

			return this;

		}

		equals( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _vector$a = /*@__PURE__*/ new Vector3();
	const _segCenter = /*@__PURE__*/ new Vector3();
	const _segDir = /*@__PURE__*/ new Vector3();
	const _diff = /*@__PURE__*/ new Vector3();

	const _edge1 = /*@__PURE__*/ new Vector3();
	const _edge2 = /*@__PURE__*/ new Vector3();
	const _normal$1 = /*@__PURE__*/ new Vector3();

	class Ray {

		constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

			this.origin = origin;
			this.direction = direction;

		}

		set( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		}

		copy( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		}

		at( t, target ) {

			return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		}

		lookAt( v ) {

			this.direction.copy( v ).sub( this.origin ).normalize();

			return this;

		}

		recast( t ) {

			this.origin.copy( this.at( t, _vector$a ) );

			return this;

		}

		closestPointToPoint( point, target ) {

			target.subVectors( point, this.origin );

			const directionDistance = target.dot( this.direction );

			if ( directionDistance < 0 ) {

				return target.copy( this.origin );

			}

			return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		}

		distanceToPoint( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		}

		distanceSqToPoint( point ) {

			const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			_vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return _vector$a.distanceToSquared( point );

		}

		distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			_segDir.copy( v1 ).sub( v0 ).normalize();
			_diff.copy( this.origin ).sub( _segCenter );

			const segExtent = v0.distanceTo( v1 ) * 0.5;
			const a01 = - this.direction.dot( _segDir );
			const b0 = _diff.dot( this.direction );
			const b1 = - _diff.dot( _segDir );
			const c = _diff.lengthSq();
			const det = Math.abs( 1 - a01 * a01 );
			let s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							const invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

			}

			return sqrDist;

		}

		intersectSphere( sphere, target ) {

			_vector$a.subVectors( sphere.center, this.origin );
			const tca = _vector$a.dot( this.direction );
			const d2 = _vector$a.dot( _vector$a ) - tca * tca;
			const radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			const thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			const t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			const t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, target );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, target );

		}

		intersectsSphere( sphere ) {

			return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		distanceToPlane( plane ) {

			const denominator = plane.normal.dot( this.direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		}

		intersectPlane( plane, target ) {

			const t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, target );

		}

		intersectsPlane( plane ) {

			// check if the ray lies on the plane first

			const distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			const denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		}

		intersectBox( box, target ) {

			let tmin, tmax, tymin, tymax, tzmin, tzmax;

			const invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			const origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, target );

		}

		intersectsBox( box ) {

			return this.intersectBox( box, _vector$a ) !== null;

		}

		intersectTriangle( a, b, c, backfaceCulling, target ) {

			// Compute the offset origin, edges, and normal.

			// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

			_edge1.subVectors( b, a );
			_edge2.subVectors( c, a );
			_normal$1.crossVectors( _edge1, _edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			let DdN = this.direction.dot( _normal$1 );
			let sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			_diff.subVectors( this.origin, a );
			const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			const QdN = - sign * _diff.dot( _normal$1 );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, target );

		}

		applyMatrix4( matrix4 ) {

			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );

			return this;

		}

		equals( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	class Matrix4 {

		constructor() {

			this.elements = [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		}

		identity() {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		clone() {

			return new Matrix4().fromArray( this.elements );

		}

		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		}

		copyPosition( m ) {

			const te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		}

		setFromMatrix3( m ) {

			const me = m.elements;

			this.set(

				me[ 0 ], me[ 3 ], me[ 6 ], 0,
				me[ 1 ], me[ 4 ], me[ 7 ], 0,
				me[ 2 ], me[ 5 ], me[ 8 ], 0,
				0, 0, 0, 1

			);

			return this;

		}

		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		}

		makeBasis( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		}

		extractRotation( m ) {

			// this method does not support reflection matrices

			const te = this.elements;
			const me = m.elements;

			const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
			const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
			const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;
			te[ 3 ] = 0;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;
			te[ 7 ] = 0;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;
			te[ 11 ] = 0;

			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		makeRotationFromEuler( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			const te = this.elements;

			const x = euler.x, y = euler.y, z = euler.z;
			const a = Math.cos( x ), b = Math.sin( x );
			const c = Math.cos( y ), d = Math.sin( y );
			const e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		makeRotationFromQuaternion( q ) {

			return this.compose( _zero, q, _one );

		}

		lookAt( eye, target, up ) {

			const te = this.elements;

			_z.subVectors( eye, target );

			if ( _z.lengthSq() === 0 ) {

				// eye and target are in the same position

				_z.z = 1;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

			if ( _x.lengthSq() === 0 ) {

				// up and z are parallel

				if ( Math.abs( up.z ) === 1 ) {

					_z.x += 0.0001;

				} else {

					_z.z += 0.0001;

				}

				_z.normalize();
				_x.crossVectors( up, _z );

			}

			_x.normalize();
			_y.crossVectors( _z, _x );

			te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
			te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
			te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

			return this;

		}

		multiply( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		}

		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		}

		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		}

		determinant() {

			const te = this.elements;

			const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		}

		transpose() {

			const te = this.elements;
			let tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		}

		setPosition( x, y, z ) {

			const te = this.elements;

			if ( x.isVector3 ) {

				te[ 12 ] = x.x;
				te[ 13 ] = x.y;
				te[ 14 ] = x.z;

			} else {

				te[ 12 ] = x;
				te[ 13 ] = y;
				te[ 14 ] = z;

			}

			return this;

		}

		invert() {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
				n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
				n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
				n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		}

		scale( v ) {

			const te = this.elements;
			const x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		}

		getMaxScaleOnAxis() {

			const te = this.elements;

			const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		}

		makeTranslation( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationX( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationY( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		}

		makeRotationZ( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationAxis( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			const c = Math.cos( angle );
			const s = Math.sin( angle );
			const t = 1 - c;
			const x = axis.x, y = axis.y, z = axis.z;
			const tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeScale( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeShear( xy, xz, yx, yz, zx, zy ) {

			this.set(

				1, yx, zx, 0,
				xy, 1, zy, 0,
				xz, yz, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		compose( position, quaternion, scale ) {

			const te = this.elements;

			const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			const x2 = x + x,	y2 = y + y, z2 = z + z;
			const xx = x * x2, xy = x * y2, xz = x * z2;
			const yy = y * y2, yz = y * z2, zz = z * z2;
			const wx = w * x2, wy = w * y2, wz = w * z2;

			const sx = scale.x, sy = scale.y, sz = scale.z;

			te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
			te[ 1 ] = ( xy + wz ) * sx;
			te[ 2 ] = ( xz - wy ) * sx;
			te[ 3 ] = 0;

			te[ 4 ] = ( xy - wz ) * sy;
			te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
			te[ 6 ] = ( yz + wx ) * sy;
			te[ 7 ] = 0;

			te[ 8 ] = ( xz + wy ) * sz;
			te[ 9 ] = ( yz - wx ) * sz;
			te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
			te[ 11 ] = 0;

			te[ 12 ] = position.x;
			te[ 13 ] = position.y;
			te[ 14 ] = position.z;
			te[ 15 ] = 1;

			return this;

		}

		decompose( position, quaternion, scale ) {

			const te = this.elements;

			let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			const det = this.determinant();
			if ( det < 0 ) sx = - sx;

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part
			_m1$2.copy( this );

			const invSX = 1 / sx;
			const invSY = 1 / sy;
			const invSZ = 1 / sz;

			_m1$2.elements[ 0 ] *= invSX;
			_m1$2.elements[ 1 ] *= invSX;
			_m1$2.elements[ 2 ] *= invSX;

			_m1$2.elements[ 4 ] *= invSY;
			_m1$2.elements[ 5 ] *= invSY;
			_m1$2.elements[ 6 ] *= invSY;

			_m1$2.elements[ 8 ] *= invSZ;
			_m1$2.elements[ 9 ] *= invSZ;
			_m1$2.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( _m1$2 );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		}

		makePerspective( left, right, top, bottom, near, far ) {

			if ( far === undefined ) {

				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

			}

			const te = this.elements;
			const x = 2 * near / ( right - left );
			const y = 2 * near / ( top - bottom );

			const a = ( right + left ) / ( right - left );
			const b = ( top + bottom ) / ( top - bottom );
			const c = - ( far + near ) / ( far - near );
			const d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		}

		makeOrthographic( left, right, top, bottom, near, far ) {

			const te = this.elements;
			const w = 1.0 / ( right - left );
			const h = 1.0 / ( top - bottom );
			const p = 1.0 / ( far - near );

			const x = ( right + left ) * w;
			const y = ( top + bottom ) * h;
			const z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		}

		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	}

	Matrix4.prototype.isMatrix4 = true;

	const _v1$5 = /*@__PURE__*/ new Vector3();
	const _m1$2 = /*@__PURE__*/ new Matrix4();
	const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
	const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
	const _x = /*@__PURE__*/ new Vector3();
	const _y = /*@__PURE__*/ new Vector3();
	const _z = /*@__PURE__*/ new Vector3();

	const _matrix$1 = /*@__PURE__*/ new Matrix4();
	const _quaternion$3 = /*@__PURE__*/ new Quaternion();

	class Euler {

		constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

		}

		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		get order() {

			return this._order;

		}

		set order( value ) {

			this._order = value;
			this._onChangeCallback();

		}

		set( x, y, z, order = this._order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

			this._onChangeCallback();

			return this;

		}

		clone() {

			return new this.constructor( this._x, this._y, this._z, this._order );

		}

		copy( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;

		}

		setFromRotationMatrix( m, order = this._order, update = true ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements;
			const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			switch ( order ) {

				case 'XYZ':

					this._y = Math.asin( clamp( m13, - 1, 1 ) );

					if ( Math.abs( m13 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );

					} else {

						this._x = Math.atan2( m32, m22 );
						this._z = 0;

					}

					break;

				case 'YXZ':

					this._x = Math.asin( - clamp( m23, - 1, 1 ) );

					if ( Math.abs( m23 ) < 0.9999999 ) {

						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );

					} else {

						this._y = Math.atan2( - m31, m11 );
						this._z = 0;

					}

					break;

				case 'ZXY':

					this._x = Math.asin( clamp( m32, - 1, 1 ) );

					if ( Math.abs( m32 ) < 0.9999999 ) {

						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );

					} else {

						this._y = 0;
						this._z = Math.atan2( m21, m11 );

					}

					break;

				case 'ZYX':

					this._y = Math.asin( - clamp( m31, - 1, 1 ) );

					if ( Math.abs( m31 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );

					} else {

						this._x = 0;
						this._z = Math.atan2( - m12, m22 );

					}

					break;

				case 'YZX':

					this._z = Math.asin( clamp( m21, - 1, 1 ) );

					if ( Math.abs( m21 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );

					} else {

						this._x = 0;
						this._y = Math.atan2( m13, m33 );

					}

					break;

				case 'XZY':

					this._z = Math.asin( - clamp( m12, - 1, 1 ) );

					if ( Math.abs( m12 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );

					} else {

						this._x = Math.atan2( - m23, m33 );
						this._y = 0;

					}

					break;

				default:

					console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

			}

			this._order = order;

			if ( update === true ) this._onChangeCallback();

			return this;

		}

		setFromQuaternion( q, order, update ) {

			_matrix$1.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( _matrix$1, order, update );

		}

		setFromVector3( v, order = this._order ) {

			return this.set( v.x, v.y, v.z, order );

		}

		reorder( newOrder ) {

			// WARNING: this discards revolution information -bhouston

			_quaternion$3.setFromEuler( this );

			return this.setFromQuaternion( _quaternion$3, newOrder );

		}

		equals( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		}

		fromArray( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this._onChangeCallback();

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

	}

	Euler.prototype.isEuler = true;

	Euler.DefaultOrder = 'XYZ';
	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	class Layers {

		constructor() {

			this.mask = 1 | 0;

		}

		set( channel ) {

			this.mask = ( 1 << channel | 0 ) >>> 0;

		}

		enable( channel ) {

			this.mask |= 1 << channel | 0;

		}

		enableAll() {

			this.mask = 0xffffffff | 0;

		}

		toggle( channel ) {

			this.mask ^= 1 << channel | 0;

		}

		disable( channel ) {

			this.mask &= ~ ( 1 << channel | 0 );

		}

		disableAll() {

			this.mask = 0;

		}

		test( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

		isEnabled( channel ) {

			return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

		}

	}

	let _object3DId = 0;

	const _v1$4 = /*@__PURE__*/ new Vector3();
	const _q1 = /*@__PURE__*/ new Quaternion();
	const _m1$1 = /*@__PURE__*/ new Matrix4();
	const _target = /*@__PURE__*/ new Vector3();

	const _position$3 = /*@__PURE__*/ new Vector3();
	const _scale$2 = /*@__PURE__*/ new Vector3();
	const _quaternion$2 = /*@__PURE__*/ new Quaternion();

	const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
	const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
	const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

	const _addedEvent = { type: 'added' };
	const _removedEvent = { type: 'removed' };

	class Object3D extends EventDispatcher$1 {

		constructor() {

			super();

			Object.defineProperty( this, 'id', { value: _object3DId ++ } );

			this.uuid = generateUUID();

			this.name = '';
			this.type = 'Object3D';

			this.parent = null;
			this.children = [];

			this.up = Object3D.DefaultUp.clone();

			const position = new Vector3();
			const rotation = new Euler();
			const quaternion = new Quaternion();
			const scale = new Vector3( 1, 1, 1 );

			function onRotationChange() {

				quaternion.setFromEuler( rotation, false );

			}

			function onQuaternionChange() {

				rotation.setFromQuaternion( quaternion, undefined, false );

			}

			rotation._onChange( onRotationChange );
			quaternion._onChange( onQuaternionChange );

			Object.defineProperties( this, {
				position: {
					configurable: true,
					enumerable: true,
					value: position
				},
				rotation: {
					configurable: true,
					enumerable: true,
					value: rotation
				},
				quaternion: {
					configurable: true,
					enumerable: true,
					value: quaternion
				},
				scale: {
					configurable: true,
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			} );

			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();

			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;

			this.layers = new Layers();
			this.visible = true;

			this.castShadow = false;
			this.receiveShadow = false;

			this.frustumCulled = true;
			this.renderOrder = 0;

			this.animations = [];

			this.userData = {};

		}

		onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

		onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

		applyMatrix4( matrix ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			this.matrix.premultiply( matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		}

		applyQuaternion( q ) {

			this.quaternion.premultiply( q );

			return this;

		}

		setRotationFromAxisAngle( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		}

		setRotationFromEuler( euler ) {

			this.quaternion.setFromEuler( euler, true );

		}

		setRotationFromMatrix( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		}

		setRotationFromQuaternion( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		}

		rotateOnAxis( axis, angle ) {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( _q1 );

			return this;

		}

		rotateOnWorldAxis( axis, angle ) {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.premultiply( _q1 );

			return this;

		}

		rotateX( angle ) {

			return this.rotateOnAxis( _xAxis, angle );

		}

		rotateY( angle ) {

			return this.rotateOnAxis( _yAxis, angle );

		}

		rotateZ( angle ) {

			return this.rotateOnAxis( _zAxis, angle );

		}

		translateOnAxis( axis, distance ) {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			_v1$4.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( _v1$4.multiplyScalar( distance ) );

			return this;

		}

		translateX( distance ) {

			return this.translateOnAxis( _xAxis, distance );

		}

		translateY( distance ) {

			return this.translateOnAxis( _yAxis, distance );

		}

		translateZ( distance ) {

			return this.translateOnAxis( _zAxis, distance );

		}

		localToWorld( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		}

		worldToLocal( vector ) {

			return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

		}

		lookAt( x, y, z ) {

			// This method does not support objects having non-uniformly-scaled parent(s)

			if ( x.isVector3 ) {

				_target.copy( x );

			} else {

				_target.set( x, y, z );

			}

			const parent = this.parent;

			this.updateWorldMatrix( true, false );

			_position$3.setFromMatrixPosition( this.matrixWorld );

			if ( this.isCamera || this.isLight ) {

				_m1$1.lookAt( _position$3, _target, this.up );

			} else {

				_m1$1.lookAt( _target, _position$3, this.up );

			}

			this.quaternion.setFromRotationMatrix( _m1$1 );

			if ( parent ) {

				_m1$1.extractRotation( parent.matrixWorld );
				_q1.setFromRotationMatrix( _m1$1 );
				this.quaternion.premultiply( _q1.invert() );

			}

		}

		add( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
				return this;

			}

			if ( object && object.isObject3D ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				this.children.push( object );

				object.dispatchEvent( _addedEvent );

			} else {

				console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

			}

			return this;

		}

		remove( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			const index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;
				this.children.splice( index, 1 );

				object.dispatchEvent( _removedEvent );

			}

			return this;

		}

		removeFromParent() {

			const parent = this.parent;

			if ( parent !== null ) {

				parent.remove( this );

			}

			return this;

		}

		clear() {

			for ( let i = 0; i < this.children.length; i ++ ) {

				const object = this.children[ i ];

				object.parent = null;

				object.dispatchEvent( _removedEvent );

			}

			this.children.length = 0;

			return this;


		}

		attach( object ) {

			// adds object as a child of this, while maintaining the object's world transform

			// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

			this.updateWorldMatrix( true, false );

			_m1$1.copy( this.matrixWorld ).invert();

			if ( object.parent !== null ) {

				object.parent.updateWorldMatrix( true, false );

				_m1$1.multiply( object.parent.matrixWorld );

			}

			object.applyMatrix4( _m1$1 );

			this.add( object );

			object.updateWorldMatrix( false, true );

			return this;

		}

		getObjectById( id ) {

			return this.getObjectByProperty( 'id', id );

		}

		getObjectByName( name ) {

			return this.getObjectByProperty( 'name', name );

		}

		getObjectByProperty( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( let i = 0, l = this.children.length; i < l; i ++ ) {

				const child = this.children[ i ];
				const object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		}

		getWorldPosition( target ) {

			this.updateWorldMatrix( true, false );

			return target.setFromMatrixPosition( this.matrixWorld );

		}

		getWorldQuaternion( target ) {

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position$3, target, _scale$2 );

			return target;

		}

		getWorldScale( target ) {

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position$3, _quaternion$2, target );

			return target;

		}

		getWorldDirection( target ) {

			this.updateWorldMatrix( true, false );

			const e = this.matrixWorld.elements;

			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

		}

		raycast( /* raycaster, intersects */ ) {}

		traverse( callback ) {

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		}

		traverseVisible( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		}

		traverseAncestors( callback ) {

			const parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		}

		updateMatrix() {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		}

		updateMatrixWorld( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( force );

			}

		}

		updateWorldMatrix( updateParents, updateChildren ) {

			const parent = this.parent;

			if ( updateParents === true && parent !== null ) {

				parent.updateWorldMatrix( true, false );

			}

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			// update children

			if ( updateChildren === true ) {

				const children = this.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateWorldMatrix( false, true );

				}

			}

		}

		toJSON( meta ) {

			// meta is a string when called from JSON.stringify
			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			const output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {},
					nodes: {}
				};

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			const object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();

			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

			// object specific properties

			if ( this.isInstancedMesh ) {

				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();
				if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

			}

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.isScene ) {

				if ( this.background ) {

					if ( this.background.isColor ) {

						object.background = this.background.toJSON();

					} else if ( this.background.isTexture ) {

						object.background = this.background.toJSON( meta ).uuid;

					}

				}

				if ( this.environment && this.environment.isTexture ) {

					object.environment = this.environment.toJSON( meta ).uuid;

				}

			} else if ( this.isMesh || this.isLine || this.isPoints ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				const parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					const shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( let i = 0, l = shapes.length; i < l; i ++ ) {

							const shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.isSkinnedMesh ) {

				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if ( this.skeleton !== undefined ) {

					serialize( meta.skeletons, this.skeleton );

					object.skeleton = this.skeleton.uuid;

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					const uuids = [];

					for ( let i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( let i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			//

			if ( this.animations.length > 0 ) {

				object.animations = [];

				for ( let i = 0; i < this.animations.length; i ++ ) {

					const animation = this.animations[ i ];

					object.animations.push( serialize( meta.animations, animation ) );

				}

			}

			if ( isRootObject ) {

				const geometries = extractFromCache( meta.geometries );
				const materials = extractFromCache( meta.materials );
				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );
				const shapes = extractFromCache( meta.shapes );
				const skeletons = extractFromCache( meta.skeletons );
				const animations = extractFromCache( meta.animations );
				const nodes = extractFromCache( meta.nodes );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;
				if ( skeletons.length > 0 ) output.skeletons = skeletons;
				if ( animations.length > 0 ) output.animations = animations;
				if ( nodes.length > 0 ) output.nodes = nodes;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				const values = [];
				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

		}

		clone( recursive ) {

			return new this.constructor().copy( this, recursive );

		}

		copy( source, recursive = true ) {

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.rotation.order = source.rotation.order;
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( let i = 0; i < source.children.length; i ++ ) {

					const child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	}

	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;

	Object3D.prototype.isObject3D = true;

	const _v0$1 = /*@__PURE__*/ new Vector3();
	const _v1$3 = /*@__PURE__*/ new Vector3();
	const _v2$2 = /*@__PURE__*/ new Vector3();
	const _v3$1 = /*@__PURE__*/ new Vector3();

	const _vab = /*@__PURE__*/ new Vector3();
	const _vac = /*@__PURE__*/ new Vector3();
	const _vbc = /*@__PURE__*/ new Vector3();
	const _vap = /*@__PURE__*/ new Vector3();
	const _vbp = /*@__PURE__*/ new Vector3();
	const _vcp = /*@__PURE__*/ new Vector3();

	class Triangle {

		constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

			this.a = a;
			this.b = b;
			this.c = c;

		}

		static getNormal( a, b, c, target ) {

			target.subVectors( c, b );
			_v0$1.subVectors( a, b );
			target.cross( _v0$1 );

			const targetLengthSq = target.lengthSq();
			if ( targetLengthSq > 0 ) {

				return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

			}

			return target.set( 0, 0, 0 );

		}

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		static getBarycoord( point, a, b, c, target ) {

			_v0$1.subVectors( c, a );
			_v1$3.subVectors( b, a );
			_v2$2.subVectors( point, a );

			const dot00 = _v0$1.dot( _v0$1 );
			const dot01 = _v0$1.dot( _v1$3 );
			const dot02 = _v0$1.dot( _v2$2 );
			const dot11 = _v1$3.dot( _v1$3 );
			const dot12 = _v1$3.dot( _v2$2 );

			const denom = ( dot00 * dot11 - dot01 * dot01 );

			// collinear or singular triangle
			if ( denom === 0 ) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set( - 2, - 1, - 1 );

			}

			const invDenom = 1 / denom;
			const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycentric coordinates must always sum to 1
			return target.set( 1 - u - v, v, u );

		}

		static containsPoint( point, a, b, c ) {

			this.getBarycoord( point, a, b, c, _v3$1 );

			return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

		}

		static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

			this.getBarycoord( point, p1, p2, p3, _v3$1 );

			target.set( 0, 0 );
			target.addScaledVector( uv1, _v3$1.x );
			target.addScaledVector( uv2, _v3$1.y );
			target.addScaledVector( uv3, _v3$1.z );

			return target;

		}

		static isFrontFacing( a, b, c, direction ) {

			_v0$1.subVectors( c, b );
			_v1$3.subVectors( a, b );

			// strictly front facing
			return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

		}

		set( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		}

		setFromPointsAndIndices( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		}

		setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

			this.a.fromBufferAttribute( attribute, i0 );
			this.b.fromBufferAttribute( attribute, i1 );
			this.c.fromBufferAttribute( attribute, i2 );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		}

		getArea() {

			_v0$1.subVectors( this.c, this.b );
			_v1$3.subVectors( this.a, this.b );

			return _v0$1.cross( _v1$3 ).length() * 0.5;

		}

		getMidpoint( target ) {

			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		}

		getNormal( target ) {

			return Triangle.getNormal( this.a, this.b, this.c, target );

		}

		getPlane( target ) {

			return target.setFromCoplanarPoints( this.a, this.b, this.c );

		}

		getBarycoord( point, target ) {

			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

		}

		getUV( point, uv1, uv2, uv3, target ) {

			return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

		}

		containsPoint( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		}

		isFrontFacing( direction ) {

			return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

		}

		intersectsBox( box ) {

			return box.intersectsTriangle( this );

		}

		closestPointToPoint( p, target ) {

			const a = this.a, b = this.b, c = this.c;
			let v, w;

			// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors( b, a );
			_vac.subVectors( c, a );
			_vap.subVectors( p, a );
			const d1 = _vab.dot( _vap );
			const d2 = _vac.dot( _vap );
			if ( d1 <= 0 && d2 <= 0 ) {

				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy( a );

			}

			_vbp.subVectors( p, b );
			const d3 = _vab.dot( _vbp );
			const d4 = _vac.dot( _vbp );
			if ( d3 >= 0 && d4 <= d3 ) {

				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy( b );

			}

			const vc = d1 * d4 - d3 * d2;
			if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

				v = d1 / ( d1 - d3 );
				// edge region of AB; barycentric coords (1-v, v, 0)
				return target.copy( a ).addScaledVector( _vab, v );

			}

			_vcp.subVectors( p, c );
			const d5 = _vab.dot( _vcp );
			const d6 = _vac.dot( _vcp );
			if ( d6 >= 0 && d5 <= d6 ) {

				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy( c );

			}

			const vb = d5 * d2 - d1 * d6;
			if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

				w = d2 / ( d2 - d6 );
				// edge region of AC; barycentric coords (1-w, 0, w)
				return target.copy( a ).addScaledVector( _vac, w );

			}

			const va = d3 * d6 - d5 * d4;
			if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

				_vbc.subVectors( c, b );
				w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
				// edge region of BC; barycentric coords (0, 1-w, w)
				return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

			}

			// face region
			const denom = 1 / ( va + vb + vc );
			// u = va * denom
			v = vb * denom;
			w = vc * denom;

			return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

		}

		equals( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	}

	let materialId = 0;

	class Material extends EventDispatcher$1 {

		constructor() {

			super();

			Object.defineProperty( this, 'id', { value: materialId ++ } );

			this.uuid = generateUUID();

			this.name = '';
			this.type = 'Material';

			this.fog = true;

			this.blending = NormalBlending;
			this.side = FrontSide;
			this.vertexColors = false;

			this.opacity = 1;
			this.transparent = false;

			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;

			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;

			this.stencilWriteMask = 0xff;
			this.stencilFunc = AlwaysStencilFunc;
			this.stencilRef = 0;
			this.stencilFuncMask = 0xff;
			this.stencilFail = KeepStencilOp;
			this.stencilZFail = KeepStencilOp;
			this.stencilZPass = KeepStencilOp;
			this.stencilWrite = false;

			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;

			this.shadowSide = null;

			this.colorWrite = true;

			this.precision = null; // override the renderer's default precision for this material

			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;

			this.dithering = false;

			this.alphaToCoverage = false;
			this.premultipliedAlpha = false;

			this.visible = true;

			this.toneMapped = true;

			this.userData = {};

			this.version = 0;

			this._alphaTest = 0;

		}

		get alphaTest() {

			return this._alphaTest;

		}

		set alphaTest( value ) {

			if ( this._alphaTest > 0 !== value > 0 ) {

				this.version ++;

			}

			this._alphaTest = value;

		}

		onBuild( /* shaderobject, renderer */ ) {}

		onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

		onBeforeCompile( /* shaderobject, renderer */ ) {}

		customProgramCacheKey() {

			return this.onBeforeCompile.toString();

		}

		setValues( values ) {

			if ( values === undefined ) return;

			for ( const key in values ) {

				const newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
					continue;

				}

				// for backward compatibility if shading is set in the constructor
				if ( key === 'shading' ) {

					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;

				}

				const currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		}

		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( isRootObject ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			const data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.sheen !== undefined ) data.sheen = this.sheen;
			if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
			if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
			if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
			if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

			if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

				data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

			}

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

			if ( this.lightMap && this.lightMap.isTexture ) {

				data.lightMap = this.lightMap.toJSON( meta ).uuid;
				data.lightMapIntensity = this.lightMapIntensity;

			}

			if ( this.aoMap && this.aoMap.isTexture ) {

				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;

			}

			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}

			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();

			}

			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}

			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
			if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
			if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;

				if ( this.combine !== undefined ) data.combine = this.combine;

			}

			if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
			if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
			if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.transmission !== undefined ) data.transmission = this.transmission;
			if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
			if ( this.thickness !== undefined ) data.thickness = this.thickness;
			if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
			if ( this.attenuationDistance !== undefined ) data.attenuationDistance = this.attenuationDistance;
			if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors ) data.vertexColors = true;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
			data.colorWrite = this.colorWrite;

			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass;

			// rotation (SpriteMaterial)
			if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.polygonOffset === true ) data.polygonOffset = true;
			if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

			if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

			if ( this.flatShading === true ) data.flatShading = this.flatShading;

			if ( this.visible === false ) data.visible = false;

			if ( this.toneMapped === false ) data.toneMapped = false;

			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				const values = [];

				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRootObject ) {

				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.name = source.name;

			this.fog = source.fog;

			this.blending = source.blending;
			this.side = source.side;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;

			const srcPlanes = source.clippingPlanes;
			let dstPlanes = null;

			if ( srcPlanes !== null ) {

				const n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( let i = 0; i !== n; ++ i ) {

					dstPlanes[ i ] = srcPlanes[ i ].clone();

				}

			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;

			this.shadowSide = source.shadowSide;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.alphaToCoverage = source.alphaToCoverage;
			this.premultipliedAlpha = source.premultipliedAlpha;

			this.visible = source.visible;

			this.toneMapped = source.toneMapped;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

	}

	Material.prototype.isMaterial = true;

	Material.fromType = function ( /*type*/ ) {

		// TODO: Behavior added in Materials.js

		return null;

	};

	class MeshBasicMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'MeshBasicMaterial';

			this.color = new Color( 0xffffff ); // emissive

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			return this;

		}

	}

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	const _vector$9 = /*@__PURE__*/ new Vector3();
	const _vector2$1 = /*@__PURE__*/ new Vector2();

	class BufferAttribute {

		constructor( array, itemSize, normalized ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.name = '';

			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;

			this.usage = StaticDrawUsage;
			this.updateRange = { offset: 0, count: - 1 };

			this.version = 0;

		}

		onUploadCallback() {}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		setUsage( value ) {

			this.usage = value;

			return this;

		}

		copy( source ) {

			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.usage = source.usage;

			return this;

		}

		copyAt( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		}

		copyArray( array ) {

			this.array.set( array );

			return this;

		}

		copyColorsArray( colors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = colors.length; i < l; i ++ ) {

				let color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		}

		copyVector2sArray( vectors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = vectors.length; i < l; i ++ ) {

				let vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		}

		copyVector3sArray( vectors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = vectors.length; i < l; i ++ ) {

				let vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		}

		copyVector4sArray( vectors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = vectors.length; i < l; i ++ ) {

				let vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		}

		applyMatrix3( m ) {

			if ( this.itemSize === 2 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector2$1.fromBufferAttribute( this, i );
					_vector2$1.applyMatrix3( m );

					this.setXY( i, _vector2$1.x, _vector2$1.y );

				}

			} else if ( this.itemSize === 3 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector$9.fromBufferAttribute( this, i );
					_vector$9.applyMatrix3( m );

					this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

				}

			}

			return this;

		}

		applyMatrix4( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );

				_vector$9.applyMatrix4( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

			return this;

		}

		applyNormalMatrix( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );

				_vector$9.applyNormalMatrix( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

			return this;

		}

		transformDirection( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );

				_vector$9.transformDirection( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

			return this;

		}

		set( value, offset = 0 ) {

			this.array.set( value, offset );

			return this;

		}

		getX( index ) {

			return this.array[ index * this.itemSize ];

		}

		setX( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		}

		getY( index ) {

			return this.array[ index * this.itemSize + 1 ];

		}

		setY( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		}

		getZ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		}

		setZ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		}

		getW( index ) {

			return this.array[ index * this.itemSize + 3 ];

		}

		setW( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		}

		setXY( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		}

		setXYZ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		}

		setXYZW( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		}

		onUpload( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

		clone() {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		}

		toJSON() {

			const data = {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call( this.array ),
				normalized: this.normalized
			};

			if ( this.name !== '' ) data.name = this.name;
			if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
			if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

			return data;

		}

	}

	BufferAttribute.prototype.isBufferAttribute = true;

	class Uint16BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Uint16Array( array ), itemSize, normalized );

		}

	}

	class Uint32BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Uint32Array( array ), itemSize, normalized );

		}

	}

	class Float16BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Uint16Array( array ), itemSize, normalized );

		}

	}

	Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

	class Float32BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Float32Array( array ), itemSize, normalized );

		}

	}

	let _id$1 = 0;

	const _m1 = /*@__PURE__*/ new Matrix4();
	const _obj = /*@__PURE__*/ new Object3D();
	const _offset = /*@__PURE__*/ new Vector3();
	const _box$1 = /*@__PURE__*/ new Box3();
	const _boxMorphTargets = /*@__PURE__*/ new Box3();
	const _vector$8 = /*@__PURE__*/ new Vector3();

	class BufferGeometry extends EventDispatcher$1 {

		constructor() {

			super();

			Object.defineProperty( this, 'id', { value: _id$1 ++ } );

			this.uuid = generateUUID();

			this.name = '';
			this.type = 'BufferGeometry';

			this.index = null;
			this.attributes = {};

			this.morphAttributes = {};
			this.morphTargetsRelative = false;

			this.groups = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			this.drawRange = { start: 0, count: Infinity };

			this.userData = {};

		}

		getIndex() {

			return this.index;

		}

		setIndex( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

			return this;

		}

		getAttribute( name ) {

			return this.attributes[ name ];

		}

		setAttribute( name, attribute ) {

			this.attributes[ name ] = attribute;

			return this;

		}

		deleteAttribute( name ) {

			delete this.attributes[ name ];

			return this;

		}

		hasAttribute( name ) {

			return this.attributes[ name ] !== undefined;

		}

		addGroup( start, count, materialIndex = 0 ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex

			} );

		}

		clearGroups() {

			this.groups = [];

		}

		setDrawRange( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		}

		applyMatrix4( matrix ) {

			const position = this.attributes.position;

			if ( position !== undefined ) {

				position.applyMatrix4( matrix );

				position.needsUpdate = true;

			}

			const normal = this.attributes.normal;

			if ( normal !== undefined ) {

				const normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normal.applyNormalMatrix( normalMatrix );

				normal.needsUpdate = true;

			}

			const tangent = this.attributes.tangent;

			if ( tangent !== undefined ) {

				tangent.transformDirection( matrix );

				tangent.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		}

		applyQuaternion( q ) {

			_m1.makeRotationFromQuaternion( q );

			this.applyMatrix4( _m1 );

			return this;

		}

		rotateX( angle ) {

			// rotate geometry around world x-axis

			_m1.makeRotationX( angle );

			this.applyMatrix4( _m1 );

			return this;

		}

		rotateY( angle ) {

			// rotate geometry around world y-axis

			_m1.makeRotationY( angle );

			this.applyMatrix4( _m1 );

			return this;

		}

		rotateZ( angle ) {

			// rotate geometry around world z-axis

			_m1.makeRotationZ( angle );

			this.applyMatrix4( _m1 );

			return this;

		}

		translate( x, y, z ) {

			// translate geometry

			_m1.makeTranslation( x, y, z );

			this.applyMatrix4( _m1 );

			return this;

		}

		scale( x, y, z ) {

			// scale geometry

			_m1.makeScale( x, y, z );

			this.applyMatrix4( _m1 );

			return this;

		}

		lookAt( vector ) {

			_obj.lookAt( vector );

			_obj.updateMatrix();

			this.applyMatrix4( _obj.matrix );

			return this;

		}

		center() {

			this.computeBoundingBox();

			this.boundingBox.getCenter( _offset ).negate();

			this.translate( _offset.x, _offset.y, _offset.z );

			return this;

		}

		setFromPoints( points ) {

			const position = [];

			for ( let i = 0, l = points.length; i < l; i ++ ) {

				const point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		}

		computeBoundingBox() {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

				this.boundingBox.set(
					new Vector3( - Infinity, - Infinity, - Infinity ),
					new Vector3( + Infinity, + Infinity, + Infinity )
				);

				return;

			}

			if ( position !== undefined ) {

				this.boundingBox.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_box$1.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$8.addVectors( this.boundingBox.min, _box$1.min );
							this.boundingBox.expandByPoint( _vector$8 );

							_vector$8.addVectors( this.boundingBox.max, _box$1.max );
							this.boundingBox.expandByPoint( _vector$8 );

						} else {

							this.boundingBox.expandByPoint( _box$1.min );
							this.boundingBox.expandByPoint( _box$1.max );

						}

					}

				}

			} else {

				this.boundingBox.makeEmpty();

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		}

		computeBoundingSphere() {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

				this.boundingSphere.set( new Vector3(), Infinity );

				return;

			}

			if ( position ) {

				// first, find the center of the bounding sphere

				const center = this.boundingSphere.center;

				_box$1.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_boxMorphTargets.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$8.addVectors( _box$1.min, _boxMorphTargets.min );
							_box$1.expandByPoint( _vector$8 );

							_vector$8.addVectors( _box$1.max, _boxMorphTargets.max );
							_box$1.expandByPoint( _vector$8 );

						} else {

							_box$1.expandByPoint( _boxMorphTargets.min );
							_box$1.expandByPoint( _boxMorphTargets.max );

						}

					}

				}

				_box$1.getCenter( center );

				// second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				let maxRadiusSq = 0;

				for ( let i = 0, il = position.count; i < il; i ++ ) {

					_vector$8.fromBufferAttribute( position, i );

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

				}

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						const morphTargetsRelative = this.morphTargetsRelative;

						for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

							_vector$8.fromBufferAttribute( morphAttribute, j );

							if ( morphTargetsRelative ) {

								_offset.fromBufferAttribute( position, j );
								_vector$8.add( _offset );

							}

							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

						}

					}

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		}

		computeTangents() {

			const index = this.index;
			const attributes = this.attributes;

			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if ( index === null ||
				 attributes.position === undefined ||
				 attributes.normal === undefined ||
				 attributes.uv === undefined ) {

				console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
				return;

			}

			const indices = index.array;
			const positions = attributes.position.array;
			const normals = attributes.normal.array;
			const uvs = attributes.uv.array;

			const nVertices = positions.length / 3;

			if ( this.hasAttribute( 'tangent' ) === false ) {

				this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

			}

			const tangents = this.getAttribute( 'tangent' ).array;

			const tan1 = [], tan2 = [];

			for ( let i = 0; i < nVertices; i ++ ) {

				tan1[ i ] = new Vector3();
				tan2[ i ] = new Vector3();

			}

			const vA = new Vector3(),
				vB = new Vector3(),
				vC = new Vector3(),

				uvA = new Vector2(),
				uvB = new Vector2(),
				uvC = new Vector2(),

				sdir = new Vector3(),
				tdir = new Vector3();

			function handleTriangle( a, b, c ) {

				vA.fromArray( positions, a * 3 );
				vB.fromArray( positions, b * 3 );
				vC.fromArray( positions, c * 3 );

				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );

				vB.sub( vA );
				vC.sub( vA );

				uvB.sub( uvA );
				uvC.sub( uvA );

				const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

				// silently ignore degenerate uv triangles having coincident or colinear vertices

				if ( ! isFinite( r ) ) return;

				sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
				tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );

				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );

			}

			let groups = this.groups;

			if ( groups.length === 0 ) {

				groups = [ {
					start: 0,
					count: indices.length
				} ];

			}

			for ( let i = 0, il = groups.length; i < il; ++ i ) {

				const group = groups[ i ];

				const start = group.start;
				const count = group.count;

				for ( let j = start, jl = start + count; j < jl; j += 3 ) {

					handleTriangle(
						indices[ j + 0 ],
						indices[ j + 1 ],
						indices[ j + 2 ]
					);

				}

			}

			const tmp = new Vector3(), tmp2 = new Vector3();
			const n = new Vector3(), n2 = new Vector3();

			function handleVertex( v ) {

				n.fromArray( normals, v * 3 );
				n2.copy( n );

				const t = tan1[ v ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( n2, t );
				const test = tmp2.dot( tan2[ v ] );
				const w = ( test < 0.0 ) ? - 1.0 : 1.0;

				tangents[ v * 4 ] = tmp.x;
				tangents[ v * 4 + 1 ] = tmp.y;
				tangents[ v * 4 + 2 ] = tmp.z;
				tangents[ v * 4 + 3 ] = w;

			}

			for ( let i = 0, il = groups.length; i < il; ++ i ) {

				const group = groups[ i ];

				const start = group.start;
				const count = group.count;

				for ( let j = start, jl = start + count; j < jl; j += 3 ) {

					handleVertex( indices[ j + 0 ] );
					handleVertex( indices[ j + 1 ] );
					handleVertex( indices[ j + 2 ] );

				}

			}

		}

		computeVertexNormals() {

			const index = this.index;
			const positionAttribute = this.getAttribute( 'position' );

			if ( positionAttribute !== undefined ) {

				let normalAttribute = this.getAttribute( 'normal' );

				if ( normalAttribute === undefined ) {

					normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
					this.setAttribute( 'normal', normalAttribute );

				} else {

					// reset existing normals to zero

					for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

						normalAttribute.setXYZ( i, 0, 0, 0 );

					}

				}

				const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
				const cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					for ( let i = 0, il = index.count; i < il; i += 3 ) {

						const vA = index.getX( i + 0 );
						const vB = index.getX( i + 1 );
						const vC = index.getX( i + 2 );

						pA.fromBufferAttribute( positionAttribute, vA );
						pB.fromBufferAttribute( positionAttribute, vB );
						pC.fromBufferAttribute( positionAttribute, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						nA.fromBufferAttribute( normalAttribute, vA );
						nB.fromBufferAttribute( normalAttribute, vB );
						nC.fromBufferAttribute( normalAttribute, vC );

						nA.add( cb );
						nB.add( cb );
						nC.add( cb );

						normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
						normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
						normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

						pA.fromBufferAttribute( positionAttribute, i + 0 );
						pB.fromBufferAttribute( positionAttribute, i + 1 );
						pC.fromBufferAttribute( positionAttribute, i + 2 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

					}

				}

				this.normalizeNormals();

				normalAttribute.needsUpdate = true;

			}

		}

		merge( geometry, offset ) {

			if ( ! ( geometry && geometry.isBufferGeometry ) ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) {

				offset = 0;

				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
				);

			}

			const attributes = this.attributes;

			for ( const key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				const attribute1 = attributes[ key ];
				const attributeArray1 = attribute1.array;

				const attribute2 = geometry.attributes[ key ];
				const attributeArray2 = attribute2.array;

				const attributeOffset = attribute2.itemSize * offset;
				const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

				for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		}

		normalizeNormals() {

			const normals = this.attributes.normal;

			for ( let i = 0, il = normals.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( normals, i );

				_vector$8.normalize();

				normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

			}

		}

		toNonIndexed() {

			function convertBufferAttribute( attribute, indices ) {

				const array = attribute.array;
				const itemSize = attribute.itemSize;
				const normalized = attribute.normalized;

				const array2 = new array.constructor( indices.length * itemSize );

				let index = 0, index2 = 0;

				for ( let i = 0, l = indices.length; i < l; i ++ ) {

					if ( attribute.isInterleavedBufferAttribute ) {

						index = indices[ i ] * attribute.data.stride + attribute.offset;

					} else {

						index = indices[ i ] * itemSize;

					}

					for ( let j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				return new BufferAttribute( array2, itemSize, normalized );

			}

			//

			if ( this.index === null ) {

				console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
				return this;

			}

			const geometry2 = new BufferGeometry();

			const indices = this.index.array;
			const attributes = this.attributes;

			// attributes

			for ( const name in attributes ) {

				const attribute = attributes[ name ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				geometry2.setAttribute( name, newAttribute );

			}

			// morph attributes

			const morphAttributes = this.morphAttributes;

			for ( const name in morphAttributes ) {

				const morphArray = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

					const attribute = morphAttribute[ i ];

					const newAttribute = convertBufferAttribute( attribute, indices );

					morphArray.push( newAttribute );

				}

				geometry2.morphAttributes[ name ] = morphArray;

			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative;

			// groups

			const groups = this.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );

			}

			return geometry2;

		}

		toJSON() {

			const data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			if ( this.parameters !== undefined ) {

				const parameters = this.parameters;

				for ( const key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			// for simplicity the code assumes attributes are not shared across geometries, see #15811

			data.data = { attributes: {} };

			const index = this.index;

			if ( index !== null ) {

				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call( index.array )
				};

			}

			const attributes = this.attributes;

			for ( const key in attributes ) {

				const attribute = attributes[ key ];

				data.data.attributes[ key ] = attribute.toJSON( data.data );

			}

			const morphAttributes = {};
			let hasMorphAttributes = false;

			for ( const key in this.morphAttributes ) {

				const attributeArray = this.morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];

					array.push( attribute.toJSON( data.data ) );

				}

				if ( array.length > 0 ) {

					morphAttributes[ key ] = array;

					hasMorphAttributes = true;

				}

			}

			if ( hasMorphAttributes ) {

				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;

			}

			const groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			const boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		}

		clone() {

			 return new this.constructor().copy( this );

		}

		copy( source ) {

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// used for storing cloned, shared data

			const data = {};

			// name

			this.name = source.name;

			// index

			const index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone( data ) );

			}

			// attributes

			const attributes = source.attributes;

			for ( const name in attributes ) {

				const attribute = attributes[ name ];
				this.setAttribute( name, attribute.clone( data ) );

			}

			// morph attributes

			const morphAttributes = source.morphAttributes;

			for ( const name in morphAttributes ) {

				const array = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone( data ) );

				}

				this.morphAttributes[ name ] = array;

			}

			this.morphTargetsRelative = source.morphTargetsRelative;

			// groups

			const groups = source.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			const boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			const boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			// geometry generator parameters

			if ( source.parameters !== undefined ) this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

	}

	BufferGeometry.prototype.isBufferGeometry = true;

	const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
	const _ray$2 = /*@__PURE__*/ new Ray();
	const _sphere$3 = /*@__PURE__*/ new Sphere();

	const _vA$1 = /*@__PURE__*/ new Vector3();
	const _vB$1 = /*@__PURE__*/ new Vector3();
	const _vC$1 = /*@__PURE__*/ new Vector3();

	const _tempA = /*@__PURE__*/ new Vector3();
	const _tempB = /*@__PURE__*/ new Vector3();
	const _tempC = /*@__PURE__*/ new Vector3();

	const _morphA = /*@__PURE__*/ new Vector3();
	const _morphB = /*@__PURE__*/ new Vector3();
	const _morphC = /*@__PURE__*/ new Vector3();

	const _uvA$1 = /*@__PURE__*/ new Vector2();
	const _uvB$1 = /*@__PURE__*/ new Vector2();
	const _uvC$1 = /*@__PURE__*/ new Vector2();

	const _intersectionPoint = /*@__PURE__*/ new Vector3();
	const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

	class Mesh extends Object3D {

		constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

			super();

			this.type = 'Mesh';

			this.geometry = geometry;
			this.material = material;

			this.updateMorphTargets();

		}

		copy( source ) {

			super.copy( source );

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		}

		updateMorphTargets() {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					const morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							const name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				const morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		}

		raycast( raycaster, intersects ) {

			const geometry = this.geometry;
			const material = this.material;
			const matrixWorld = this.matrixWorld;

			if ( material === undefined ) return;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$3.copy( geometry.boundingSphere );
			_sphere$3.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

			//

			_inverseMatrix$2.copy( matrixWorld ).invert();
			_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

			// Check boundingBox before continuing

			if ( geometry.boundingBox !== null ) {

				if ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;

			}

			let intersection;

			if ( geometry.isBufferGeometry ) {

				const index = geometry.index;
				const position = geometry.attributes.position;
				const morphPosition = geometry.morphAttributes.position;
				const morphTargetsRelative = geometry.morphTargetsRelative;
				const uv = geometry.attributes.uv;
				const uv2 = geometry.attributes.uv2;
				const groups = geometry.groups;
				const drawRange = geometry.drawRange;

				if ( index !== null ) {

					// indexed buffer geometry

					if ( Array.isArray( material ) ) {

						for ( let i = 0, il = groups.length; i < il; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							const start = Math.max( group.start, drawRange.start );
							const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

							for ( let j = start, jl = end; j < jl; j += 3 ) {

								const a = index.getX( j );
								const b = index.getX( j + 1 );
								const c = index.getX( j + 2 );

								intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
									intersection.face.materialIndex = group.materialIndex;
									intersects.push( intersection );

								}

							}

						}

					} else {

						const start = Math.max( 0, drawRange.start );
						const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

						for ( let i = start, il = end; i < il; i += 3 ) {

							const a = index.getX( i );
							const b = index.getX( i + 1 );
							const c = index.getX( i + 2 );

							intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
								intersects.push( intersection );

							}

						}

					}

				} else if ( position !== undefined ) {

					// non-indexed buffer geometry

					if ( Array.isArray( material ) ) {

						for ( let i = 0, il = groups.length; i < il; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							const start = Math.max( group.start, drawRange.start );
							const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

							for ( let j = start, jl = end; j < jl; j += 3 ) {

								const a = j;
								const b = j + 1;
								const c = j + 2;

								intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
									intersection.face.materialIndex = group.materialIndex;
									intersects.push( intersection );

								}

							}

						}

					} else {

						const start = Math.max( 0, drawRange.start );
						const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

						for ( let i = start, il = end; i < il; i += 3 ) {

							const a = i;
							const b = i + 1;
							const c = i + 2;

							intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
								intersects.push( intersection );

							}

						}

					}

				}

			} else if ( geometry.isGeometry ) {

				console.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

	Mesh.prototype.isMesh = true;

	function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

		let intersect;

		if ( material.side === BackSide ) {

			intersect = ray.intersectTriangle( pC, pB, pA, true, point );

		} else {

			intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

		}

		if ( intersect === null ) return null;

		_intersectionPointWorld.copy( point );
		_intersectionPointWorld.applyMatrix4( object.matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

		if ( distance < raycaster.near || distance > raycaster.far ) return null;

		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};

	}

	function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

		_vA$1.fromBufferAttribute( position, a );
		_vB$1.fromBufferAttribute( position, b );
		_vC$1.fromBufferAttribute( position, c );

		const morphInfluences = object.morphTargetInfluences;

		if ( morphPosition && morphInfluences ) {

			_morphA.set( 0, 0, 0 );
			_morphB.set( 0, 0, 0 );
			_morphC.set( 0, 0, 0 );

			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morphAttribute = morphPosition[ i ];

				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morphAttribute, a );
				_tempB.fromBufferAttribute( morphAttribute, b );
				_tempC.fromBufferAttribute( morphAttribute, c );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );
					_morphB.addScaledVector( _tempB, influence );
					_morphC.addScaledVector( _tempC, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );
					_morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );
					_morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );

				}

			}

			_vA$1.add( _morphA );
			_vB$1.add( _morphB );
			_vC$1.add( _morphC );

		}

		if ( object.isSkinnedMesh ) {

			object.boneTransform( a, _vA$1 );
			object.boneTransform( b, _vB$1 );
			object.boneTransform( c, _vC$1 );

		}

		const intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

		if ( intersection ) {

			if ( uv ) {

				_uvA$1.fromBufferAttribute( uv, a );
				_uvB$1.fromBufferAttribute( uv, b );
				_uvC$1.fromBufferAttribute( uv, c );

				intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

			}

			if ( uv2 ) {

				_uvA$1.fromBufferAttribute( uv2, a );
				_uvB$1.fromBufferAttribute( uv2, b );
				_uvC$1.fromBufferAttribute( uv2, c );

				intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

			}

			const face = {
				a: a,
				b: b,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			};

			Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

			intersection.face = face;

		}

		return intersection;

	}

	class BoxGeometry extends BufferGeometry {

		constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

			super();

			this.type = 'BoxGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			const scope = this;

			// segments

			widthSegments = Math.floor( widthSegments );
			heightSegments = Math.floor( heightSegments );
			depthSegments = Math.floor( depthSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let numberOfVertices = 0;
			let groupStart = 0;

			// build each side of the box geometry

			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
			buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
			buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

				const segmentWidth = width / gridX;
				const segmentHeight = height / gridY;

				const widthHalf = width / 2;
				const heightHalf = height / 2;
				const depthHalf = depth / 2;

				const gridX1 = gridX + 1;
				const gridY1 = gridY + 1;

				let vertexCounter = 0;
				let groupCount = 0;

				const vector = new Vector3();

				// generate vertices, normals and uvs

				for ( let iy = 0; iy < gridY1; iy ++ ) {

					const y = iy * segmentHeight - heightHalf;

					for ( let ix = 0; ix < gridX1; ix ++ ) {

						const x = ix * segmentWidth - widthHalf;

						// set values to correct vector component

						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;

						// now apply vector to vertex buffer

						vertices.push( vector.x, vector.y, vector.z );

						// set values to correct vector component

						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;

						// now apply vector to normal buffer

						normals.push( vector.x, vector.y, vector.z );

						// uvs

						uvs.push( ix / gridX );
						uvs.push( 1 - ( iy / gridY ) );

						// counters

						vertexCounter += 1;

					}

				}

				// indices

				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment

				for ( let iy = 0; iy < gridY; iy ++ ) {

					for ( let ix = 0; ix < gridX; ix ++ ) {

						const a = numberOfVertices + ix + gridX1 * iy;
						const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// increase counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, materialIndex );

				// calculate new start value for groups

				groupStart += groupCount;

				// update total number of vertices

				numberOfVertices += vertexCounter;

			}

		}

		static fromJSON( data ) {

			return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

		}

	}

	/**
	 * Uniform Utilities
	 */

	function cloneUniforms( src ) {

		const dst = {};

		for ( const u in src ) {

			dst[ u ] = {};

			for ( const p in src[ u ] ) {

				const property = src[ u ][ p ];

				if ( property && ( property.isColor ||
					property.isMatrix3 || property.isMatrix4 ||
					property.isVector2 || property.isVector3 || property.isVector4 ||
					property.isTexture || property.isQuaternion ) ) {

					dst[ u ][ p ] = property.clone();

				} else if ( Array.isArray( property ) ) {

					dst[ u ][ p ] = property.slice();

				} else {

					dst[ u ][ p ] = property;

				}

			}

		}

		return dst;

	}

	function mergeUniforms( uniforms ) {

		const merged = {};

		for ( let u = 0; u < uniforms.length; u ++ ) {

			const tmp = cloneUniforms( uniforms[ u ] );

			for ( const p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	}

	// Legacy

	const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	class ShaderMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'ShaderMaterial';

			this.defines = {};
			this.uniforms = {};

			this.vertexShader = default_vertex;
			this.fragmentShader = default_fragment;

			this.linewidth = 1;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false; // set to use scene fog
			this.lights = false; // set to use scene lights
			this.clipping = false; // set to use user-defined clipping planes

			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			};

			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [ 1, 1, 1 ],
				'uv': [ 0, 0 ],
				'uv2': [ 0, 0 ]
			};

			this.index0AttributeName = undefined;
			this.uniformsNeedUpdate = false;

			this.glslVersion = null;

			if ( parameters !== undefined ) {

				if ( parameters.attributes !== undefined ) {

					console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

				}

				this.setValues( parameters );

			}

		}

		copy( source ) {

			super.copy( source );

			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;

			this.uniforms = cloneUniforms( source.uniforms );

			this.defines = Object.assign( {}, source.defines );

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.lights = source.lights;
			this.clipping = source.clipping;

			this.extensions = Object.assign( {}, source.extensions );

			this.glslVersion = source.glslVersion;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.glslVersion = this.glslVersion;
			data.uniforms = {};

			for ( const name in this.uniforms ) {

				const uniform = this.uniforms[ name ];
				const value = uniform.value;

				if ( value && value.isTexture ) {

					data.uniforms[ name ] = {
						type: 't',
						value: value.toJSON( meta ).uuid
					};

				} else if ( value && value.isColor ) {

					data.uniforms[ name ] = {
						type: 'c',
						value: value.getHex()
					};

				} else if ( value && value.isVector2 ) {

					data.uniforms[ name ] = {
						type: 'v2',
						value: value.toArray()
					};

				} else if ( value && value.isVector3 ) {

					data.uniforms[ name ] = {
						type: 'v3',
						value: value.toArray()
					};

				} else if ( value && value.isVector4 ) {

					data.uniforms[ name ] = {
						type: 'v4',
						value: value.toArray()
					};

				} else if ( value && value.isMatrix3 ) {

					data.uniforms[ name ] = {
						type: 'm3',
						value: value.toArray()
					};

				} else if ( value && value.isMatrix4 ) {

					data.uniforms[ name ] = {
						type: 'm4',
						value: value.toArray()
					};

				} else {

					data.uniforms[ name ] = {
						value: value
					};

					// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

				}

			}

			if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;

			const extensions = {};

			for ( const key in this.extensions ) {

				if ( this.extensions[ key ] === true ) extensions[ key ] = true;

			}

			if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

			return data;

		}

	}

	ShaderMaterial.prototype.isShaderMaterial = true;

	class Camera extends Object3D {

		constructor() {

			super();

			this.type = 'Camera';

			this.matrixWorldInverse = new Matrix4();

			this.projectionMatrix = new Matrix4();
			this.projectionMatrixInverse = new Matrix4();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );

			this.projectionMatrix.copy( source.projectionMatrix );
			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

			return this;

		}

		getWorldDirection( target ) {

			this.updateWorldMatrix( true, false );

			const e = this.matrixWorld.elements;

			return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

		}

		updateMatrixWorld( force ) {

			super.updateMatrixWorld( force );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		}

		updateWorldMatrix( updateParents, updateChildren ) {

			super.updateWorldMatrix( updateParents, updateChildren );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	Camera.prototype.isCamera = true;

	class PerspectiveCamera extends Camera {

		constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

			super();

			this.type = 'PerspectiveCamera';

			this.fov = fov;
			this.zoom = 1;

			this.near = near;
			this.far = far;
			this.focus = 10;

			this.aspect = aspect;
			this.view = null;

			this.filmGauge = 35;	// width of the film (default in millimeters)
			this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

			this.updateProjectionMatrix();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		}

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength( focalLength ) {

			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		}

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength() {

			const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		}

		getEffectiveFOV() {

			return RAD2DEG * 2 * Math.atan(
				Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

		}

		getFilmWidth() {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		}

		getFilmHeight() {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		}

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   const w = 1920;
		 *   const h = 1080;
		 *   const fullWidth = w * 3;
		 *   const fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		}

		clearViewOffset() {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		}

		updateProjectionMatrix() {

			const near = this.near;
			let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
			let height = 2 * top;
			let width = this.aspect * height;
			let left = - 0.5 * width;
			const view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				const fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			const skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	}

	PerspectiveCamera.prototype.isPerspectiveCamera = true;

	const fov = 90, aspect = 1;

	class CubeCamera extends Object3D {

		constructor( near, far, renderTarget ) {

			super();

			this.type = 'CubeCamera';

			if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

				console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
				return;

			}

			this.renderTarget = renderTarget;

			const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.layers = this.layers;
			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
			this.add( cameraPX );

			const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.layers = this.layers;
			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
			this.add( cameraNX );

			const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.layers = this.layers;
			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
			this.add( cameraPY );

			const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.layers = this.layers;
			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
			this.add( cameraNY );

			const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.layers = this.layers;
			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
			this.add( cameraPZ );

			const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.layers = this.layers;
			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
			this.add( cameraNZ );

		}

		update( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			const renderTarget = this.renderTarget;

			const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

			const currentRenderTarget = renderer.getRenderTarget();

			const currentOutputEncoding = renderer.outputEncoding;
			const currentToneMapping = renderer.toneMapping;
			const currentXrEnabled = renderer.xr.enabled;

			renderer.outputEncoding = LinearEncoding;
			renderer.toneMapping = NoToneMapping;
			renderer.xr.enabled = false;

			const generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderer.setRenderTarget( renderTarget, 0 );
			renderer.render( scene, cameraPX );

			renderer.setRenderTarget( renderTarget, 1 );
			renderer.render( scene, cameraNX );

			renderer.setRenderTarget( renderTarget, 2 );
			renderer.render( scene, cameraPY );

			renderer.setRenderTarget( renderTarget, 3 );
			renderer.render( scene, cameraNY );

			renderer.setRenderTarget( renderTarget, 4 );
			renderer.render( scene, cameraPZ );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderer.setRenderTarget( renderTarget, 5 );
			renderer.render( scene, cameraNZ );

			renderer.setRenderTarget( currentRenderTarget );

			renderer.outputEncoding = currentOutputEncoding;
			renderer.toneMapping = currentToneMapping;
			renderer.xr.enabled = currentXrEnabled;

			renderTarget.texture.needsPMREMUpdate = true;

		}

	}

	class CubeTexture extends Texture {

		constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

			super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.flipY = false;

		}

		get images() {

			return this.image;

		}

		set images( value ) {

			this.image = value;

		}

	}

	CubeTexture.prototype.isCubeTexture = true;

	class WebGLCubeRenderTarget extends WebGLRenderTarget {

		constructor( size, options = {} ) {

			super( size, size, options );

			const image = { width: size, height: size, depth: 1 };
			const images = [ image, image, image, image, image, image ];

			this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

			// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
			// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

			this.texture.isRenderTargetTexture = true;

			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		}

		fromEquirectangularTexture( renderer, texture ) {

			this.texture.type = texture.type;
			this.texture.encoding = texture.encoding;

			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;

			const shader = {

				uniforms: {
					tEquirect: { value: null },
				},

				vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

				fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			};

			const geometry = new BoxGeometry( 5, 5, 5 );

			const material = new ShaderMaterial( {

				name: 'CubemapFromEquirect',

				uniforms: cloneUniforms( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending

			} );

			material.uniforms.tEquirect.value = texture;

			const mesh = new Mesh( geometry, material );

			const currentMinFilter = texture.minFilter;

			// Avoid blurred poles
			if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

			const camera = new CubeCamera( 1, 10, this );
			camera.update( renderer, mesh );

			texture.minFilter = currentMinFilter;

			mesh.geometry.dispose();
			mesh.material.dispose();

			return this;

		}

		clear( renderer, color, depth, stencil ) {

			const currentRenderTarget = renderer.getRenderTarget();

			for ( let i = 0; i < 6; i ++ ) {

				renderer.setRenderTarget( this, i );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( currentRenderTarget );

		}

	}

	WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

	const _vector1 = /*@__PURE__*/ new Vector3();
	const _vector2 = /*@__PURE__*/ new Vector3();
	const _normalMatrix = /*@__PURE__*/ new Matrix3();

	class Plane {

		constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

			// normal is assumed to be normalized

			this.normal = normal;
			this.constant = constant;

		}

		set( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		}

		setComponents( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		}

		setFromNormalAndCoplanarPoint( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		}

		setFromCoplanarPoints( a, b, c ) {

			const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		}

		copy( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		}

		normalize() {

			// Note: will lead to a divide by zero if the plane is invalid.

			const inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		}

		negate() {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		}

		distanceToPoint( point ) {

			return this.normal.dot( point ) + this.constant;

		}

		distanceToSphere( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		}

		projectPoint( point, target ) {

			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		}

		intersectLine( line, target ) {

			const direction = line.delta( _vector1 );

			const denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return target.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return null;

			}

			const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return null;

			}

			return target.copy( direction ).multiplyScalar( t ).add( line.start );

		}

		intersectsLine( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			const startSign = this.distanceToPoint( line.start );
			const endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		}

		intersectsBox( box ) {

			return box.intersectsPlane( this );

		}

		intersectsSphere( sphere ) {

			return sphere.intersectsPlane( this );

		}

		coplanarPoint( target ) {

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		}

		applyMatrix4( matrix, optionalNormalMatrix ) {

			const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

			const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

			const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			this.constant = - referencePoint.dot( normal );

			return this;

		}

		translate( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		}

		equals( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	Plane.prototype.isPlane = true;

	const _sphere$2 = /*@__PURE__*/ new Sphere();
	const _vector$7 = /*@__PURE__*/ new Vector3();

	class Frustum {

		constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

			this.planes = [ p0, p1, p2, p3, p4, p5 ];

		}

		set( p0, p1, p2, p3, p4, p5 ) {

			const planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		}

		copy( frustum ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		}

		setFromProjectionMatrix( m ) {

			const planes = this.planes;
			const me = m.elements;
			const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		}

		intersectsObject( object ) {

			const geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( _sphere$2 );

		}

		intersectsSprite( sprite ) {

			_sphere$2.center.set( 0, 0, 0 );
			_sphere$2.radius = 0.7071067811865476;
			_sphere$2.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( _sphere$2 );

		}

		intersectsSphere( sphere ) {

			const planes = this.planes;
			const center = sphere.center;
			const negRadius = - sphere.radius;

			for ( let i = 0; i < 6; i ++ ) {

				const distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		}

		intersectsBox( box ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				const plane = planes[ i ];

				// corner at max distance

				_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

					return false;

				}

			}

			return true;

		}

		containsPoint( point ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	function WebGLAnimation() {

		let context = null;
		let isAnimating = false;
		let animationLoop = null;
		let requestId = null;

		function onAnimationFrame( time, frame ) {

			animationLoop( time, frame );

			requestId = context.requestAnimationFrame( onAnimationFrame );

		}

		return {

			start: function () {

				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;

				requestId = context.requestAnimationFrame( onAnimationFrame );

				isAnimating = true;

			},

			stop: function () {

				context.cancelAnimationFrame( requestId );

				isAnimating = false;

			},

			setAnimationLoop: function ( callback ) {

				animationLoop = callback;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

	}

	function WebGLAttributes( gl, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		const buffers = new WeakMap();

		function createBuffer( attribute, bufferType ) {

			const array = attribute.array;
			const usage = attribute.usage;

			const buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			let type;

			if ( array instanceof Float32Array ) {

				type = 5126;

			} else if ( array instanceof Uint16Array ) {

				if ( attribute.isFloat16BufferAttribute ) {

					if ( isWebGL2 ) {

						type = 5131;

					} else {

						throw new Error( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

					}

				} else {

					type = 5123;

				}

			} else if ( array instanceof Int16Array ) {

				type = 5122;

			} else if ( array instanceof Uint32Array ) {

				type = 5125;

			} else if ( array instanceof Int32Array ) {

				type = 5124;

			} else if ( array instanceof Int8Array ) {

				type = 5120;

			} else if ( array instanceof Uint8Array ) {

				type = 5121;

			} else if ( array instanceof Uint8ClampedArray ) {

				type = 5121;

			} else {

				throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			const array = attribute.array;
			const updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else {

				if ( isWebGL2 ) {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array, updateRange.offset, updateRange.count );

				} else {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				}

				updateRange.count = - 1; // reset range

			}

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers.get( attribute );

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			const data = buffers.get( attribute );

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				buffers.delete( attribute );

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isGLBufferAttribute ) {

				const cached = buffers.get( attribute );

				if ( ! cached || cached.version < attribute.version ) {

					buffers.set( attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					} );

				}

				return;

			}

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			const data = buffers.get( attribute );

			if ( data === undefined ) {

				buffers.set( attribute, createBuffer( attribute, bufferType ) );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	class PlaneGeometry extends BufferGeometry {

		constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

			super();
			this.type = 'PlaneGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			const width_half = width / 2;
			const height_half = height / 2;

			const gridX = Math.floor( widthSegments );
			const gridY = Math.floor( heightSegments );

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			const segment_width = width / gridX;
			const segment_height = height / gridY;

			//

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segment_height - height_half;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segment_width - width_half;

					vertices.push( x, - y, 0 );

					normals.push( 0, 0, 1 );

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

				}

			}

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = ix + gridX1 * iy;
					const b = ix + gridX1 * ( iy + 1 );
					const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = ( ix + 1 ) + gridX1 * iy;

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		static fromJSON( data ) {

			return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

		}

	}

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

	var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

	var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";

	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

	var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

	var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

	var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

	var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

	var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

	var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

	var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

	var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

	var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

	var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";

	var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";

	var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

	var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

	const vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

	const fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	const fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

	const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

	const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

	const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

	const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

	const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

	const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

	const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

	const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	const ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		alphatest_pars_fragment: alphatest_pars_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphcolor_vertex: morphcolor_vertex,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normal_pars_fragment: normal_pars_fragment,
		normal_pars_vertex: normal_pars_vertex,
		normal_vertex: normal_vertex,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		output_fragment: output_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmission_fragment: transmission_fragment,
		transmission_pars_fragment: transmission_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,

		background_vert: vertex$g,
		background_frag: fragment$g,
		cube_vert: vertex$f,
		cube_frag: fragment$f,
		depth_vert: vertex$e,
		depth_frag: fragment$e,
		distanceRGBA_vert: vertex$d,
		distanceRGBA_frag: fragment$d,
		equirect_vert: vertex$c,
		equirect_frag: fragment$c,
		linedashed_vert: vertex$b,
		linedashed_frag: fragment$b,
		meshbasic_vert: vertex$a,
		meshbasic_frag: fragment$a,
		meshlambert_vert: vertex$9,
		meshlambert_frag: fragment$9,
		meshmatcap_vert: vertex$8,
		meshmatcap_frag: fragment$8,
		meshnormal_vert: vertex$7,
		meshnormal_frag: fragment$7,
		meshphong_vert: vertex$6,
		meshphong_frag: fragment$6,
		meshphysical_vert: vertex$5,
		meshphysical_frag: fragment$5,
		meshtoon_vert: vertex$4,
		meshtoon_frag: fragment$4,
		points_vert: vertex$3,
		points_frag: fragment$3,
		shadow_vert: vertex$2,
		shadow_frag: fragment$2,
		sprite_vert: vertex$1,
		sprite_frag: fragment$1
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */

	const UniformsLib = {

		common: {

			diffuse: { value: new Color( 0xffffff ) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },
			uv2Transform: { value: new Matrix3() },

			alphaMap: { value: null },
			alphaTest: { value: 0 }

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 }, // basic, lambert, phong
			ior: { value: 1.5 }, // physical
			refractionRatio: { value: 0.98 } // basic, lambert, phong

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 }

		},

		emissivemap: {

			emissiveMap: { value: null }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		roughnessmap: {

			roughnessMap: { value: null }

		},

		metalnessmap: {

			metalnessMap: { value: null }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			lightProbe: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {}
			} },

			directionalLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {}
			} },

			spotLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {}
			} },

			pointLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} },

			ltc_1: { value: null },
			ltc_2: { value: null }

		},

		points: {

			diffuse: { value: new Color( 0xffffff ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			alphaMap: { value: null },
			alphaTest: { value: 0 },
			uvTransform: { value: new Matrix3() }

		},

		sprite: {

			diffuse: { value: new Color( 0xffffff ) },
			opacity: { value: 1.0 },
			center: { value: new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			alphaMap: { value: null },
			alphaTest: { value: 0 },
			uvTransform: { value: new Matrix3() }

		}

	};

	const ShaderLib = {

		basic: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					roughness: { value: 1.0 },
					metalness: { value: 0.0 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		toon: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag

		},

		matcap: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			] ),

			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag

		},

		points: {

			uniforms: mergeUniforms( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.meshnormal_vert,
			fragmentShader: ShaderChunk.meshnormal_frag

		},

		sprite: {

			uniforms: mergeUniforms( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag

		},

		background: {

			uniforms: {
				uvTransform: { value: new Matrix3() },
				t2D: { value: null },
			},

			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag

		},
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {

			uniforms: mergeUniforms( [
				UniformsLib.envmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: mergeUniforms( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: mergeUniforms( [
			ShaderLib.standard.uniforms,
			{
				clearcoat: { value: 0 },
				clearcoatMap: { value: null },
				clearcoatRoughness: { value: 0 },
				clearcoatRoughnessMap: { value: null },
				clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
				clearcoatNormalMap: { value: null },
				sheen: { value: 0 },
				sheenColor: { value: new Color( 0x000000 ) },
				sheenColorMap: { value: null },
				sheenRoughness: { value: 1 },
				sheenRoughnessMap: { value: null },
				transmission: { value: 0 },
				transmissionMap: { value: null },
				transmissionSamplerSize: { value: new Vector2() },
				transmissionSamplerMap: { value: null },
				thickness: { value: 0 },
				thicknessMap: { value: null },
				attenuationDistance: { value: 0 },
				attenuationColor: { value: new Color( 0x000000 ) },
				specularIntensity: { value: 1 },
				specularIntensityMap: { value: null },
				specularColor: { value: new Color( 1, 1, 1 ) },
				specularColorMap: { value: null },
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	function WebGLBackground( renderer, cubemaps, state, objects, alpha, premultipliedAlpha ) {

		const clearColor = new Color( 0x000000 );
		let clearAlpha = alpha === true ? 0 : 1;

		let planeMesh;
		let boxMesh;

		let currentBackground = null;
		let currentBackgroundVersion = 0;
		let currentTonemapping = null;

		function render( renderList, scene ) {

			let forceClear = false;
			let background = scene.isScene === true ? scene.background : null;

			if ( background && background.isTexture ) {

				background = cubemaps.get( background );

			}

			// Ignore background in AR
			// TODO: Reconsider this.

			const xr = renderer.xr;
			const session = xr.getSession && xr.getSession();

			if ( session && session.environmentBlendMode === 'additive' ) {

				background = null;

			}

			if ( background === null ) {

				setClear( clearColor, clearAlpha );

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							name: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.deleteAttribute( 'normal' );
					boxMesh.geometry.deleteAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					// enable code injection for non-built-in material
					Object.defineProperty( boxMesh.material, 'envMap', {

						get: function () {

							return this.uniforms.envMap.value;

						}

					} );

					objects.update( boxMesh );

				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					boxMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}

				// push to the pre-sorted opaque render list
				renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeMesh === undefined ) {

					planeMesh = new Mesh(
						new PlaneGeometry( 2, 2 ),
						new ShaderMaterial( {
							name: 'BackgroundMaterial',
							uniforms: cloneUniforms( ShaderLib.background.uniforms ),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					planeMesh.geometry.deleteAttribute( 'normal' );

					// enable code injection for non-built-in material
					Object.defineProperty( planeMesh.material, 'map', {

						get: function () {

							return this.uniforms.t2D.value;

						}

					} );

					objects.update( planeMesh );

				}

				planeMesh.material.uniforms.t2D.value = background;

				if ( background.matrixAutoUpdate === true ) {

					background.updateMatrix();

				}

				planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					planeMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}


				// push to the pre-sorted opaque render list
				renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

			}

		}

		function setClear( color, alpha ) {

			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha = 1 ) {

				clearColor.set( color );
				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

		const maxVertexAttributes = gl.getParameter( 34921 );

		const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
		const vaoAvailable = capabilities.isWebGL2 || extension !== null;

		const bindingStates = {};

		const defaultState = createBindingState( null );
		let currentState = defaultState;
		let forceUpdate = false;

		function setup( object, material, program, geometry, index ) {

			let updateBuffers = false;

			if ( vaoAvailable ) {

				const state = getBindingState( geometry, program, material );

				if ( currentState !== state ) {

					currentState = state;
					bindVertexArrayObject( currentState.object );

				}

				updateBuffers = needsUpdate( geometry, index );

				if ( updateBuffers ) saveCache( geometry, index );

			} else {

				const wireframe = ( material.wireframe === true );

				if ( currentState.geometry !== geometry.id ||
					currentState.program !== program.id ||
					currentState.wireframe !== wireframe ) {

					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;

					updateBuffers = true;

				}

			}

			if ( object.isInstancedMesh === true ) {

				updateBuffers = true;

			}

			if ( index !== null ) {

				attributes.update( index, 34963 );

			}

			if ( updateBuffers || forceUpdate ) {

				forceUpdate = false;

				setupVertexAttributes( object, material, program, geometry );

				if ( index !== null ) {

					gl.bindBuffer( 34963, attributes.get( index ).buffer );

				}

			}

		}

		function createVertexArrayObject() {

			if ( capabilities.isWebGL2 ) return gl.createVertexArray();

			return extension.createVertexArrayOES();

		}

		function bindVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

			return extension.bindVertexArrayOES( vao );

		}

		function deleteVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

			return extension.deleteVertexArrayOES( vao );

		}

		function getBindingState( geometry, program, material ) {

			const wireframe = ( material.wireframe === true );

			let programMap = bindingStates[ geometry.id ];

			if ( programMap === undefined ) {

				programMap = {};
				bindingStates[ geometry.id ] = programMap;

			}

			let stateMap = programMap[ program.id ];

			if ( stateMap === undefined ) {

				stateMap = {};
				programMap[ program.id ] = stateMap;

			}

			let state = stateMap[ wireframe ];

			if ( state === undefined ) {

				state = createBindingState( createVertexArrayObject() );
				stateMap[ wireframe ] = state;

			}

			return state;

		}

		function createBindingState( vao ) {

			const newAttributes = [];
			const enabledAttributes = [];
			const attributeDivisors = [];

			for ( let i = 0; i < maxVertexAttributes; i ++ ) {

				newAttributes[ i ] = 0;
				enabledAttributes[ i ] = 0;
				attributeDivisors[ i ] = 0;

			}

			return {

				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,

				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null

			};

		}

		function needsUpdate( geometry, index ) {

			const cachedAttributes = currentState.attributes;
			const geometryAttributes = geometry.attributes;

			let attributesNum = 0;

			for ( const key in geometryAttributes ) {

				const cachedAttribute = cachedAttributes[ key ];
				const geometryAttribute = geometryAttributes[ key ];

				if ( cachedAttribute === undefined ) return true;

				if ( cachedAttribute.attribute !== geometryAttribute ) return true;

				if ( cachedAttribute.data !== geometryAttribute.data ) return true;

				attributesNum ++;

			}

			if ( currentState.attributesNum !== attributesNum ) return true;

			if ( currentState.index !== index ) return true;

			return false;

		}

		function saveCache( geometry, index ) {

			const cache = {};
			const attributes = geometry.attributes;
			let attributesNum = 0;

			for ( const key in attributes ) {

				const attribute = attributes[ key ];

				const data = {};
				data.attribute = attribute;

				if ( attribute.data ) {

					data.data = attribute.data;

				}

				cache[ key ] = data;

				attributesNum ++;

			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;

			currentState.index = index;

		}

		function initAttributes() {

			const newAttributes = currentState.newAttributes;

			for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			enableAttributeAndDivisor( attribute, 0 );

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;
			const attributeDivisors = currentState.attributeDivisors;

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

				extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;

			for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

			if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

				gl.vertexAttribIPointer( index, size, type, stride, offset );

			} else {

				gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

			}

		}

		function setupVertexAttributes( object, material, program, geometry ) {

			if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

			}

			initAttributes();

			const geometryAttributes = geometry.attributes;

			const programAttributes = program.getAttributes();

			const materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute.location >= 0 ) {

					let geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute === undefined ) {

						if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
						if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

					}

					if ( geometryAttribute !== undefined ) {

						const normalized = geometryAttribute.normalized;
						const size = geometryAttribute.itemSize;

						const attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						const buffer = attribute.buffer;
						const type = attribute.type;
						const bytesPerElement = attribute.bytesPerElement;

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							const data = geometryAttribute.data;
							const stride = data.stride;
							const offset = geometryAttribute.offset;

							if ( data.isInstancedInterleavedBuffer ) {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

								}

								if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = data.meshPerAttribute * data.count;

								}

							} else {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttribute( programAttribute.location + i );

								}

							}

							gl.bindBuffer( 34962, buffer );

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								vertexAttribPointer(
									programAttribute.location + i,
									size / programAttribute.locationSize,
									type,
									normalized,
									stride * bytesPerElement,
									( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement
								);

							}

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

								}

								if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttribute( programAttribute.location + i );

								}

							}

							gl.bindBuffer( 34962, buffer );

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								vertexAttribPointer(
									programAttribute.location + i,
									size / programAttribute.locationSize,
									type,
									normalized,
									size * bytesPerElement,
									( size / programAttribute.locationSize ) * i * bytesPerElement
								);

							}

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						const value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									gl.vertexAttrib2fv( programAttribute.location, value );
									break;

								case 3:
									gl.vertexAttrib3fv( programAttribute.location, value );
									break;

								case 4:
									gl.vertexAttrib4fv( programAttribute.location, value );
									break;

								default:
									gl.vertexAttrib1fv( programAttribute.location, value );

							}

						}

					}

				}

			}

			disableUnusedAttributes();

		}

		function dispose() {

			reset();

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				for ( const programId in programMap ) {

					const stateMap = programMap[ programId ];

					for ( const wireframe in stateMap ) {

						deleteVertexArrayObject( stateMap[ wireframe ].object );

						delete stateMap[ wireframe ];

					}

					delete programMap[ programId ];

				}

				delete bindingStates[ geometryId ];

			}

		}

		function releaseStatesOfGeometry( geometry ) {

			if ( bindingStates[ geometry.id ] === undefined ) return;

			const programMap = bindingStates[ geometry.id ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometry.id ];

		}

		function releaseStatesOfProgram( program ) {

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				if ( programMap[ program.id ] === undefined ) continue;

				const stateMap = programMap[ program.id ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ program.id ];

			}

		}

		function reset() {

			resetDefaultState();
			forceUpdate = true;

			if ( currentState === defaultState ) return;

			currentState = defaultState;
			bindVertexArrayObject( currentState.object );

		}

		// for backward-compatibility

		function resetDefaultState() {

			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;

		}

		return {

			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes

		};

	}

	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		let mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			let extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawArraysInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawArraysInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, start, count, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLCapabilities( gl, extensions, parameters ) {

		let maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
					gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
					gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
			( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		const maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		const drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );

		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		const maxTextures = gl.getParameter( 34930 );
		const maxVertexTextures = gl.getParameter( 35660 );
		const maxTextureSize = gl.getParameter( 3379 );
		const maxCubemapSize = gl.getParameter( 34076 );

		const maxAttributes = gl.getParameter( 34921 );
		const maxVertexUniforms = gl.getParameter( 36347 );
		const maxVaryings = gl.getParameter( 36348 );
		const maxFragmentUniforms = gl.getParameter( 36349 );

		const vertexTextures = maxVertexTextures > 0;
		const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
		const floatVertexTextures = vertexTextures && floatFragmentTextures;

		const maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

		return {

			isWebGL2: isWebGL2,

			drawBuffers: drawBuffers,

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,

			maxSamples: maxSamples

		};

	}

	function WebGLClipping( properties ) {

		const scope = this;

		let globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false;

		const plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping, camera ) {

			const enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;
			resetGlobalState();

		};

		this.setState = function ( material, camera, useCache ) {

			const planes = material.clippingPlanes,
				clipIntersection = material.clipIntersection,
				clipShadows = material.clipShadows;

			const materialProperties = properties.get( material );

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4;

				let dstArray = materialProperties.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, useCache );

				for ( let i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			const nPlanes = planes !== null ? planes.length : 0;
			let dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					const flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;

			return dstArray;

		}

	}

	function WebGLCubeMaps( renderer ) {

		let cubemaps = new WeakMap();

		function mapTextureMapping( texture, mapping ) {

			if ( mapping === EquirectangularReflectionMapping ) {

				texture.mapping = CubeReflectionMapping;

			} else if ( mapping === EquirectangularRefractionMapping ) {

				texture.mapping = CubeRefractionMapping;

			}

			return texture;

		}

		function get( texture ) {

			if ( texture && texture.isTexture && texture.isRenderTargetTexture === false ) {

				const mapping = texture.mapping;

				if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

					if ( cubemaps.has( texture ) ) {

						const cubemap = cubemaps.get( texture ).texture;
						return mapTextureMapping( cubemap, texture.mapping );

					} else {

						const image = texture.image;

						if ( image && image.height > 0 ) {

							const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
							renderTarget.fromEquirectangularTexture( renderer, texture );
							cubemaps.set( texture, renderTarget );

							texture.addEventListener( 'dispose', onTextureDispose );

							return mapTextureMapping( renderTarget.texture, texture.mapping );

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

			return texture;

		}

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			const cubemap = cubemaps.get( texture );

			if ( cubemap !== undefined ) {

				cubemaps.delete( texture );
				cubemap.dispose();

			}

		}

		function dispose() {

			cubemaps = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	class OrthographicCamera extends Camera {

		constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

			super();

			this.type = 'OrthographicCamera';

			this.zoom = 1;
			this.view = null;

			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;

			this.near = near;
			this.far = far;

			this.updateProjectionMatrix();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		}

		setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		}

		clearViewOffset() {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		}

		updateProjectionMatrix() {

			const dx = ( this.right - this.left ) / ( 2 * this.zoom );
			const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			const cx = ( this.right + this.left ) / 2;
			const cy = ( this.top + this.bottom ) / 2;

			let left = cx - dx;
			let right = cx + dx;
			let top = cy + dy;
			let bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
				const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	}

	OrthographicCamera.prototype.isOrthographicCamera = true;

	const LOD_MIN = 4;

	// The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.
	const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

	// The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.
	const MAX_SAMPLES = 20;

	const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
	const _clearColor = /*@__PURE__*/ new Color();
	let _oldTarget = null;

	// Golden Ratio
	const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
	const INV_PHI = 1 / PHI;

	// Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.
	const _axisDirections = [
		/*@__PURE__*/ new Vector3( 1, 1, 1 ),
		/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
		/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
		/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
		/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
		/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
		/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
		/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
		/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
		/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];

	/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * Paper: Fast, Accurate Image-Based Lighting
	 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
	*/

	class PMREMGenerator {

		constructor( renderer ) {

			this._renderer = renderer;
			this._pingPongRenderTarget = null;

			this._lodMax = 0;
			this._cubeSize = 0;
			this._lodPlanes = [];
			this._sizeLods = [];
			this._sigmas = [];

			this._blurMaterial = null;
			this._cubemapMaterial = null;
			this._equirectMaterial = null;

			this._compileMaterial( this._blurMaterial );

		}

		/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */
		fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

			_oldTarget = this._renderer.getRenderTarget();

			this._setSize( 256 );

			const cubeUVRenderTarget = this._allocateTargets();
			cubeUVRenderTarget.depthBuffer = true;

			this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

			if ( sigma > 0 ) {

				this._blur( cubeUVRenderTarget, 0, 0, sigma );

			}

			this._applyPMREM( cubeUVRenderTarget );
			this._cleanup( cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * or HDR. The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		fromEquirectangular( equirectangular, renderTarget = null ) {

			return this._fromTexture( equirectangular, renderTarget );

		}

		/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * or HDR. The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		fromCubemap( cubemap, renderTarget = null ) {

			return this._fromTexture( cubemap, renderTarget );

		}

		/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileCubemapShader() {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial();
				this._compileMaterial( this._cubemapMaterial );

			}

		}

		/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileEquirectangularShader() {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial();
				this._compileMaterial( this._equirectMaterial );

			}

		}

		/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */
		dispose() {

			this._dispose();

			if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
			if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

		}

		// private interface

		_setSize( cubeSize ) {

			this._lodMax = Math.floor( Math.log2( cubeSize ) );
			this._cubeSize = Math.pow( 2, this._lodMax );

		}

		_dispose() {

			if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

			if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

			for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

				this._lodPlanes[ i ].dispose();

			}

		}

		_cleanup( outputTarget ) {

			this._renderer.setRenderTarget( _oldTarget );
			outputTarget.scissorTest = false;
			_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

		}

		_fromTexture( texture, renderTarget ) {

			if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

				this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

			} else { // Equirectangular

				this._setSize( texture.image.width / 4 );

			}

			_oldTarget = this._renderer.getRenderTarget();

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();
			this._textureToCubeUV( texture, cubeUVRenderTarget );
			this._applyPMREM( cubeUVRenderTarget );
			this._cleanup( cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		_allocateTargets() {

			const width = 3 * Math.max( this._cubeSize, 16 * 7 );
			const height = 4 * this._cubeSize - 32;

			const params = {
				magFilter: LinearFilter,
				minFilter: LinearFilter,
				generateMipmaps: false,
				type: HalfFloatType,
				format: RGBAFormat,
				encoding: LinearEncoding,
				depthBuffer: false
			};

			const cubeUVRenderTarget = _createRenderTarget( width, height, params );

			if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width ) {

				if ( this._pingPongRenderTarget !== null ) {

					this._dispose();

				}

				this._pingPongRenderTarget = _createRenderTarget( width, height, params );

				const { _lodMax } = this;
				( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

				this._blurMaterial = _getBlurShader( _lodMax, width, height );

			}

			return cubeUVRenderTarget;

		}

		_compileMaterial( material ) {

			const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
			this._renderer.compile( tmpMesh, _flatCamera );

		}

		_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

			const fov = 90;
			const aspect = 1;
			const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
			const upSign = [ 1, - 1, 1, 1, 1, 1 ];
			const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
			const renderer = this._renderer;

			const originalAutoClear = renderer.autoClear;
			const toneMapping = renderer.toneMapping;
			renderer.getClearColor( _clearColor );

			renderer.toneMapping = NoToneMapping;
			renderer.autoClear = false;

			const backgroundMaterial = new MeshBasicMaterial( {
				name: 'PMREM.Background',
				side: BackSide,
				depthWrite: false,
				depthTest: false,
			} );

			const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

			let useSolidColor = false;
			const background = scene.background;

			if ( background ) {

				if ( background.isColor ) {

					backgroundMaterial.color.copy( background );
					scene.background = null;
					useSolidColor = true;

				}

			} else {

				backgroundMaterial.color.copy( _clearColor );
				useSolidColor = true;

			}

			for ( let i = 0; i < 6; i ++ ) {

				const col = i % 3;

				if ( col === 0 ) {

					cubeCamera.up.set( 0, upSign[ i ], 0 );
					cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

				} else if ( col === 1 ) {

					cubeCamera.up.set( 0, 0, upSign[ i ] );
					cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

				} else {

					cubeCamera.up.set( 0, upSign[ i ], 0 );
					cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

				}

				const size = this._cubeSize;

				_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

				renderer.setRenderTarget( cubeUVRenderTarget );

				if ( useSolidColor ) {

					renderer.render( backgroundBox, cubeCamera );

				}

				renderer.render( scene, cubeCamera );

			}

			backgroundBox.geometry.dispose();
			backgroundBox.material.dispose();

			renderer.toneMapping = toneMapping;
			renderer.autoClear = originalAutoClear;
			scene.background = background;

		}

		_textureToCubeUV( texture, cubeUVRenderTarget ) {

			const renderer = this._renderer;

			const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

			if ( isCubeTexture ) {

				if ( this._cubemapMaterial === null ) {

					this._cubemapMaterial = _getCubemapMaterial();

				}

				this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;

			} else {

				if ( this._equirectMaterial === null ) {

					this._equirectMaterial = _getEquirectMaterial();

				}

			}

			const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
			const mesh = new Mesh( this._lodPlanes[ 0 ], material );

			const uniforms = material.uniforms;

			uniforms[ 'envMap' ].value = texture;

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

			renderer.setRenderTarget( cubeUVRenderTarget );
			renderer.render( mesh, _flatCamera );

		}

		_applyPMREM( cubeUVRenderTarget ) {

			const renderer = this._renderer;
			const autoClear = renderer.autoClear;
			renderer.autoClear = false;

			for ( let i = 1; i < this._lodPlanes.length; i ++ ) {

				const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

				const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

				this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

			}

			renderer.autoClear = autoClear;

		}

		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */
		_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

			const pingPongRenderTarget = this._pingPongRenderTarget;

			this._halfBlur(
				cubeUVRenderTarget,
				pingPongRenderTarget,
				lodIn,
				lodOut,
				sigma,
				'latitudinal',
				poleAxis );

			this._halfBlur(
				pingPongRenderTarget,
				cubeUVRenderTarget,
				lodOut,
				lodOut,
				sigma,
				'longitudinal',
				poleAxis );

		}

		_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

			const renderer = this._renderer;
			const blurMaterial = this._blurMaterial;

			if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

				console.error(
					'blur direction must be either latitudinal or longitudinal!' );

			}

			// Number of standard deviations at which to cut off the discrete approximation.
			const STANDARD_DEVIATIONS = 3;

			const blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
			const blurUniforms = blurMaterial.uniforms;

			const pixels = this._sizeLods[ lodIn ] - 1;
			const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
			const sigmaPixels = sigmaRadians / radiansPerPixel;
			const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

			if ( samples > MAX_SAMPLES ) {

				console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

			}

			const weights = [];
			let sum = 0;

			for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

				const x = i / sigmaPixels;
				const weight = Math.exp( - x * x / 2 );
				weights.push( weight );

				if ( i === 0 ) {

					sum += weight;

				} else if ( i < samples ) {

					sum += 2 * weight;

				}

			}

			for ( let i = 0; i < weights.length; i ++ ) {

				weights[ i ] = weights[ i ] / sum;

			}

			blurUniforms[ 'envMap' ].value = targetIn.texture;
			blurUniforms[ 'samples' ].value = samples;
			blurUniforms[ 'weights' ].value = weights;
			blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

			if ( poleAxis ) {

				blurUniforms[ 'poleAxis' ].value = poleAxis;

			}

			const { _lodMax } = this;
			blurUniforms[ 'dTheta' ].value = radiansPerPixel;
			blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

			const outputSize = this._sizeLods[ lodOut ];
			const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
			const y = 4 * ( this._cubeSize - outputSize );

			_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
			renderer.setRenderTarget( targetOut );
			renderer.render( blurMesh, _flatCamera );

		}

	}



	function _createPlanes( lodMax ) {

		const lodPlanes = [];
		const sizeLods = [];
		const sigmas = [];

		let lod = lodMax;

		const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

		for ( let i = 0; i < totalLods; i ++ ) {

			const sizeLod = Math.pow( 2, lod );
			sizeLods.push( sizeLod );
			let sigma = 1.0 / sizeLod;

			if ( i > lodMax - LOD_MIN ) {

				sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

			} else if ( i === 0 ) {

				sigma = 0;

			}

			sigmas.push( sigma );

			const texelSize = 1.0 / ( sizeLod - 1 );
			const min = - texelSize / 2;
			const max = 1 + texelSize / 2;
			const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

			const cubeFaces = 6;
			const vertices = 6;
			const positionSize = 3;
			const uvSize = 2;
			const faceIndexSize = 1;

			const position = new Float32Array( positionSize * vertices * cubeFaces );
			const uv = new Float32Array( uvSize * vertices * cubeFaces );
			const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

			for ( let face = 0; face < cubeFaces; face ++ ) {

				const x = ( face % 3 ) * 2 / 3 - 1;
				const y = face > 2 ? 0 : - 1;
				const coordinates = [
					x, y, 0,
					x + 2 / 3, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y + 1, 0
				];
				position.set( coordinates, positionSize * vertices * face );
				uv.set( uv1, uvSize * vertices * face );
				const fill = [ face, face, face, face, face, face ];
				faceIndex.set( fill, faceIndexSize * vertices * face );

			}

			const planes = new BufferGeometry();
			planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
			planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
			planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
			lodPlanes.push( planes );

			if ( lod > LOD_MIN ) {

				lod --;

			}

		}

		return { lodPlanes, sizeLods, sigmas };

	}

	function _createRenderTarget( width, height, params ) {

		const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
		cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
		cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
		cubeUVRenderTarget.scissorTest = true;
		return cubeUVRenderTarget;

	}

	function _setViewport( target, x, y, width, height ) {

		target.viewport.set( x, y, width, height );
		target.scissor.set( x, y, width, height );

	}

	function _getBlurShader( lodMax, width, height ) {

		const weights = new Float32Array( MAX_SAMPLES );
		const poleAxis = new Vector3( 0, 1, 0 );
		const shaderMaterial = new ShaderMaterial( {

			name: 'SphericalGaussianBlur',

			defines: {
				'n': MAX_SAMPLES,
				'CUBEUV_TEXEL_WIDTH': 1.0 / width,
				'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
				'CUBEUV_MAX_MIP': `${lodMax}.0`,
			},

			uniforms: {
				'envMap': { value: null },
				'samples': { value: 1 },
				'weights': { value: weights },
				'latitudinal': { value: false },
				'dTheta': { value: 0 },
				'mipInt': { value: 0 },
				'poleAxis': { value: poleAxis }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

		return shaderMaterial;

	}

	function _getEquirectMaterial() {

		return new ShaderMaterial( {

			name: 'EquirectangularToCubeUV',

			uniforms: {
				'envMap': { value: null }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

	}

	function _getCubemapMaterial() {

		return new ShaderMaterial( {

			name: 'CubemapToCubeUV',

			uniforms: {
				'envMap': { value: null },
				'flipEnvMap': { value: - 1 }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

	}

	function _getCommonVertexShader() {

		return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

	}

	function WebGLCubeUVMaps( renderer ) {

		let cubeUVmaps = new WeakMap();

		let pmremGenerator = null;

		function get( texture ) {

			if ( texture && texture.isTexture ) {

				const mapping = texture.mapping;

				const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
				const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

				// equirect/cube map to cubeUV conversion

				if ( isEquirectMap || isCubeMap ) {

					if ( texture.isRenderTargetTexture && texture.needsPMREMUpdate === true ) {

						texture.needsPMREMUpdate = false;

						let renderTarget = cubeUVmaps.get( texture );

						if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

						renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
						cubeUVmaps.set( texture, renderTarget );

						return renderTarget.texture;

					} else {

						if ( cubeUVmaps.has( texture ) ) {

							return cubeUVmaps.get( texture ).texture;

						} else {

							const image = texture.image;

							if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

								if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

								const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
								cubeUVmaps.set( texture, renderTarget );

								texture.addEventListener( 'dispose', onTextureDispose );

								return renderTarget.texture;

							} else {

								// image not yet ready. try the conversion next frame

								return null;

							}

						}

					}

				}

			}

			return texture;

		}

		function isCubeTextureComplete( image ) {

			let count = 0;
			const length = 6;

			for ( let i = 0; i < length; i ++ ) {

				if ( image[ i ] !== undefined ) count ++;

			}

			return count === length;


		}

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			const cubemapUV = cubeUVmaps.get( texture );

			if ( cubemapUV !== undefined ) {

				cubeUVmaps.delete( texture );
				cubemapUV.dispose();

			}

		}

		function dispose() {

			cubeUVmaps = new WeakMap();

			if ( pmremGenerator !== null ) {

				pmremGenerator.dispose();
				pmremGenerator = null;

			}

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function WebGLExtensions( gl ) {

		const extensions = {};

		function getExtension( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			let extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			extensions[ name ] = extension;

			return extension;

		}

		return {

			has: function ( name ) {

				return getExtension( name ) !== null;

			},

			init: function ( capabilities ) {

				if ( capabilities.isWebGL2 ) {

					getExtension( 'EXT_color_buffer_float' );

				} else {

					getExtension( 'WEBGL_depth_texture' );
					getExtension( 'OES_texture_float' );
					getExtension( 'OES_texture_half_float' );
					getExtension( 'OES_texture_half_float_linear' );
					getExtension( 'OES_standard_derivatives' );
					getExtension( 'OES_element_index_uint' );
					getExtension( 'OES_vertex_array_object' );
					getExtension( 'ANGLE_instanced_arrays' );

				}

				getExtension( 'OES_texture_float_linear' );
				getExtension( 'EXT_color_buffer_half_float' );
				getExtension( 'WEBGL_multisampled_render_to_texture' );

			},

			get: function ( name ) {

				const extension = getExtension( name );

				if ( extension === null ) {

					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

				}

				return extension;

			}

		};

	}

	function WebGLGeometries( gl, attributes, info, bindingStates ) {

		const geometries = {};
		const wireframeAttributes = new WeakMap();

		function onGeometryDispose( event ) {

			const geometry = event.target;

			if ( geometry.index !== null ) {

				attributes.remove( geometry.index );

			}

			for ( const name in geometry.attributes ) {

				attributes.remove( geometry.attributes[ name ] );

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			const attribute = wireframeAttributes.get( geometry );

			if ( attribute ) {

				attributes.remove( attribute );
				wireframeAttributes.delete( geometry );

			}

			bindingStates.releaseStatesOfGeometry( geometry );

			if ( geometry.isInstancedBufferGeometry === true ) {

				delete geometry._maxInstanceCount;

			}

			//

			info.memory.geometries --;

		}

		function get( object, geometry ) {

			if ( geometries[ geometry.id ] === true ) return geometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			geometries[ geometry.id ] = true;

			info.memory.geometries ++;

			return geometry;

		}

		function update( geometry ) {

			const geometryAttributes = geometry.attributes;

			// Updating index buffer in VAO now. See WebGLBindingStates.

			for ( const name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], 34962 );

			}

			// morph targets

			const morphAttributes = geometry.morphAttributes;

			for ( const name in morphAttributes ) {

				const array = morphAttributes[ name ];

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], 34962 );

				}

			}

		}

		function updateWireframeAttribute( geometry ) {

			const indices = [];

			const geometryIndex = geometry.index;
			const geometryPosition = geometry.attributes.position;
			let version = 0;

			if ( geometryIndex !== null ) {

				const array = geometryIndex.array;
				version = geometryIndex.version;

				for ( let i = 0, l = array.length; i < l; i += 3 ) {

					const a = array[ i + 0 ];
					const b = array[ i + 1 ];
					const c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else {

				const array = geometryPosition.array;
				version = geometryPosition.version;

				for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					const a = i + 0;
					const b = i + 1;
					const c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
			attribute.version = version;

			// Updating index buffer in VAO now. See WebGLBindingStates

			//

			const previousAttribute = wireframeAttributes.get( geometry );

			if ( previousAttribute ) attributes.remove( previousAttribute );

			//

			wireframeAttributes.set( geometry, attribute );

		}

		function getWireframeAttribute( geometry ) {

			const currentAttribute = wireframeAttributes.get( geometry );

			if ( currentAttribute ) {

				const geometryIndex = geometry.index;

				if ( geometryIndex !== null ) {

					// if the attribute is obsolete, create a new one

					if ( currentAttribute.version < geometryIndex.version ) {

						updateWireframeAttribute( geometry );

					}

				}

			} else {

				updateWireframeAttribute( geometry );

			}

			return wireframeAttributes.get( geometry );

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		let mode;

		function setMode( value ) {

			mode = value;

		}

		let type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			let extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawElementsInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawElementsInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLInfo( gl ) {

		const memory = {
			geometries: 0,
			textures: 0
		};

		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update( count, mode, instanceCount ) {

			render.calls ++;

			switch ( mode ) {

				case 4:
					render.triangles += instanceCount * ( count / 3 );
					break;

				case 1:
					render.lines += instanceCount * ( count / 2 );
					break;

				case 3:
					render.lines += instanceCount * ( count - 1 );
					break;

				case 2:
					render.lines += instanceCount * count;
					break;

				case 0:
					render.points += instanceCount * count;
					break;

				default:
					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
					break;

			}

		}

		function reset() {

			render.frame ++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};

	}

	function numericalSort( a, b ) {

		return a[ 0 ] - b[ 0 ];

	}

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function denormalize( morph, attribute ) {

		let denominator = 1;
		const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;

		if ( array instanceof Int8Array ) denominator = 127;
		else if ( array instanceof Int16Array ) denominator = 32767;
		else if ( array instanceof Int32Array ) denominator = 2147483647;
		else console.error( 'THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array );

		morph.divideScalar( denominator );

	}

	function WebGLMorphtargets( gl, capabilities, textures ) {

		const influencesList = {};
		const morphInfluences = new Float32Array( 8 );
		const morphTextures = new WeakMap();
		const morph = new Vector4();

		const workInfluences = [];

		for ( let i = 0; i < 8; i ++ ) {

			workInfluences[ i ] = [ i, 0 ];

		}

		function update( object, geometry, material, program ) {

			const objectInfluences = object.morphTargetInfluences;

			if ( capabilities.isWebGL2 === true ) {

				// instead of using attributes, the WebGL 2 code path encodes morph targets
				// into an array of data textures. Each layer represents a single morph target.

				const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
				const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

				let entry = morphTextures.get( geometry );

				if ( entry === undefined || entry.count !== morphTargetsCount ) {

					if ( entry !== undefined ) entry.texture.dispose();

					const hasMorphPosition = geometry.morphAttributes.position !== undefined;
					const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
					const hasMorphColors = geometry.morphAttributes.color !== undefined;

					const morphTargets = geometry.morphAttributes.position || [];
					const morphNormals = geometry.morphAttributes.normal || [];
					const morphColors = geometry.morphAttributes.color || [];

					let vertexDataCount = 0;

					if ( hasMorphPosition === true ) vertexDataCount = 1;
					if ( hasMorphNormals === true ) vertexDataCount = 2;
					if ( hasMorphColors === true ) vertexDataCount = 3;

					let width = geometry.attributes.position.count * vertexDataCount;
					let height = 1;

					if ( width > capabilities.maxTextureSize ) {

						height = Math.ceil( width / capabilities.maxTextureSize );
						width = capabilities.maxTextureSize;

					}

					const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

					const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
					texture.type = FloatType;
					texture.needsUpdate = true;

					// fill buffer

					const vertexDataStride = vertexDataCount * 4;

					for ( let i = 0; i < morphTargetsCount; i ++ ) {

						const morphTarget = morphTargets[ i ];
						const morphNormal = morphNormals[ i ];
						const morphColor = morphColors[ i ];

						const offset = width * height * 4 * i;

						for ( let j = 0; j < morphTarget.count; j ++ ) {

							const stride = j * vertexDataStride;

							if ( hasMorphPosition === true ) {

								morph.fromBufferAttribute( morphTarget, j );

								if ( morphTarget.normalized === true ) denormalize( morph, morphTarget );

								buffer[ offset + stride + 0 ] = morph.x;
								buffer[ offset + stride + 1 ] = morph.y;
								buffer[ offset + stride + 2 ] = morph.z;
								buffer[ offset + stride + 3 ] = 0;

							}

							if ( hasMorphNormals === true ) {

								morph.fromBufferAttribute( morphNormal, j );

								if ( morphNormal.normalized === true ) denormalize( morph, morphNormal );

								buffer[ offset + stride + 4 ] = morph.x;
								buffer[ offset + stride + 5 ] = morph.y;
								buffer[ offset + stride + 6 ] = morph.z;
								buffer[ offset + stride + 7 ] = 0;

							}

							if ( hasMorphColors === true ) {

								morph.fromBufferAttribute( morphColor, j );

								if ( morphColor.normalized === true ) denormalize( morph, morphColor );

								buffer[ offset + stride + 8 ] = morph.x;
								buffer[ offset + stride + 9 ] = morph.y;
								buffer[ offset + stride + 10 ] = morph.z;
								buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

							}

						}

					}

					entry = {
						count: morphTargetsCount,
						texture: texture,
						size: new Vector2( width, height )
					};

					morphTextures.set( geometry, entry );

					function disposeTexture() {

						texture.dispose();

						morphTextures.delete( geometry );

						geometry.removeEventListener( 'dispose', disposeTexture );

					}

					geometry.addEventListener( 'dispose', disposeTexture );

				}

				//

				let morphInfluencesSum = 0;

				for ( let i = 0; i < objectInfluences.length; i ++ ) {

					morphInfluencesSum += objectInfluences[ i ];

				}

				const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

				program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
				program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

				program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
				program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );


			} else {

				// When object doesn't have morph target influences defined, we treat it as a 0-length array
				// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

				const length = objectInfluences === undefined ? 0 : objectInfluences.length;

				let influences = influencesList[ geometry.id ];

				if ( influences === undefined || influences.length !== length ) {

					// initialise list

					influences = [];

					for ( let i = 0; i < length; i ++ ) {

						influences[ i ] = [ i, 0 ];

					}

					influencesList[ geometry.id ] = influences;

				}

				// Collect influences

				for ( let i = 0; i < length; i ++ ) {

					const influence = influences[ i ];

					influence[ 0 ] = i;
					influence[ 1 ] = objectInfluences[ i ];

				}

				influences.sort( absNumericalSort );

				for ( let i = 0; i < 8; i ++ ) {

					if ( i < length && influences[ i ][ 1 ] ) {

						workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
						workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

					} else {

						workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
						workInfluences[ i ][ 1 ] = 0;

					}

				}

				workInfluences.sort( numericalSort );

				const morphTargets = geometry.morphAttributes.position;
				const morphNormals = geometry.morphAttributes.normal;

				let morphInfluencesSum = 0;

				for ( let i = 0; i < 8; i ++ ) {

					const influence = workInfluences[ i ];
					const index = influence[ 0 ];
					const value = influence[ 1 ];

					if ( index !== Number.MAX_SAFE_INTEGER && value ) {

						if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

							geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

						}

						if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

							geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

						}

						morphInfluences[ i ] = value;
						morphInfluencesSum += value;

					} else {

						if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

							geometry.deleteAttribute( 'morphTarget' + i );

						}

						if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

							geometry.deleteAttribute( 'morphNormal' + i );

						}

						morphInfluences[ i ] = 0;

					}

				}

				// GLSL shader uses formula baseinfluence * base + sum(target * influence)
				// This allows us to switch between absolute morphs and relative morphs without changing shader code
				// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
				const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

				program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
				program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

			}

		}

		return {

			update: update

		};

	}

	function WebGLObjects( gl, geometries, attributes, info ) {

		let updateMap = new WeakMap();

		function update( object ) {

			const frame = info.render.frame;

			const geometry = object.geometry;
			const buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateMap.get( buffergeometry ) !== frame ) {

				geometries.update( buffergeometry );

				updateMap.set( buffergeometry, frame );

			}

			if ( object.isInstancedMesh ) {

				if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

					object.addEventListener( 'dispose', onInstancedMeshDispose );

				}

				attributes.update( object.instanceMatrix, 34962 );

				if ( object.instanceColor !== null ) {

					attributes.update( object.instanceColor, 34962 );

				}

			}

			return buffergeometry;

		}

		function dispose() {

			updateMap = new WeakMap();

		}

		function onInstancedMeshDispose( event ) {

			const instancedMesh = event.target;

			instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

			attributes.remove( instancedMesh.instanceMatrix );

			if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	const emptyTexture = new Texture();
	const emptyArrayTexture = new DataArrayTexture();
	const empty3dTexture = new Data3DTexture();
	const emptyCubeTexture = new CubeTexture();

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32 = [];
	const arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	const mat4array = new Float32Array( 16 );
	const mat3array = new Float32Array( 9 );
	const mat2array = new Float32Array( 4 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		const firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize;
		let r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	function arraysEqual( a, b ) {

		if ( a.length !== b.length ) return false;

		for ( let i = 0, l = a.length; i < l; i ++ ) {

			if ( a[ i ] !== b[ i ] ) return false;

		}

		return true;

	}

	function copyArray( a, b ) {

		for ( let i = 0, l = b.length; i < l; i ++ ) {

			a[ i ] = b[ i ];

		}

	}

	// Texture unit allocation

	function allocTexUnits( textures, n ) {

		let r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( let i = 0; i !== n; ++ i ) {

			r[ i ] = textures.allocateTextureUnit();

		}

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValueV1f( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1f( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValueV2f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2f( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3f( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else if ( v.r !== undefined ) {

			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

				gl.uniform3f( this.addr, v.r, v.g, v.b );

				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single matrix (from flat array or THREE.MatrixN)

	function setValueM2( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix2fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat2array.set( elements );

			gl.uniformMatrix2fv( this.addr, false, mat2array );

			copyArray( cache, elements );

		}

	}

	function setValueM3( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix3fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat3array.set( elements );

			gl.uniformMatrix3fv( this.addr, false, mat3array );

			copyArray( cache, elements );

		}

	}

	function setValueM4( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix4fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat4array.set( elements );

			gl.uniformMatrix4fv( this.addr, false, mat4array );

			copyArray( cache, elements );

		}

	}

	// Single integer / boolean

	function setValueV1i( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1i( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single integer / boolean vector (from flat array)

	function setValueV2i( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV3i( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV4i( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

	// Single unsigned integer

	function setValueV1ui( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1ui( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single unsigned integer vector (from flat array)

	function setValueV2ui( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2uiv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV3ui( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3uiv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV4ui( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4uiv( this.addr, v );

		copyArray( cache, v );

	}


	// Single texture (2D / Cube)

	function setValueT1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2D( v || emptyTexture, unit );

	}

	function setValueT3D1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture3D( v || empty3dTexture, unit );

	}

	function setValueT6( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTextureCube( v || emptyCubeTexture, unit );

	}

	function setValueT2DArray1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2DArray( v || emptyArrayTexture, unit );

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1f; // FLOAT
			case 0x8b50: return setValueV2f; // _VEC2
			case 0x8b51: return setValueV3f; // _VEC3
			case 0x8b52: return setValueV4f; // _VEC4

			case 0x8b5a: return setValueM2; // _MAT2
			case 0x8b5b: return setValueM3; // _MAT3
			case 0x8b5c: return setValueM4; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

			case 0x1405: return setValueV1ui; // UINT
			case 0x8dc6: return setValueV2ui; // _VEC2
			case 0x8dc7: return setValueV3ui; // _VEC3
			case 0x8dc8: return setValueV4ui; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;

		}

	}


	// Array of scalars

	function setValueV1fArray( gl, v ) {

		gl.uniform1fv( this.addr, v );

	}

	// Array of vectors (from flat array or array of THREE.VectorN)

	function setValueV2fArray( gl, v ) {

		const data = flatten( v, this.size, 2 );

		gl.uniform2fv( this.addr, data );

	}

	function setValueV3fArray( gl, v ) {

		const data = flatten( v, this.size, 3 );

		gl.uniform3fv( this.addr, data );

	}

	function setValueV4fArray( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniform4fv( this.addr, data );

	}

	// Array of matrices (from flat array or array of THREE.MatrixN)

	function setValueM2Array( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniformMatrix2fv( this.addr, false, data );

	}

	function setValueM3Array( gl, v ) {

		const data = flatten( v, this.size, 9 );

		gl.uniformMatrix3fv( this.addr, false, data );

	}

	function setValueM4Array( gl, v ) {

		const data = flatten( v, this.size, 16 );

		gl.uniformMatrix4fv( this.addr, false, data );

	}

	// Array of integer / boolean

	function setValueV1iArray( gl, v ) {

		gl.uniform1iv( this.addr, v );

	}

	// Array of integer / boolean vectors (from flat array)

	function setValueV2iArray( gl, v ) {

		gl.uniform2iv( this.addr, v );

	}

	function setValueV3iArray( gl, v ) {

		gl.uniform3iv( this.addr, v );

	}

	function setValueV4iArray( gl, v ) {

		gl.uniform4iv( this.addr, v );

	}

	// Array of unsigned integer

	function setValueV1uiArray( gl, v ) {

		gl.uniform1uiv( this.addr, v );

	}

	// Array of unsigned integer vectors (from flat array)

	function setValueV2uiArray( gl, v ) {

		gl.uniform2uiv( this.addr, v );

	}

	function setValueV3uiArray( gl, v ) {

		gl.uniform3uiv( this.addr, v );

	}

	function setValueV4uiArray( gl, v ) {

		gl.uniform4uiv( this.addr, v );

	}


	// Array of textures (2D / 3D / Cube / 2DArray)

	function setValueT1Array( gl, v, textures ) {

		const n = v.length;

		const units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT3DArray( gl, v, textures ) {

		const n = v.length;

		const units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

		}

	}

	function setValueT6Array( gl, v, textures ) {

		const n = v.length;

		const units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	function setValueT2DArrayArray( gl, v, textures ) {

		const n = v.length;

		const units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

		}

	}


	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1fArray; // FLOAT
			case 0x8b50: return setValueV2fArray; // _VEC2
			case 0x8b51: return setValueV3fArray; // _VEC3
			case 0x8b52: return setValueV4fArray; // _VEC4

			case 0x8b5a: return setValueM2Array; // _MAT2
			case 0x8b5b: return setValueM3Array; // _MAT3
			case 0x8b5c: return setValueM4Array; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

			case 0x1405: return setValueV1uiArray; // UINT
			case 0x8dc6: return setValueV2uiArray; // _VEC2
			case 0x8dc7: return setValueV3uiArray; // _VEC3
			case 0x8dc8: return setValueV4uiArray; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3DArray;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6Array;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArrayArray;

		}

	}

	// --- Uniform Classes ---

	function SingleUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	function PureArrayUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	PureArrayUniform.prototype.updateCache = function ( data ) {

		const cache = this.cache;

		if ( data instanceof Float32Array && cache.length !== data.length ) {

			this.cache = new Float32Array( data.length );

		}

		copyArray( cache, data );

	};

	function StructuredUniform( id ) {

		this.id = id;

		this.seq = [];
		this.map = {};

	}

	StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

		const seq = this.seq;

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			u.setValue( gl, value[ u.id ], textures );

		}

	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	const RePathPart = /(\w+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		const path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while ( true ) {

			const match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex;

			let id = match[ 1 ];
			const idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				const map = container.map;
				let next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	function WebGLUniforms( gl, program ) {

		this.seq = [];
		this.map = {};

		const n = gl.getProgramParameter( program, 35718 );

		for ( let i = 0; i < n; ++ i ) {

			const info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

		const u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, textures );

	};

	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

		const v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	};


	// Static interface

	WebGLUniforms.upload = function ( gl, seq, values, textures ) {

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, textures );

			}

		}

	};

	WebGLUniforms.seqWithValue = function ( seq, values ) {

		const r = [];

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	};

	function WebGLShader( gl, type, string ) {

		const shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		return shader;

	}

	let programIdCount = 0;

	function handleSource( string, errorLine ) {

		const lines = string.split( '\n' );
		const lines2 = [];

		const from = Math.max( errorLine - 6, 0 );
		const to = Math.min( errorLine + 6, lines.length );

		for ( let i = from; i < to; i ++ ) {

			lines2.push( ( i + 1 ) + ': ' + lines[ i ] );

		}

		return lines2.join( '\n' );

	}

	function getEncodingComponents( encoding ) {

		switch ( encoding ) {

			case LinearEncoding:
				return [ 'Linear', '( value )' ];
			case sRGBEncoding:
				return [ 'sRGB', '( value )' ];
			default:
				console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
				return [ 'Linear', '( value )' ];

		}

	}

	function getShaderErrors( gl, shader, type ) {

		const status = gl.getShaderParameter( shader, 35713 );
		const errors = gl.getShaderInfoLog( shader ).trim();

		if ( status && errors === '' ) return '';

		const errorLine = parseInt( /ERROR: 0:(\d+)/.exec( errors )[ 1 ] );

		// --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

	}

	function getTexelEncodingFunction( functionName, encoding ) {

		const components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		let toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
				toneMappingName = 'Linear';

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	function generateExtensions( parameters ) {

		const chunks = [
			( parameters.extensionDerivatives || !! parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
			( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		const chunks = [];

		for ( const name in defines ) {

			const value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		const attributes = {};

		const n = gl.getProgramParameter( program, 35721 );

		for ( let i = 0; i < n; i ++ ) {

			const info = gl.getActiveAttrib( program, i );
			const name = info.name;

			let locationSize = 1;
			if ( info.type === 35674 ) locationSize = 2;
			if ( info.type === 35675 ) locationSize = 3;
			if ( info.type === 35676 ) locationSize = 4;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = {
				type: info.type,
				location: gl.getAttribLocation( program, name ),
				locationSize: locationSize
			};

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
			.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
			.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
			.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	// Resolve Includes

	const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes( string ) {

		return string.replace( includePattern, includeReplacer );

	}

	function includeReplacer( match, include ) {

		const string = ShaderChunk[ include ];

		if ( string === undefined ) {

			throw new Error( 'Can not resolve #include <' + include + '>' );

		}

		return resolveIncludes( string );

	}

	// Unroll Loops

	const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops( string ) {

		return string
			.replace( unrollLoopPattern, loopReplacer )
			.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

	}

	function deprecatedLoopReplacer( match, start, end, snippet ) {

		console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
		return loopReplacer( match, start, end, snippet );

	}

	function loopReplacer( match, start, end, snippet ) {

		let string = '';

		for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

			string += snippet
				.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
				.replace( /UNROLLED_LOOP_INDEX/g, i );

		}

		return string;

	}

	//

	function generatePrecision( parameters ) {

		let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

		if ( parameters.precision === 'highp' ) {

			precisionstring += '\n#define HIGH_PRECISION';

		} else if ( parameters.precision === 'mediump' ) {

			precisionstring += '\n#define MEDIUM_PRECISION';

		} else if ( parameters.precision === 'lowp' ) {

			precisionstring += '\n#define LOW_PRECISION';

		}

		return precisionstring;

	}

	function generateShadowMapTypeDefine( parameters ) {

		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		} else if ( parameters.shadowMapType === VSMShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

		}

		return shadowMapTypeDefine;

	}

	function generateEnvMapTypeDefine( parameters ) {

		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

			}

		}

		return envMapTypeDefine;

	}

	function generateEnvMapModeDefine( parameters ) {

		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeRefractionMapping:

					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

		}

		return envMapModeDefine;

	}

	function generateEnvMapBlendingDefine( parameters ) {

		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if ( parameters.envMap ) {

			switch ( parameters.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		return envMapBlendingDefine;

	}

	function generateCubeUVSize( parameters ) {

		const imageHeight = parameters.envMapCubeUVHeight;

		if ( imageHeight === null ) return null;

		const maxMip = Math.log2( imageHeight / 32 + 1 ) + 3;

		const texelHeight = 1.0 / imageHeight;

		const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

		return { texelWidth, texelHeight, maxMip };

	}

	function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

		// TODO Send this event to Three.js DevTools
		// console.log( 'WebGLProgram', cacheKey );

		const gl = renderer.getContext();

		const defines = parameters.defines;

		let vertexShader = parameters.vertexShader;
		let fragmentShader = parameters.fragmentShader;

		const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
		const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
		const envMapModeDefine = generateEnvMapModeDefine( parameters );
		const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
		const envMapCubeUVSize = generateCubeUVSize( parameters );

		const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

		const customDefines = generateDefines( defines );

		const program = gl.createProgram();

		let prefixVertex, prefixFragment;
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if ( parameters.isRawShaderMaterial ) {

			prefixVertex = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,
				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				generatePrecision( parameters ),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.instancing ? '#define USE_INSTANCING' : '',
				parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define MAX_BONES ' + parameters.maxBones,
				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',

				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
				parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',

				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
				parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				( parameters.morphColors && parameters.isWebGL2 ) ? '#define USE_MORPHCOLORS' : '',
				( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE' : '',
				( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
				( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				'#ifdef USE_INSTANCING',

				'	attribute mat4 instanceMatrix;',

				'#endif',

				'#ifdef USE_INSTANCING_COLOR',

				'	attribute vec3 instanceColor;',

				'#endif',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_TANGENT',

				'	attribute vec4 tangent;',

				'#endif',

				'#if defined( USE_COLOR_ALPHA )',

				'	attribute vec4 color;',

				'#elif defined( USE_COLOR )',

				'	attribute vec3 color;',

				'#endif',

				'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				generatePrecision( parameters ),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
				envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
				envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

				parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
				parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.alphaTest ? '#define USE_ALPHATEST' : '',

				parameters.sheen ? '#define USE_SHEEN' : '',
				parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
				parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',
				parameters.opaque ? '#define OPAQUE' : '',

				ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
				getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

				parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = resolveIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = resolveIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

			// GLSL 3.0 conversion for built-in materials and ShaderMaterial

			versionString = '#version 300 es\n';

			prefixVertex = [
				'precision mediump sampler2DArray;',
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;

			prefixFragment = [
				'#define varying in',
				( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
				( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;

		}

		const vertexGlsl = versionString + prefixVertex + vertexShader;
		const fragmentGlsl = versionString + prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
		const glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( parameters.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		// check for link errors
		if ( renderer.debug.checkShaderErrors ) {

			const programLog = gl.getProgramInfoLog( program ).trim();
			const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
			const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

			let runnable = true;
			let haveDiagnostics = true;

			if ( gl.getProgramParameter( program, 35714 ) === false ) {

				runnable = false;

				const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
				const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

				console.error(
					'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
					'VALIDATE_STATUS ' + gl.getProgramParameter( program, 35715 ) + '\n\n' +
					'Program Info Log: ' + programLog + '\n' +
					vertexErrors + '\n' +
					fragmentErrors
				);

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

		}

		// Clean up

		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		let cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		let cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			bindingStates.releaseStatesOfProgram( this );

			gl.deleteProgram( program );
			this.program = undefined;

		};

		//

		this.name = parameters.shaderName;
		this.id = programIdCount ++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	let _id = 0;

	class WebGLShaderCache {

		constructor() {

			this.shaderCache = new Map();
			this.materialCache = new Map();

		}

		update( material ) {

			const vertexShader = material.vertexShader;
			const fragmentShader = material.fragmentShader;

			const vertexShaderStage = this._getShaderStage( vertexShader );
			const fragmentShaderStage = this._getShaderStage( fragmentShader );

			const materialShaders = this._getShaderCacheForMaterial( material );

			if ( materialShaders.has( vertexShaderStage ) === false ) {

				materialShaders.add( vertexShaderStage );
				vertexShaderStage.usedTimes ++;

			}

			if ( materialShaders.has( fragmentShaderStage ) === false ) {

				materialShaders.add( fragmentShaderStage );
				fragmentShaderStage.usedTimes ++;

			}

			return this;

		}

		remove( material ) {

			const materialShaders = this.materialCache.get( material );

			for ( const shaderStage of materialShaders ) {

				shaderStage.usedTimes --;

				if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

			}

			this.materialCache.delete( material );

			return this;

		}

		getVertexShaderID( material ) {

			return this._getShaderStage( material.vertexShader ).id;

		}

		getFragmentShaderID( material ) {

			return this._getShaderStage( material.fragmentShader ).id;

		}

		dispose() {

			this.shaderCache.clear();
			this.materialCache.clear();

		}

		_getShaderCacheForMaterial( material ) {

			const cache = this.materialCache;

			if ( cache.has( material ) === false ) {

				cache.set( material, new Set() );

			}

			return cache.get( material );

		}

		_getShaderStage( code ) {

			const cache = this.shaderCache;

			if ( cache.has( code ) === false ) {

				const stage = new WebGLShaderStage( code );
				cache.set( code, stage );

			}

			return cache.get( code );

		}

	}

	class WebGLShaderStage {

		constructor( code ) {

			this.id = _id ++;

			this.code = code;
			this.usedTimes = 0;

		}

	}

	function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

		const _programLayers = new Layers();
		const _customShaders = new WebGLShaderCache();
		const programs = [];

		const isWebGL2 = capabilities.isWebGL2;
		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		const floatVertexTextures = capabilities.floatVertexTextures;
		const maxVertexUniforms = capabilities.maxVertexUniforms;
		const vertexTextures = capabilities.vertexTextures;
		let precision = capabilities.precision;

		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};

		function getMaxBones( object ) {

			const skeleton = object.skeleton;
			const bones = skeleton.bones;

			if ( floatVertexTextures ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				const nVertexUniforms = maxVertexUniforms;
				const nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				const maxBones = Math.min( nVertexMatrices, bones.length );

				if ( maxBones < bones.length ) {

					console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
					return 0;

				}

				return maxBones;

			}

		}

		function getParameters( material, lights, shadows, scene, object ) {

			const fog = scene.fog;
			const geometry = object.geometry;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;

			const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
			const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

			const shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			const maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			//

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			let morphTextureStride = 0;

			if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
			if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
			if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

			//

			let vertexShader, fragmentShader;
			let customVertexShaderID, customFragmentShaderID;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];

				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;

			} else {

				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;

				_customShaders.update( material );

				customVertexShaderID = _customShaders.getVertexShaderID( material );
				customFragmentShaderID = _customShaders.getFragmentShaderID( material );

			}

			const currentRenderTarget = renderer.getRenderTarget();

			const useAlphaTest = material.alphaTest > 0;
			const useClearcoat = material.clearcoat > 0;

			const parameters = {

				isWebGL2: isWebGL2,

				shaderID: shaderID,
				shaderName: material.type,

				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,

				customVertexShaderID: customVertexShaderID,
				customFragmentShaderID: customFragmentShaderID,

				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,

				precision: precision,

				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

				supportsVertexTextures: vertexTextures,
				outputEncoding: ( currentRenderTarget === null ) ? renderer.outputEncoding : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding ),
				map: !! material.map,
				matcap: !! material.matcap,
				envMap: !! envMap,
				envMapMode: envMap && envMap.mapping,
				envMapCubeUVHeight: envMapCubeUVHeight,
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,

				decodeVideoTexture: !! material.map && ( material.map.isVideoTexture === true ) && ( material.map.encoding === sRGBEncoding ),

				clearcoat: useClearcoat,
				clearcoatMap: useClearcoat && !! material.clearcoatMap,
				clearcoatRoughnessMap: useClearcoat && !! material.clearcoatRoughnessMap,
				clearcoatNormalMap: useClearcoat && !! material.clearcoatNormalMap,

				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				specularIntensityMap: !! material.specularIntensityMap,
				specularColorMap: !! material.specularColorMap,

				opaque: material.transparent === false && material.blending === NormalBlending,

				alphaMap: !! material.alphaMap,
				alphaTest: useAlphaTest,

				gradientMap: !! material.gradientMap,

				sheen: material.sheen > 0,
				sheenColorMap: !! material.sheenColorMap,
				sheenRoughnessMap: !! material.sheenRoughnessMap,

				transmission: material.transmission > 0,
				transmissionMap: !! material.transmissionMap,
				thicknessMap: !! material.thicknessMap,

				combine: material.combine,

				vertexTangents: ( !! material.normalMap && !! geometry.attributes.tangent ),
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,
				vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || !! material.sheenColorMap || !! material.sheenRoughnessMap,
				uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || material.transmission > 0 || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || material.sheen > 0 || !! material.sheenColorMap || !! material.sheenRoughnessMap ) && !! material.displacementMap,

				fog: !! fog,
				useFog: material.fog,
				fogExp2: ( fog && fog.isFogExp2 ),

				flatShading: !! material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				skinning: object.isSkinnedMesh === true && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: floatVertexTextures,

				morphTargets: geometry.morphAttributes.position !== undefined,
				morphNormals: geometry.morphAttributes.normal !== undefined,
				morphColors: geometry.morphAttributes.color !== undefined,
				morphTargetsCount: morphTargetsCount,
				morphTextureStride: morphTextureStride,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,

				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

				index0AttributeName: material.index0AttributeName,

				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

				rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

				customProgramCacheKey: material.customProgramCacheKey()

			};

			return parameters;

		}

		function getProgramCacheKey( parameters ) {

			const array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( parameters.customVertexShaderID );
				array.push( parameters.customFragmentShaderID );

			}

			if ( parameters.defines !== undefined ) {

				for ( const name in parameters.defines ) {

					array.push( name );
					array.push( parameters.defines[ name ] );

				}

			}

			if ( parameters.isRawShaderMaterial === false ) {

				getProgramCacheKeyParameters( array, parameters );
				getProgramCacheKeyBooleans( array, parameters );
				array.push( renderer.outputEncoding );

			}

			array.push( parameters.customProgramCacheKey );

			return array.join();

		}

		function getProgramCacheKeyParameters( array, parameters ) {

			array.push( parameters.precision );
			array.push( parameters.outputEncoding );
			array.push( parameters.envMapMode );
			array.push( parameters.envMapCubeUVHeight );
			array.push( parameters.combine );
			array.push( parameters.vertexUvs );
			array.push( parameters.fogExp2 );
			array.push( parameters.sizeAttenuation );
			array.push( parameters.maxBones );
			array.push( parameters.morphTargetsCount );
			array.push( parameters.morphAttributeCount );
			array.push( parameters.numDirLights );
			array.push( parameters.numPointLights );
			array.push( parameters.numSpotLights );
			array.push( parameters.numHemiLights );
			array.push( parameters.numRectAreaLights );
			array.push( parameters.numDirLightShadows );
			array.push( parameters.numPointLightShadows );
			array.push( parameters.numSpotLightShadows );
			array.push( parameters.shadowMapType );
			array.push( parameters.toneMapping );
			array.push( parameters.numClippingPlanes );
			array.push( parameters.numClipIntersection );

		}

		function getProgramCacheKeyBooleans( array, parameters ) {

			_programLayers.disableAll();

			if ( parameters.isWebGL2 )
				_programLayers.enable( 0 );
			if ( parameters.supportsVertexTextures )
				_programLayers.enable( 1 );
			if ( parameters.instancing )
				_programLayers.enable( 2 );
			if ( parameters.instancingColor )
				_programLayers.enable( 3 );
			if ( parameters.map )
				_programLayers.enable( 4 );
			if ( parameters.matcap )
				_programLayers.enable( 5 );
			if ( parameters.envMap )
				_programLayers.enable( 6 );
			if ( parameters.lightMap )
				_programLayers.enable( 7 );
			if ( parameters.aoMap )
				_programLayers.enable( 8 );
			if ( parameters.emissiveMap )
				_programLayers.enable( 9 );
			if ( parameters.bumpMap )
				_programLayers.enable( 10 );
			if ( parameters.normalMap )
				_programLayers.enable( 11 );
			if ( parameters.objectSpaceNormalMap )
				_programLayers.enable( 12 );
			if ( parameters.tangentSpaceNormalMap )
				_programLayers.enable( 13 );
			if ( parameters.clearcoat )
				_programLayers.enable( 14 );
			if ( parameters.clearcoatMap )
				_programLayers.enable( 15 );
			if ( parameters.clearcoatRoughnessMap )
				_programLayers.enable( 16 );
			if ( parameters.clearcoatNormalMap )
				_programLayers.enable( 17 );
			if ( parameters.displacementMap )
				_programLayers.enable( 18 );
			if ( parameters.specularMap )
				_programLayers.enable( 19 );
			if ( parameters.roughnessMap )
				_programLayers.enable( 20 );
			if ( parameters.metalnessMap )
				_programLayers.enable( 21 );
			if ( parameters.gradientMap )
				_programLayers.enable( 22 );
			if ( parameters.alphaMap )
				_programLayers.enable( 23 );
			if ( parameters.alphaTest )
				_programLayers.enable( 24 );
			if ( parameters.vertexColors )
				_programLayers.enable( 25 );
			if ( parameters.vertexAlphas )
				_programLayers.enable( 26 );
			if ( parameters.vertexUvs )
				_programLayers.enable( 27 );
			if ( parameters.vertexTangents )
				_programLayers.enable( 28 );
			if ( parameters.uvsVertexOnly )
				_programLayers.enable( 29 );
			if ( parameters.fog )
				_programLayers.enable( 30 );

			array.push( _programLayers.mask );
			_programLayers.disableAll();

			if ( parameters.useFog )
				_programLayers.enable( 0 );
			if ( parameters.flatShading )
				_programLayers.enable( 1 );
			if ( parameters.logarithmicDepthBuffer )
				_programLayers.enable( 2 );
			if ( parameters.skinning )
				_programLayers.enable( 3 );
			if ( parameters.useVertexTexture )
				_programLayers.enable( 4 );
			if ( parameters.morphTargets )
				_programLayers.enable( 5 );
			if ( parameters.morphNormals )
				_programLayers.enable( 6 );
			if ( parameters.morphColors )
				_programLayers.enable( 7 );
			if ( parameters.premultipliedAlpha )
				_programLayers.enable( 8 );
			if ( parameters.shadowMapEnabled )
				_programLayers.enable( 9 );
			if ( parameters.physicallyCorrectLights )
				_programLayers.enable( 10 );
			if ( parameters.doubleSided )
				_programLayers.enable( 11 );
			if ( parameters.flipSided )
				_programLayers.enable( 12 );
			if ( parameters.depthPacking )
				_programLayers.enable( 13 );
			if ( parameters.dithering )
				_programLayers.enable( 14 );
			if ( parameters.specularIntensityMap )
				_programLayers.enable( 15 );
			if ( parameters.specularColorMap )
				_programLayers.enable( 16 );
			if ( parameters.transmission )
				_programLayers.enable( 17 );
			if ( parameters.transmissionMap )
				_programLayers.enable( 18 );
			if ( parameters.thicknessMap )
				_programLayers.enable( 19 );
			if ( parameters.sheen )
				_programLayers.enable( 20 );
			if ( parameters.sheenColorMap )
				_programLayers.enable( 21 );
			if ( parameters.sheenRoughnessMap )
				_programLayers.enable( 22 );
			if ( parameters.decodeVideoTexture )
				_programLayers.enable( 23 );
			if ( parameters.opaque )
				_programLayers.enable( 24 );

			array.push( _programLayers.mask );

		}

		function getUniforms( material ) {

			const shaderID = shaderIDs[ material.type ];
			let uniforms;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];
				uniforms = UniformsUtils.clone( shader.uniforms );

			} else {

				uniforms = material.uniforms;

			}

			return uniforms;

		}

		function acquireProgram( parameters, cacheKey ) {

			let program;

			// Check if code has been already compiled
			for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

				const preexistingProgram = programs[ p ];

				if ( preexistingProgram.cacheKey === cacheKey ) {

					program = preexistingProgram;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
				programs.push( program );

			}

			return program;

		}

		function releaseProgram( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				const i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		}

		function releaseShaderCache( material ) {

			_customShaders.remove( material );

		}

		function dispose() {

			_customShaders.dispose();

		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			releaseShaderCache: releaseShaderCache,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs,
			dispose: dispose
		};

	}

	function WebGLProperties() {

		let properties = new WeakMap();

		function get( object ) {

			let map = properties.get( object );

			if ( map === undefined ) {

				map = {};
				properties.set( object, map );

			}

			return map;

		}

		function remove( object ) {

			properties.delete( object );

		}

		function update( object, key, value ) {

			properties.get( object )[ key ] = value;

		}

		function dispose() {

			properties = new WeakMap();

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	function painterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}


	function WebGLRenderList() {

		const renderItems = [];
		let renderItemsIndex = 0;

		const opaque = [];
		const transmissive = [];
		const transparent = [];

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transmissive.length = 0;
			transparent.length = 0;

		}

		function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

			let renderItem = renderItems[ renderItemsIndex ];

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			renderItemsIndex ++;

			return renderItem;

		}

		function push( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			if ( material.transmission > 0.0 ) {

				transmissive.push( renderItem );

			} else if ( material.transparent === true ) {

				transparent.push( renderItem );

			} else {

				opaque.push( renderItem );

			}

		}

		function unshift( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			if ( material.transmission > 0.0 ) {

				transmissive.unshift( renderItem );

			} else if ( material.transparent === true ) {

				transparent.unshift( renderItem );

			} else {

				opaque.unshift( renderItem );

			}

		}

		function sort( customOpaqueSort, customTransparentSort ) {

			if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
			if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
			if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

		}

		function finish() {

			// Clear references from inactive renderItems in the list

			for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

				const renderItem = renderItems[ i ];

				if ( renderItem.id === null ) break;

				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.group = null;

			}

		}

		return {

			opaque: opaque,
			transmissive: transmissive,
			transparent: transparent,

			init: init,
			push: push,
			unshift: unshift,
			finish: finish,

			sort: sort
		};

	}

	function WebGLRenderLists() {

		let lists = new WeakMap();

		function get( scene, renderCallDepth ) {

			let list;

			if ( lists.has( scene ) === false ) {

				list = new WebGLRenderList();
				lists.set( scene, [ list ] );

			} else {

				if ( renderCallDepth >= lists.get( scene ).length ) {

					list = new WebGLRenderList();
					lists.get( scene ).push( list );

				} else {

					list = lists.get( scene )[ renderCallDepth ];

				}

			}

			return list;

		}

		function dispose() {

			lists = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function UniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	function ShadowUniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					// TODO (abelnation): set RectAreaLight shadow uniforms

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}



	let nextVersion = 0;

	function shadowCastingLightsFirst( lightA, lightB ) {

		return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

	}

	function WebGLLights( extensions, capabilities ) {

		const cache = new UniformsCache();

		const shadowCache = ShadowUniformsCache();

		const state = {

			version: 0,

			hash: {
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,

				numDirectionalShadows: - 1,
				numPointShadows: - 1,
				numSpotShadows: - 1
			},

			ambient: [ 0, 0, 0 ],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []

		};

		for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

		const vector3 = new Vector3();
		const matrix4 = new Matrix4();
		const matrix42 = new Matrix4();

		function setup( lights, physicallyCorrectLights ) {

			let r = 0, g = 0, b = 0;

			for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			let numDirectionalShadows = 0;
			let numPointShadows = 0;
			let numSpotShadows = 0;

			lights.sort( shadowCastingLightsFirst );

			// artist-friendly light intensity scaling factor
			const scaleFactor = ( physicallyCorrectLights !== true ) ? Math.PI : 1;

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				const color = light.color;
				const intensity = light.intensity;
				const distance = light.distance;

				const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity * scaleFactor;
					g += color.g * intensity * scaleFactor;
					b += color.b * intensity * scaleFactor;

				} else if ( light.isLightProbe ) {

					for ( let j = 0; j < 9; j ++ ) {

						state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

					}

				} else if ( light.isDirectionalLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.directionalShadow[ directionalLength ] = shadowUniforms;
						state.directionalShadowMap[ directionalLength ] = shadowMap;
						state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

						numDirectionalShadows ++;

					}

					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );

					uniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );
					uniforms.distance = distance;

					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = light.decay;

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.spotShadow[ spotLength ] = shadowUniforms;
						state.spotShadowMap[ spotLength ] = shadowMap;
						state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

						numSpotShadows ++;

					}

					state.spot[ spotLength ] = uniforms;

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = cache.get( light );

					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

					// (b) intensity is the brightness of the light
					uniforms.color.copy( color ).multiplyScalar( intensity );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					state.rectArea[ rectAreaLength ] = uniforms;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						shadowUniforms.shadowCameraNear = shadow.camera.near;
						shadowUniforms.shadowCameraFar = shadow.camera.far;

						state.pointShadow[ pointLength ] = shadowUniforms;
						state.pointShadowMap[ pointLength ] = shadowMap;
						state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

						numPointShadows ++;

					}

					state.point[ pointLength ] = uniforms;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = cache.get( light );

					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );

					state.hemi[ hemiLength ] = uniforms;

					hemiLength ++;

				}

			}

			if ( rectAreaLength > 0 ) {

				if ( capabilities.isWebGL2 ) {

					// WebGL 2

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else {

					// WebGL 1

					if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

					} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

					} else {

						console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

					}

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			const hash = state.hash;

			if ( hash.directionalLength !== directionalLength ||
				hash.pointLength !== pointLength ||
				hash.spotLength !== spotLength ||
				hash.rectAreaLength !== rectAreaLength ||
				hash.hemiLength !== hemiLength ||
				hash.numDirectionalShadows !== numDirectionalShadows ||
				hash.numPointShadows !== numPointShadows ||
				hash.numSpotShadows !== numSpotShadows ) {

				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;

				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotShadowMatrix.length = numSpotShadows;

				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;

				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;

				state.version = nextVersion ++;

			}

		}

		function setupView( lights, camera ) {

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			const viewMatrix = camera.matrixWorldInverse;

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				if ( light.isDirectionalLight ) {

					const uniforms = state.directional[ directionalLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = state.spot[ spotLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = state.rectArea[ rectAreaLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = state.point[ pointLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = state.hemi[ hemiLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();

					hemiLength ++;

				}

			}

		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};

	}

	function WebGLRenderState( extensions, capabilities ) {

		const lights = new WebGLLights( extensions, capabilities );

		const lightsArray = [];
		const shadowsArray = [];

		function init() {

			lightsArray.length = 0;
			shadowsArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function setupLights( physicallyCorrectLights ) {

			lights.setup( lightsArray, physicallyCorrectLights );

		}

		function setupLightsView( camera ) {

			lights.setupView( lightsArray, camera );

		}

		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			lights: lights
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,

			pushLight: pushLight,
			pushShadow: pushShadow
		};

	}

	function WebGLRenderStates( extensions, capabilities ) {

		let renderStates = new WeakMap();

		function get( scene, renderCallDepth = 0 ) {

			let renderState;

			if ( renderStates.has( scene ) === false ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.set( scene, [ renderState ] );

			} else {

				if ( renderCallDepth >= renderStates.get( scene ).length ) {

					renderState = new WebGLRenderState( extensions, capabilities );
					renderStates.get( scene ).push( renderState );

				} else {

					renderState = renderStates.get( scene )[ renderCallDepth ];

				}

			}

			return renderState;

		}

		function dispose() {

			renderStates = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	class MeshDepthMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'MeshDepthMaterial';

			this.depthPacking = BasicDepthPacking;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.depthPacking = source.depthPacking;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			return this;

		}

	}

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	class MeshDistanceMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'MeshDistanceMaterial';

			this.referencePosition = new Vector3();
			this.nearDistance = 1;
			this.farDistance = 1000;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.fog = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.referencePosition.copy( source.referencePosition );
			this.nearDistance = source.nearDistance;
			this.farDistance = source.farDistance;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			return this;

		}

	}

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

	const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

	function WebGLShadowMap( _renderer, _objects, _capabilities ) {

		let _frustum = new Frustum();

		const _shadowMapSize = new Vector2(),
			_viewportSize = new Vector2(),

			_viewport = new Vector4(),

			_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
			_distanceMaterial = new MeshDistanceMaterial(),

			_materialCache = {},

			_maxTextureSize = _capabilities.maxTextureSize;

		const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

		const shadowMaterialVertical = new ShaderMaterial( {
			defines: {
				VSM_SAMPLES: 8
			},
			uniforms: {
				shadow_pass: { value: null },
				resolution: { value: new Vector2() },
				radius: { value: 4.0 }
			},

			vertexShader: vertex,
			fragmentShader: fragment

		} );

		const shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

		const fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute(
			'position',
			new BufferAttribute(
				new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
				3
			)
		);

		const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

		const scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			if ( lights.length === 0 ) return;

			const currentRenderTarget = _renderer.getRenderTarget();
			const activeCubeFace = _renderer.getActiveCubeFace();
			const activeMipmapLevel = _renderer.getActiveMipmapLevel();

			const _state = _renderer.state;

			// Set GL state for depth map.
			_state.setBlending( NoBlending );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// render depth map

			for ( let i = 0, il = lights.length; i < il; i ++ ) {

				const light = lights[ i ];
				const shadow = light.shadow;

				if ( shadow === undefined ) {

					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

				_shadowMapSize.copy( shadow.mapSize );

				const shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply( shadowFrameExtents );

				_viewportSize.copy( shadow.mapSize );

				if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

					if ( _shadowMapSize.x > _maxTextureSize ) {

						_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;

					}

					if ( _shadowMapSize.y > _maxTextureSize ) {

						_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;

					}

				}

				if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );
					shadow.map.texture.name = light.name + '.shadowMap';

					shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

					shadow.camera.updateProjectionMatrix();

				}

				if ( shadow.map === null ) {

					const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + '.shadowMap';

					shadow.camera.updateProjectionMatrix();

				}

				_renderer.setRenderTarget( shadow.map );
				_renderer.clear();

				const viewportCount = shadow.getViewportCount();

				for ( let vp = 0; vp < viewportCount; vp ++ ) {

					const viewport = shadow.getViewport( vp );

					_viewport.set(
						_viewportSize.x * viewport.x,
						_viewportSize.y * viewport.y,
						_viewportSize.x * viewport.z,
						_viewportSize.y * viewport.w
					);

					_state.viewport( _viewport );

					shadow.updateMatrices( light, vp );

					_frustum = shadow.getFrustum();

					renderObject( scene, camera, shadow.camera, light, this.type );

				}

				// do blur pass for VSM

				if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

					VSMPass( shadow, camera );

				}

				shadow.needsUpdate = false;

			}

			scope.needsUpdate = false;

			_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

		};

		function VSMPass( shadow, camera ) {

			const geometry = _objects.update( fullScreenMesh );

			if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

				shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
				shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

				shadowMaterialVertical.needsUpdate = true;
				shadowMaterialHorizontal.needsUpdate = true;

			}

			// vertical pass

			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.mapPass );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

			// horizontal pass

			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

		}

		function getDepthMaterial( object, material, light, shadowCameraNear, shadowCameraFar, type ) {

			let result = null;

			const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

			if ( customMaterial !== undefined ) {

				result = customMaterial;

			} else {

				result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

			}

			if ( ( _renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 ) ||
				( material.displacementMap && material.displacementScale !== 0 ) ||
				( material.alphaMap && material.alphaTest > 0 ) ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				const keyA = result.uuid, keyB = material.uuid;

				let materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				let cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;

				}

				result = cachedMaterial;

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if ( type === VSMShadowMap ) {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

			} else {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

			}

			result.alphaMap = material.alphaMap;
			result.alphaTest = material.alphaTest;

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.displacementMap = material.displacementMap;
			result.displacementScale = material.displacementScale;
			result.displacementBias = material.displacementBias;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

				result.referencePosition.setFromMatrixPosition( light.matrixWorld );
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, light, type ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					const geometry = _objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

							const group = groups[ k ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								const depthMaterial = getDepthMaterial( object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else if ( material.visible ) {

						const depthMaterial = getDepthMaterial( object, material, light, shadowCamera.near, shadowCamera.far, type );

						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, light, type );

			}

		}

	}

	function WebGLState( gl, extensions, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {

			let locked = false;

			const color = new Vector4();
			let currentColorMask = null;
			const currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			let locked = false;

			let currentDepthMask = null;
			let currentDepthFunc = null;
			let currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( 2929 );

					} else {

						disable( 2929 );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						if ( depthFunc ) {

							switch ( depthFunc ) {

								case NeverDepth:

									gl.depthFunc( 512 );
									break;

								case AlwaysDepth:

									gl.depthFunc( 519 );
									break;

								case LessDepth:

									gl.depthFunc( 513 );
									break;

								case LessEqualDepth:

									gl.depthFunc( 515 );
									break;

								case EqualDepth:

									gl.depthFunc( 514 );
									break;

								case GreaterEqualDepth:

									gl.depthFunc( 518 );
									break;

								case GreaterDepth:

									gl.depthFunc( 516 );
									break;

								case NotEqualDepth:

									gl.depthFunc( 517 );
									break;

								default:

									gl.depthFunc( 515 );

							}

						} else {

							gl.depthFunc( 515 );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			let locked = false;

			let currentStencilMask = null;
			let currentStencilFunc = null;
			let currentStencilRef = null;
			let currentStencilFuncMask = null;
			let currentStencilFail = null;
			let currentStencilZFail = null;
			let currentStencilZPass = null;
			let currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( ! locked ) {

						if ( stencilTest ) {

							enable( 2960 );

						} else {

							disable( 2960 );

						}

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef !== stencilRef ||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail !== stencilFail ||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		const colorBuffer = new ColorBuffer();
		const depthBuffer = new DepthBuffer();
		const stencilBuffer = new StencilBuffer();

		let enabledCapabilities = {};

		let currentBoundFramebuffers = {};
		let currentDrawbuffers = new WeakMap();
		let defaultDrawbuffers = [];

		let currentProgram = null;

		let currentBlendingEnabled = false;
		let currentBlending = null;
		let currentBlendEquation = null;
		let currentBlendSrc = null;
		let currentBlendDst = null;
		let currentBlendEquationAlpha = null;
		let currentBlendSrcAlpha = null;
		let currentBlendDstAlpha = null;
		let currentPremultipledAlpha = false;

		let currentFlipSided = null;
		let currentCullFace = null;

		let currentLineWidth = null;

		let currentPolygonOffsetFactor = null;
		let currentPolygonOffsetUnits = null;

		const maxTextures = gl.getParameter( 35661 );

		let lineWidthAvailable = false;
		let version = 0;
		const glVersion = gl.getParameter( 7938 );

		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

			version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

			version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );

		}

		let currentTextureSlot = null;
		let currentBoundTextures = {};

		const scissorParam = gl.getParameter( 3088 );
		const viewportParam = gl.getParameter( 2978 );

		const currentScissor = new Vector4().fromArray( scissorParam );
		const currentViewport = new Vector4().fromArray( viewportParam );

		function createTexture( type, target, count ) {

			const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			const texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, 10241, 9728 );
			gl.texParameteri( type, 10240, 9728 );

			for ( let i = 0; i < count; i ++ ) {

				gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

			}

			return texture;

		}

		const emptyTextures = {};
		emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
		emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( 2929 );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( 2884 );

		setBlending( NoBlending );

		//

		function enable( id ) {

			if ( enabledCapabilities[ id ] !== true ) {

				gl.enable( id );
				enabledCapabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( enabledCapabilities[ id ] !== false ) {

				gl.disable( id );
				enabledCapabilities[ id ] = false;

			}

		}

		function bindFramebuffer( target, framebuffer ) {

			if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

				gl.bindFramebuffer( target, framebuffer );

				currentBoundFramebuffers[ target ] = framebuffer;

				if ( isWebGL2 ) {

					// 36009 is equivalent to 36160

					if ( target === 36009 ) {

						currentBoundFramebuffers[ 36160 ] = framebuffer;

					}

					if ( target === 36160 ) {

						currentBoundFramebuffers[ 36009 ] = framebuffer;

					}

				}

				return true;

			}

			return false;

		}

		function drawBuffers( renderTarget, framebuffer ) {

			let drawBuffers = defaultDrawbuffers;

			let needsUpdate = false;

			if ( renderTarget ) {

				drawBuffers = currentDrawbuffers.get( framebuffer );

				if ( drawBuffers === undefined ) {

					drawBuffers = [];
					currentDrawbuffers.set( framebuffer, drawBuffers );

				}

				if ( renderTarget.isWebGLMultipleRenderTargets ) {

					const textures = renderTarget.texture;

					if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== 36064 ) {

						for ( let i = 0, il = textures.length; i < il; i ++ ) {

							drawBuffers[ i ] = 36064 + i;

						}

						drawBuffers.length = textures.length;

						needsUpdate = true;

					}

				} else {

					if ( drawBuffers[ 0 ] !== 36064 ) {

						drawBuffers[ 0 ] = 36064;

						needsUpdate = true;

					}

				}

			} else {

				if ( drawBuffers[ 0 ] !== 1029 ) {

					drawBuffers[ 0 ] = 1029;

					needsUpdate = true;

				}

			}

			if ( needsUpdate ) {

				if ( capabilities.isWebGL2 ) {

					gl.drawBuffers( drawBuffers );

				} else {

					extensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( drawBuffers );

				}

			}


		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		const equationToGL = {
			[ AddEquation ]: 32774,
			[ SubtractEquation ]: 32778,
			[ ReverseSubtractEquation ]: 32779
		};

		if ( isWebGL2 ) {

			equationToGL[ MinEquation ] = 32775;
			equationToGL[ MaxEquation ] = 32776;

		} else {

			const extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				equationToGL[ MinEquation ] = extension.MIN_EXT;
				equationToGL[ MaxEquation ] = extension.MAX_EXT;

			}

		}

		const factorToGL = {
			[ ZeroFactor ]: 0,
			[ OneFactor ]: 1,
			[ SrcColorFactor ]: 768,
			[ SrcAlphaFactor ]: 770,
			[ SrcAlphaSaturateFactor ]: 776,
			[ DstColorFactor ]: 774,
			[ DstAlphaFactor ]: 772,
			[ OneMinusSrcColorFactor ]: 769,
			[ OneMinusSrcAlphaFactor ]: 771,
			[ OneMinusDstColorFactor ]: 775,
			[ OneMinusDstAlphaFactor ]: 773
		};

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending === NoBlending ) {

				if ( currentBlendingEnabled === true ) {

					disable( 3042 );
					currentBlendingEnabled = false;

				}

				return;

			}

			if ( currentBlendingEnabled === false ) {

				enable( 3042 );
				currentBlendingEnabled = true;

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

						gl.blendEquation( 32774 );

						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;

					}

					if ( premultipliedAlpha ) {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( 1, 771, 1, 771 );
								break;

							case AdditiveBlending:
								gl.blendFunc( 1, 1 );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( 0, 769, 0, 1 );
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate( 0, 768, 0, 770 );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					} else {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( 770, 771, 1, 771 );
								break;

							case AdditiveBlending:
								gl.blendFunc( 770, 1 );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( 0, 769, 0, 1 );
								break;

							case MultiplyBlending:
								gl.blendFunc( 0, 768 );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				return;

			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

			currentBlending = blending;
			currentPremultipledAlpha = null;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( 2884 )
				: enable( 2884 );

			let flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			const stencilWrite = material.stencilWrite;
			stencilBuffer.setTest( stencilWrite );
			if ( stencilWrite ) {

				stencilBuffer.setMask( material.stencilWriteMask );
				stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
				stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

			}

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			material.alphaToCoverage === true
				? enable( 32926 )
				: disable( 32926 );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( 2304 );

				} else {

					gl.frontFace( 2305 );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( 2884 );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( 1029 );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( 1028 );

					} else {

						gl.cullFace( 1032 );

					}

				}

			} else {

				disable( 2884 );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( 32823 );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( 32823 );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( 3089 );

			} else {

				disable( 3089 );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture ) {

			if ( currentTextureSlot === null ) {

				activeTexture();

			}

			let boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function unbindTexture() {

			const boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

				gl.bindTexture( boundTexture.type, null );

				boundTexture.type = undefined;
				boundTexture.texture = undefined;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texSubImage2D() {

			try {

				gl.texSubImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texSubImage3D() {

			try {

				gl.texSubImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function compressedTexSubImage2D() {

			try {

				gl.compressedTexSubImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texStorage2D() {

			try {

				gl.texStorage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texStorage3D() {

			try {

				gl.texStorage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage3D() {

			try {

				gl.texImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		//

		function reset() {

			// reset state

			gl.disable( 3042 );
			gl.disable( 2884 );
			gl.disable( 2929 );
			gl.disable( 32823 );
			gl.disable( 3089 );
			gl.disable( 2960 );
			gl.disable( 32926 );

			gl.blendEquation( 32774 );
			gl.blendFunc( 1, 0 );
			gl.blendFuncSeparate( 1, 0, 1, 0 );

			gl.colorMask( true, true, true, true );
			gl.clearColor( 0, 0, 0, 0 );

			gl.depthMask( true );
			gl.depthFunc( 513 );
			gl.clearDepth( 1 );

			gl.stencilMask( 0xffffffff );
			gl.stencilFunc( 519, 0, 0xffffffff );
			gl.stencilOp( 7680, 7680, 7680 );
			gl.clearStencil( 0 );

			gl.cullFace( 1029 );
			gl.frontFace( 2305 );

			gl.polygonOffset( 0, 0 );

			gl.activeTexture( 33984 );

			gl.bindFramebuffer( 36160, null );

			if ( isWebGL2 === true ) {

				gl.bindFramebuffer( 36009, null );
				gl.bindFramebuffer( 36008, null );

			}

			gl.useProgram( null );

			gl.lineWidth( 1 );

			gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
			gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

			// reset internals

			enabledCapabilities = {};

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentBoundFramebuffers = {};
			currentDrawbuffers = new WeakMap();
			defaultDrawbuffers = [];

			currentProgram = null;

			currentBlendingEnabled = false;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;

			currentFlipSided = null;
			currentCullFace = null;

			currentLineWidth = null;

			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;

			currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
			currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			enable: enable,
			disable: disable,

			bindFramebuffer: bindFramebuffer,
			drawBuffers: drawBuffers,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,

			texStorage2D: texStorage2D,
			texStorage3D: texStorage3D,
			texSubImage2D: texSubImage2D,
			texSubImage3D: texSubImage3D,
			compressedTexSubImage2D: compressedTexSubImage2D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

		const isWebGL2 = capabilities.isWebGL2;
		const maxTextures = capabilities.maxTextures;
		const maxCubemapSize = capabilities.maxCubemapSize;
		const maxTextureSize = capabilities.maxTextureSize;
		const maxSamples = capabilities.maxSamples;
		const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
		const supportsInvalidateFramebuffer = /OculusBrowser/g.test( navigator.userAgent );

		const _videoTextures = new WeakMap();
		let _canvas;

		const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

		// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

		let useOffscreenCanvas = false;

		try {

			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
				// eslint-disable-next-line compat/compat
				&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

		} catch ( err ) {

			// Ignore any errors

		}

		function createCanvas( width, height ) {

			// Use OffscreenCanvas when available. Specially needed in web workers

			return useOffscreenCanvas ?
				// eslint-disable-next-line compat/compat
				new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

		}

		function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

			let scale = 1;

			// handle case if texture exceeds max size

			if ( image.width > maxSize || image.height > maxSize ) {

				scale = maxSize / Math.max( image.width, image.height );

			}

			// only perform resize if necessary

			if ( scale < 1 || needsPowerOfTwo === true ) {

				// only perform resize for certain image types

				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

					const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;

					const width = floor( scale * image.width );
					const height = floor( scale * image.height );

					if ( _canvas === undefined ) _canvas = createCanvas( width, height );

					// cube textures can't reuse the same canvas

					const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

					canvas.width = width;
					canvas.height = height;

					const context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, width, height );

					console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

					return canvas;

				} else {

					if ( 'data' in image ) {

						console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

					}

					return image;

				}

			}

			return image;

		}

		function isPowerOfTwo$1( image ) {

			return isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );

		}

		function textureNeedsPowerOfTwo( texture ) {

			if ( isWebGL2 ) return false;

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, supportsMips ) {

			return texture.generateMipmaps && supportsMips &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		function generateMipmap( target ) {

			_gl.generateMipmap( target );

		}

		function getInternalFormat( internalFormatName, glFormat, glType, encoding, isVideoTexture = false ) {

			if ( isWebGL2 === false ) return glFormat;

			if ( internalFormatName !== null ) {

				if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

				console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

			}

			let internalFormat = glFormat;

			if ( glFormat === 6403 ) {

				if ( glType === 5126 ) internalFormat = 33326;
				if ( glType === 5131 ) internalFormat = 33325;
				if ( glType === 5121 ) internalFormat = 33321;

			}

			if ( glFormat === 33319 ) {

				if ( glType === 5126 ) internalFormat = 33328;
				if ( glType === 5131 ) internalFormat = 33327;
				if ( glType === 5121 ) internalFormat = 33323;

			}

			if ( glFormat === 6408 ) {

				if ( glType === 5126 ) internalFormat = 34836;
				if ( glType === 5131 ) internalFormat = 34842;
				if ( glType === 5121 ) internalFormat = ( encoding === sRGBEncoding && isVideoTexture === false ) ? 35907 : 32856;
				if ( glType === 32819 ) internalFormat = 32854;
				if ( glType === 32820 ) internalFormat = 32855;

			}

			if ( internalFormat === 33325 || internalFormat === 33326 ||
				internalFormat === 33327 || internalFormat === 33328 ||
				internalFormat === 34842 || internalFormat === 34836 ) {

				extensions.get( 'EXT_color_buffer_float' );

			}

			return internalFormat;

		}

		function getMipLevels( texture, image, supportsMips ) {

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

				return Math.log2( Math.max( image.width, image.height ) ) + 1;

			} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

				// user-defined mipmaps

				return texture.mipmaps.length;

			} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

				return image.mipmaps.length;

			} else {

				// texture without mipmaps (only base level)

				return 1;

			}

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

				return 9728;

			}

			return 9729;

		}

		//

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				_videoTextures.delete( texture );

			}

		}

		function onRenderTargetDispose( event ) {

			const renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

		}

		//

		function deallocateTexture( texture ) {

			const textureProperties = properties.get( texture );

			if ( textureProperties.__webglInit === undefined ) return;

			// check if it's necessary to remove the WebGLTexture object

			const source = texture.source;
			const webglTextures = _sources.get( source );

			if ( webglTextures ) {

				const webglTexture = webglTextures[ textureProperties.__cacheKey ];
				webglTexture.usedTimes --;

				// the WebGLTexture object is not used anymore, remove it

				if ( webglTexture.usedTimes === 0 ) {

					deleteTexture( texture );

				}

				// remove the weak map entry if no WebGLTexture uses the source anymore

				if ( Object.keys( webglTextures ).length === 0 ) {

					_sources.delete( source );

				}

			}

			properties.remove( texture );

		}

		function deleteTexture( texture ) {

			const textureProperties = properties.get( texture );
			_gl.deleteTexture( textureProperties.__webglTexture );

			const source = texture.source;
			const webglTextures = _sources.get( source );
			delete webglTextures[ textureProperties.__cacheKey ];

			info.memory.textures --;

		}

		function deallocateRenderTarget( renderTarget ) {

			const texture = renderTarget.texture;

			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( texture );

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

				info.memory.textures --;

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				for ( let i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
				if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
				if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
				if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

			}

			if ( renderTarget.isWebGLMultipleRenderTargets ) {

				for ( let i = 0, il = texture.length; i < il; i ++ ) {

					const attachmentProperties = properties.get( texture[ i ] );

					if ( attachmentProperties.__webglTexture ) {

						_gl.deleteTexture( attachmentProperties.__webglTexture );

						info.memory.textures --;

					}

					properties.remove( texture[ i ] );

				}

			}

			properties.remove( texture );
			properties.remove( renderTarget );

		}

		//

		let textureUnits = 0;

		function resetTextureUnits() {

			textureUnits = 0;

		}

		function allocateTextureUnit() {

			const textureUnit = textureUnits;

			if ( textureUnit >= maxTextures ) {

				console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

			}

			textureUnits += 1;

			return textureUnit;

		}

		function getTextureCacheKey( texture ) {

			const array = [];

			array.push( texture.wrapS );
			array.push( texture.wrapT );
			array.push( texture.magFilter );
			array.push( texture.minFilter );
			array.push( texture.anisotropy );
			array.push( texture.internalFormat );
			array.push( texture.format );
			array.push( texture.type );
			array.push( texture.generateMipmaps );
			array.push( texture.premultiplyAlpha );
			array.push( texture.flipY );
			array.push( texture.unpackAlignment );
			array.push( texture.encoding );

			return array.join();

		}

		//

		function setTexture2D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.isVideoTexture ) updateVideoTexture( texture );

			if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

				const image = texture.image;

				if ( image === null ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 3553, textureProperties.__webglTexture );

		}

		function setTexture2DArray( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 35866, textureProperties.__webglTexture );

		}

		function setTexture3D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 32879, textureProperties.__webglTexture );

		}

		function setTextureCube( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadCubeTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 34067, textureProperties.__webglTexture );

		}

		const wrappingToGL = {
			[ RepeatWrapping ]: 10497,
			[ ClampToEdgeWrapping ]: 33071,
			[ MirroredRepeatWrapping ]: 33648
		};

		const filterToGL = {
			[ NearestFilter ]: 9728,
			[ NearestMipmapNearestFilter ]: 9984,
			[ NearestMipmapLinearFilter ]: 9986,

			[ LinearFilter ]: 9729,
			[ LinearMipmapNearestFilter ]: 9985,
			[ LinearMipmapLinearFilter ]: 9987
		};

		function setTextureParameters( textureType, texture, supportsMips ) {

			if ( supportsMips ) {

				_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
				_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

				if ( textureType === 32879 || textureType === 35866 ) {

					_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

				}

				_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
				_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

			} else {

				_gl.texParameteri( textureType, 10242, 33071 );
				_gl.texParameteri( textureType, 10243, 33071 );

				if ( textureType === 32879 || textureType === 35866 ) {

					_gl.texParameteri( textureType, 32882, 33071 );

				}

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

				}

				_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

				}

			}

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
				if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function initTexture( textureProperties, texture ) {

			let forceUpload = false;

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

			}

			// create Source <-> WebGLTextures mapping if necessary

			const source = texture.source;
			let webglTextures = _sources.get( source );

			if ( webglTextures === undefined ) {

				webglTextures = {};
				_sources.set( source, webglTextures );

			}

			// check if there is already a WebGLTexture object for the given texture parameters

			const textureCacheKey = getTextureCacheKey( texture );

			if ( textureCacheKey !== textureProperties.__cacheKey ) {

				// if not, create a new instance of WebGLTexture

				if ( webglTextures[ textureCacheKey ] === undefined ) {

					// create new entry

					webglTextures[ textureCacheKey ] = {
						texture: _gl.createTexture(),
						usedTimes: 0
					};

					info.memory.textures ++;

					// when a new instance of WebGLTexture was created, a texture upload is required
					// even if the image contents are identical

					forceUpload = true;

				}

				webglTextures[ textureCacheKey ].usedTimes ++;

				// every time the texture cache key changes, it's necessary to check if an instance of
				// WebGLTexture can be deleted in order to avoid a memory leak.

				const webglTexture = webglTextures[ textureProperties.__cacheKey ];

				if ( webglTexture !== undefined ) {

					webglTextures[ textureProperties.__cacheKey ].usedTimes --;

					if ( webglTexture.usedTimes === 0 ) {

						deleteTexture( texture );

					}

				}

				// store references to cache key and WebGLTexture object

				textureProperties.__cacheKey = textureCacheKey;
				textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

			}

			return forceUpload;

		}

		function uploadTexture( textureProperties, texture, slot ) {

			let textureType = 3553;

			if ( texture.isDataArrayTexture ) textureType = 35866;
			if ( texture.isData3DTexture ) textureType = 32879;

			const forceUpload = initTexture( textureProperties, texture );
			const source = texture.source;

			state.activeTexture( 33984 + slot );
			state.bindTexture( textureType, textureProperties.__webglTexture );

			if ( source.version !== source.__currentVersion || forceUpload === true ) {

				_gl.pixelStorei( 37440, texture.flipY );
				_gl.pixelStorei( 37441, texture.premultiplyAlpha );
				_gl.pixelStorei( 3317, texture.unpackAlignment );
				_gl.pixelStorei( 37443, 0 );

				const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;
				let image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );
				image = verifyColorSpace( texture, image );

				const supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
					glFormat = utils.convert( texture.format, texture.encoding );

				let glType = utils.convert( texture.type ),
					glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture );

				setTextureParameters( textureType, texture, supportsMips );

				let mipmap;
				const mipmaps = texture.mipmaps;

				const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
				const allocateMemory = ( textureProperties.__version === undefined );
				const levels = getMipLevels( texture, image, supportsMips );

				if ( texture.isDepthTexture ) {

					// populate depth texture with dummy data

					glInternalFormat = 6402;

					if ( isWebGL2 ) {

						if ( texture.type === FloatType ) {

							glInternalFormat = 36012;

						} else if ( texture.type === UnsignedIntType ) {

							glInternalFormat = 33190;

						} else if ( texture.type === UnsignedInt248Type ) {

							glInternalFormat = 35056;

						} else {

							glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

						}

					} else {

						if ( texture.type === FloatType ) {

							console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

						}

					}

					// validation checks for WebGL 1

					if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

							console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

							texture.type = UnsignedShortType;
							glType = utils.convert( texture.type );

						}

					}

					if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

						// Depth stencil textures need the DEPTH_STENCIL internal format
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						glInternalFormat = 34041;

						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedInt248Type ) {

							console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

							texture.type = UnsignedInt248Type;
							glType = utils.convert( texture.type );

						}

					}

					//

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( 3553, 1, glInternalFormat, image.width, image.height );

					} else {

						state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

					}

				} else if ( texture.isDataTexture ) {

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && supportsMips ) {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( useTexStorage ) {

								state.texSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

							} else {

								state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

						texture.generateMipmaps = false;

					} else {

						if ( useTexStorage ) {

							if ( allocateMemory ) {

								state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

							}

							state.texSubImage2D( 3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

						} else {

							state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

						}

					}

				} else if ( texture.isCompressedTexture ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									state.compressedTexSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

								} else {

									state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								}

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

							}

						} else {

							if ( useTexStorage ) {

								state.texSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

							} else {

								state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				} else if ( texture.isDataArrayTexture ) {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage3D( 35866, levels, glInternalFormat, image.width, image.height, image.depth );

						}

						state.texSubImage3D( 35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

					} else {

						state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

					}

				} else if ( texture.isData3DTexture ) {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage3D( 32879, levels, glInternalFormat, image.width, image.height, image.depth );

						}

						state.texSubImage3D( 32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

					} else {

						state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

					}

				} else if ( texture.isFramebufferTexture ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

					} else {

						state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

					}

				} else {

					// regular Texture (image, video, canvas)

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && supportsMips ) {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( useTexStorage ) {

								state.texSubImage2D( 3553, i, 0, 0, glFormat, glType, mipmap );

							} else {

								state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

							}

						}

						texture.generateMipmaps = false;

					} else {

						if ( useTexStorage ) {

							if ( allocateMemory ) {

								state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

							}

							state.texSubImage2D( 3553, 0, 0, 0, glFormat, glType, image );

						} else {

							state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );

						}

					}

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( textureType );

				}

				source.__currentVersion = source.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			}

			textureProperties.__version = texture.version;

		}

		function uploadCubeTexture( textureProperties, texture, slot ) {

			if ( texture.image.length !== 6 ) return;

			const forceUpload = initTexture( textureProperties, texture );
			const source = texture.source;

			state.activeTexture( 33984 + slot );
			state.bindTexture( 34067, textureProperties.__webglTexture );

			if ( source.version !== source.__currentVersion || forceUpload === true ) {

				_gl.pixelStorei( 37440, texture.flipY );
				_gl.pixelStorei( 37441, texture.premultiplyAlpha );
				_gl.pixelStorei( 3317, texture.unpackAlignment );
				_gl.pixelStorei( 37443, 0 );

				const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
				const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

				const cubeImage = [];

				for ( let i = 0; i < 6; i ++ ) {

					if ( ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

					cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

				}

				const image = cubeImage[ 0 ],
					supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
					glFormat = utils.convert( texture.format, texture.encoding ),
					glType = utils.convert( texture.type ),
					glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );

				const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
				const allocateMemory = ( textureProperties.__version === undefined );
				let levels = getMipLevels( texture, image, supportsMips );

				setTextureParameters( 34067, texture, supportsMips );

				let mipmaps;

				if ( isCompressed ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( 34067, levels, glInternalFormat, image.width, image.height );

					}

					for ( let i = 0; i < 6; i ++ ) {

						mipmaps = cubeImage[ i ].mipmaps;

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];

							if ( texture.format !== RGBAFormat ) {

								if ( glFormat !== null ) {

									if ( useTexStorage ) {

										state.compressedTexSubImage2D( 34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

									} else {

										state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									}

								} else {

									console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

								}

							} else {

								if ( useTexStorage ) {

									state.texSubImage2D( 34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

								} else {

									state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

				} else {

					mipmaps = texture.mipmaps;

					if ( useTexStorage && allocateMemory ) {

						// TODO: Uniformly handle mipmap definitions
						// Normal textures and compressed cube textures define base level + mips with their mipmap array
						// Uncompressed cube textures use their mipmap array only for mips (no base level)

						if ( mipmaps.length > 0 ) levels ++;

						state.texStorage2D( 34067, levels, glInternalFormat, cubeImage[ 0 ].width, cubeImage[ 0 ].height );

					}

					for ( let i = 0; i < 6; i ++ ) {

						if ( isDataTexture ) {

							if ( useTexStorage ) {

								state.texSubImage2D( 34069 + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

							} else {

								state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							}

							for ( let j = 0; j < mipmaps.length; j ++ ) {

								const mipmap = mipmaps[ j ];
								const mipmapImage = mipmap.image[ i ].image;

								if ( useTexStorage ) {

									state.texSubImage2D( 34069 + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

								} else {

									state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

								}

							}

						} else {

							if ( useTexStorage ) {

								state.texSubImage2D( 34069 + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

							} else {

								state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

							}

							for ( let j = 0; j < mipmaps.length; j ++ ) {

								const mipmap = mipmaps[ j ];

								if ( useTexStorage ) {

									state.texSubImage2D( 34069 + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

								} else {

									state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

								}

							}

						}

					}

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					// We assume images for cube map have the same size.
					generateMipmap( 34067 );

				}

				source.__currentVersion = source.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			}

			textureProperties.__version = texture.version;

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {

			const glFormat = utils.convert( texture.format, texture.encoding );
			const glType = utils.convert( texture.type );
			const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
			const renderTargetProperties = properties.get( renderTarget );

			if ( ! renderTargetProperties.__hasExternalTextures ) {

				if ( textureTarget === 32879 || textureTarget === 35866 ) {

					state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

				} else {

					state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				}

			}

			state.bindFramebuffer( 36160, framebuffer );

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

			} else {

				_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );

			}

			state.bindFramebuffer( 36160, null );

		}


		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

			_gl.bindRenderbuffer( 36161, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				let glInternalFormat = 33189;

				if ( isMultisample || useMultisampledRTT( renderTarget ) ) {

					const depthTexture = renderTarget.depthTexture;

					if ( depthTexture && depthTexture.isDepthTexture ) {

						if ( depthTexture.type === FloatType ) {

							glInternalFormat = 36012;

						} else if ( depthTexture.type === UnsignedIntType ) {

							glInternalFormat = 33190;

						}

					}

					const samples = getRenderTargetSamples( renderTarget );

					if ( useMultisampledRTT( renderTarget ) ) {

						multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else {

						_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					}

				} else {

					_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

				}

				_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				const samples = getRenderTargetSamples( renderTarget );

				if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

					_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

				} else if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, 35056, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

				}


				_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

			} else {

				// Use the first texture for MRT so far
				const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[ 0 ] : renderTarget.texture;

				const glFormat = utils.convert( texture.format, texture.encoding );
				const glType = utils.convert( texture.type );
				const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
				const samples = getRenderTargetSamples( renderTarget );

				if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			}

			_gl.bindRenderbuffer( 36161, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			state.bindFramebuffer( 36160, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
			const samples = getRenderTargetSamples( renderTarget );

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 36096, 3553, webglDepthTexture, 0, samples );

				} else {

					_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

				}

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 33306, 3553, webglDepthTexture, 0, samples );

				} else {

					_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

				}

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );
			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

			if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( let i = 0; i < 6; i ++ ) {

						state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

					}

				} else {

					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

				}

			}

			state.bindFramebuffer( 36160, null );

		}

		// rebind framebuffer with external textures
		function rebindTextures( renderTarget, colorTexture, depthTexture ) {

			const renderTargetProperties = properties.get( renderTarget );

			if ( colorTexture !== undefined ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553 );

			}

			if ( depthTexture !== undefined ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			const texture = renderTarget.texture;

			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			if ( renderTarget.isWebGLMultipleRenderTargets !== true ) {

				if ( textureProperties.__webglTexture === undefined ) {

					textureProperties.__webglTexture = _gl.createTexture();

				}

				textureProperties.__version = texture.version;
				info.memory.textures ++;

			}

			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
			const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );
			const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if ( isMultipleRenderTargets ) {

					if ( capabilities.drawBuffers ) {

						const textures = renderTarget.texture;

						for ( let i = 0, il = textures.length; i < il; i ++ ) {

							const attachmentProperties = properties.get( textures[ i ] );

							if ( attachmentProperties.__webglTexture === undefined ) {

								attachmentProperties.__webglTexture = _gl.createTexture();

								info.memory.textures ++;

							}

						}

					} else {

						console.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );

					}

				} else if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

					const glFormat = utils.convert( texture.format, texture.encoding );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
					const samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
					_gl.bindRenderbuffer( 36161, null );

					if ( renderTarget.depthBuffer ) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					}

					state.bindFramebuffer( 36160, null );

				}

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( 34067, textureProperties.__webglTexture );
				setTextureParameters( 34067, texture, supportsMips );

				for ( let i = 0; i < 6; i ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, 36064, 34069 + i );

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( 34067 );

				}

				state.unbindTexture();

			} else if ( isMultipleRenderTargets ) {

				const textures = renderTarget.texture;

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					const attachment = textures[ i ];
					const attachmentProperties = properties.get( attachment );

					state.bindTexture( 3553, attachmentProperties.__webglTexture );
					setTextureParameters( 3553, attachment, supportsMips );
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553 );

					if ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {

						generateMipmap( 3553 );

					}

				}

				state.unbindTexture();

			} else {

				let glTextureType = 3553;

				if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

					if ( isWebGL2 ) {

						glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;

					} else {

						console.error( 'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.' );

					}

				}

				state.bindTexture( glTextureType, textureProperties.__webglTexture );
				setTextureParameters( glTextureType, texture, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType );

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( glTextureType );

				}

				state.unbindTexture();

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

			for ( let i = 0, il = textures.length; i < il; i ++ ) {

				const texture = textures[ i ];

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
					const webglTexture = properties.get( texture ).__webglTexture;

					state.bindTexture( target, webglTexture );
					generateMipmap( target );
					state.unbindTexture();

				}

			}

		}

		function updateMultisampleRenderTarget( renderTarget ) {

			if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = 16384;
				const invalidationArray = [ 36064 ];
				const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;

				if ( renderTarget.depthBuffer ) {

					invalidationArray.push( depthStyle );

				}

				const renderTargetProperties = properties.get( renderTarget );
				const ignoreDepthValues = ( renderTargetProperties.__ignoreDepthValues !== undefined ) ? renderTargetProperties.__ignoreDepthValues : false;

				if ( ignoreDepthValues === false ) {

					if ( renderTarget.depthBuffer ) mask |= 256;
					if ( renderTarget.stencilBuffer ) mask |= 1024;

				}

				state.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
				state.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

				if ( ignoreDepthValues === true ) {

					_gl.invalidateFramebuffer( 36008, [ depthStyle ] );
					_gl.invalidateFramebuffer( 36009, [ depthStyle ] );

				}

				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				if ( supportsInvalidateFramebuffer ) {

					_gl.invalidateFramebuffer( 36008, invalidationArray );

				}

				state.bindFramebuffer( 36008, null );
				state.bindFramebuffer( 36009, renderTargetProperties.__webglMultisampledFramebuffer );

			}

		}

		function getRenderTargetSamples( renderTarget ) {

			return Math.min( maxSamples, renderTarget.samples );

		}

		function useMultisampledRTT( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );

			return isWebGL2 && renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

		}

		function updateVideoTexture( texture ) {

			const frame = info.render.frame;

			// Check the last frame we updated the VideoTexture

			if ( _videoTextures.get( texture ) !== frame ) {

				_videoTextures.set( texture, frame );
				texture.update();

			}

		}

		function verifyColorSpace( texture, image ) {

			const encoding = texture.encoding;
			const format = texture.format;
			const type = texture.type;

			if ( texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat ) return image;

			if ( encoding !== LinearEncoding ) {

				// sRGB

				if ( encoding === sRGBEncoding ) {

					if ( isWebGL2 === false ) {

						// in WebGL 1, try to use EXT_sRGB extension and unsized formats

						if ( extensions.has( 'EXT_sRGB' ) === true && format === RGBAFormat ) {

							texture.format = _SRGBAFormat;

							// it's not possible to generate mips in WebGL 1 with this extension

							texture.minFilter = LinearFilter;
							texture.generateMipmaps = false;

						} else {

							// slow fallback (CPU decode)

							image = ImageUtils.sRGBToLinear( image );

						}

					} else {

						// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

						if ( format !== RGBAFormat || type !== UnsignedByteType ) {

							console.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );

						}

					}

				} else {

					console.error( 'THREE.WebGLTextures: Unsupported texture encoding:', encoding );

				}

			}

			return image;

		}

		//

		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;

		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.rebindTextures = rebindTextures;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
		this.setupDepthRenderbuffer = setupDepthRenderbuffer;
		this.setupFrameBufferTexture = setupFrameBufferTexture;
		this.useMultisampledRTT = useMultisampledRTT;

	}

	function WebGLUtils( gl, extensions, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		function convert( p, encoding = null ) {

			let extension;

			if ( p === UnsignedByteType ) return 5121;
			if ( p === UnsignedShort4444Type ) return 32819;
			if ( p === UnsignedShort5551Type ) return 32820;

			if ( p === ByteType ) return 5120;
			if ( p === ShortType ) return 5122;
			if ( p === UnsignedShortType ) return 5123;
			if ( p === IntType ) return 5124;
			if ( p === UnsignedIntType ) return 5125;
			if ( p === FloatType ) return 5126;

			if ( p === HalfFloatType ) {

				if ( isWebGL2 ) return 5131;

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) {

					return extension.HALF_FLOAT_OES;

				} else {

					return null;

				}

			}

			if ( p === AlphaFormat ) return 6406;
			if ( p === RGBAFormat ) return 6408;
			if ( p === LuminanceFormat ) return 6409;
			if ( p === LuminanceAlphaFormat ) return 6410;
			if ( p === DepthFormat ) return 6402;
			if ( p === DepthStencilFormat ) return 34041;
			if ( p === RedFormat ) return 6403;

			if ( p === RGBFormat ) {

				console.warn( 'THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228' );
				return 6408;

			}

			// WebGL 1 sRGB fallback

			if ( p === _SRGBAFormat ) {

				extension = extensions.get( 'EXT_sRGB' );

				if ( extension !== null ) {

					return extension.SRGB_ALPHA_EXT;

				} else {

					return null;

				}

			}

			// WebGL2 formats.

			if ( p === RedIntegerFormat ) return 36244;
			if ( p === RGFormat ) return 33319;
			if ( p === RGIntegerFormat ) return 33320;
			if ( p === RGBAIntegerFormat ) return 36249;

			// S3TC

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				if ( encoding === sRGBEncoding ) {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

					} else {

						return null;

					}

				} else {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

					} else {

						return null;

					}

				}

			}

			// PVRTC

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				} else {

					return null;

				}

			}

			// ETC1

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) {

					return extension.COMPRESSED_RGB_ETC1_WEBGL;

				} else {

					return null;

				}

			}

			// ETC2

			if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc' );

				if ( extension !== null ) {

					if ( p === RGB_ETC2_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
					if ( p === RGBA_ETC2_EAC_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

				} else {

					return null;

				}

			}

			// ASTC

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					if ( p === RGBA_ASTC_4x4_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
					if ( p === RGBA_ASTC_5x4_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
					if ( p === RGBA_ASTC_5x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
					if ( p === RGBA_ASTC_6x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
					if ( p === RGBA_ASTC_6x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
					if ( p === RGBA_ASTC_8x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
					if ( p === RGBA_ASTC_8x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
					if ( p === RGBA_ASTC_8x8_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
					if ( p === RGBA_ASTC_10x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
					if ( p === RGBA_ASTC_10x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
					if ( p === RGBA_ASTC_10x8_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
					if ( p === RGBA_ASTC_10x10_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
					if ( p === RGBA_ASTC_12x10_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
					if ( p === RGBA_ASTC_12x12_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

				} else {

					return null;

				}

			}

			// BPTC

			if ( p === RGBA_BPTC_Format ) {

				extension = extensions.get( 'EXT_texture_compression_bptc' );

				if ( extension !== null ) {

					if ( p === RGBA_BPTC_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;

				} else {

					return null;

				}

			}

			//

			if ( p === UnsignedInt248Type ) {

				if ( isWebGL2 ) return 34042;

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) {

					return extension.UNSIGNED_INT_24_8_WEBGL;

				} else {

					return null;

				}

			}

		}

		return { convert: convert };

	}

	class ArrayCamera extends PerspectiveCamera {

		constructor( array = [] ) {

			super();

			this.cameras = array;

		}

	}

	ArrayCamera.prototype.isArrayCamera = true;

	class Group extends Object3D {

		constructor() {

			super();

			this.type = 'Group';

		}

	}

	Group.prototype.isGroup = true;

	const _moveEvent = { type: 'move' };

	class WebXRController {

		constructor() {

			this._targetRay = null;
			this._grip = null;
			this._hand = null;

		}

		getHandSpace() {

			if ( this._hand === null ) {

				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;

				this._hand.joints = {};
				this._hand.inputState = { pinching: false };

			}

			return this._hand;

		}

		getTargetRaySpace() {

			if ( this._targetRay === null ) {

				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;
				this._targetRay.hasLinearVelocity = false;
				this._targetRay.linearVelocity = new Vector3();
				this._targetRay.hasAngularVelocity = false;
				this._targetRay.angularVelocity = new Vector3();

			}

			return this._targetRay;

		}

		getGripSpace() {

			if ( this._grip === null ) {

				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;
				this._grip.hasLinearVelocity = false;
				this._grip.linearVelocity = new Vector3();
				this._grip.hasAngularVelocity = false;
				this._grip.angularVelocity = new Vector3();

			}

			return this._grip;

		}

		dispatchEvent( event ) {

			if ( this._targetRay !== null ) {

				this._targetRay.dispatchEvent( event );

			}

			if ( this._grip !== null ) {

				this._grip.dispatchEvent( event );

			}

			if ( this._hand !== null ) {

				this._hand.dispatchEvent( event );

			}

			return this;

		}

		disconnect( inputSource ) {

			this.dispatchEvent( { type: 'disconnected', data: inputSource } );

			if ( this._targetRay !== null ) {

				this._targetRay.visible = false;

			}

			if ( this._grip !== null ) {

				this._grip.visible = false;

			}

			if ( this._hand !== null ) {

				this._hand.visible = false;

			}

			return this;

		}

		update( inputSource, frame, referenceSpace ) {

			let inputPose = null;
			let gripPose = null;
			let handPose = null;

			const targetRay = this._targetRay;
			const grip = this._grip;
			const hand = this._hand;

			if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

				if ( targetRay !== null ) {

					inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

					if ( inputPose !== null ) {

						targetRay.matrix.fromArray( inputPose.transform.matrix );
						targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

						if ( inputPose.linearVelocity ) {

							targetRay.hasLinearVelocity = true;
							targetRay.linearVelocity.copy( inputPose.linearVelocity );

						} else {

							targetRay.hasLinearVelocity = false;

						}

						if ( inputPose.angularVelocity ) {

							targetRay.hasAngularVelocity = true;
							targetRay.angularVelocity.copy( inputPose.angularVelocity );

						} else {

							targetRay.hasAngularVelocity = false;

						}

						this.dispatchEvent( _moveEvent );

					}

				}

				if ( hand && inputSource.hand ) {

					handPose = true;

					for ( const inputjoint of inputSource.hand.values() ) {

						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose( inputjoint, referenceSpace );

						if ( hand.joints[ inputjoint.jointName ] === undefined ) {

							// The transform of this joint will be updated with the joint pose on each frame
							const joint = new Group();
							joint.matrixAutoUpdate = false;
							joint.visible = false;
							hand.joints[ inputjoint.jointName ] = joint;
							// ??
							hand.add( joint );

						}

						const joint = hand.joints[ inputjoint.jointName ];

						if ( jointPose !== null ) {

							joint.matrix.fromArray( jointPose.transform.matrix );
							joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
							joint.jointRadius = jointPose.radius;

						}

						joint.visible = jointPose !== null;

					}

					// Custom events

					// Check pinchz
					const indexTip = hand.joints[ 'index-finger-tip' ];
					const thumbTip = hand.joints[ 'thumb-tip' ];
					const distance = indexTip.position.distanceTo( thumbTip.position );

					const distanceToPinch = 0.02;
					const threshold = 0.005;

					if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

						hand.inputState.pinching = false;
						this.dispatchEvent( {
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						} );

					} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

						hand.inputState.pinching = true;
						this.dispatchEvent( {
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						} );

					}

				} else {

					if ( grip !== null && inputSource.gripSpace ) {

						gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

						if ( gripPose !== null ) {

							grip.matrix.fromArray( gripPose.transform.matrix );
							grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

							if ( gripPose.linearVelocity ) {

								grip.hasLinearVelocity = true;
								grip.linearVelocity.copy( gripPose.linearVelocity );

							} else {

								grip.hasLinearVelocity = false;

							}

							if ( gripPose.angularVelocity ) {

								grip.hasAngularVelocity = true;
								grip.angularVelocity.copy( gripPose.angularVelocity );

							} else {

								grip.hasAngularVelocity = false;

							}

						}

					}

				}

			}

			if ( targetRay !== null ) {

				targetRay.visible = ( inputPose !== null );

			}

			if ( grip !== null ) {

				grip.visible = ( gripPose !== null );

			}

			if ( hand !== null ) {

				hand.visible = ( handPose !== null );

			}

			return this;

		}

	}

	class DepthTexture extends Texture {

		constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

			format = format !== undefined ? format : DepthFormat;

			if ( format !== DepthFormat && format !== DepthStencilFormat ) {

				throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

			}

			if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
			if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

			super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.image = { width: width, height: height };

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.flipY = false;
			this.generateMipmaps	= false;

		}


	}

	DepthTexture.prototype.isDepthTexture = true;

	class WebXRManager extends EventDispatcher$1 {

		constructor( renderer, gl ) {

			super();

			const scope = this;

			let session = null;
			let framebufferScaleFactor = 1.0;

			let referenceSpace = null;
			let referenceSpaceType = 'local-floor';

			let pose = null;
			let glBinding = null;
			let glProjLayer = null;
			let glBaseLayer = null;
			let xrFrame = null;
			const attributes = gl.getContextAttributes();
			let initialRenderTarget = null;
			let newRenderTarget = null;

			const controllers = [];
			const inputSourcesMap = new Map();

			//

			const cameraL = new PerspectiveCamera();
			cameraL.layers.enable( 1 );
			cameraL.viewport = new Vector4();

			const cameraR = new PerspectiveCamera();
			cameraR.layers.enable( 2 );
			cameraR.viewport = new Vector4();

			const cameras = [ cameraL, cameraR ];

			const cameraVR = new ArrayCamera();
			cameraVR.layers.enable( 1 );
			cameraVR.layers.enable( 2 );

			let _currentDepthNear = null;
			let _currentDepthFar = null;

			//

			this.cameraAutoUpdate = true;
			this.enabled = false;

			this.isPresenting = false;

			this.getController = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getTargetRaySpace();

			};

			this.getControllerGrip = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getGripSpace();

			};

			this.getHand = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getHandSpace();

			};

			//

			function onSessionEvent( event ) {

				const controller = inputSourcesMap.get( event.inputSource );

				if ( controller ) {

					controller.dispatchEvent( { type: event.type, data: event.inputSource } );

				}

			}

			function onSessionEnd() {

				inputSourcesMap.forEach( function ( controller, inputSource ) {

					controller.disconnect( inputSource );

				} );

				inputSourcesMap.clear();

				_currentDepthNear = null;
				_currentDepthFar = null;

				// restore framebuffer/rendering state

				renderer.setRenderTarget( initialRenderTarget );

				glBaseLayer = null;
				glProjLayer = null;
				glBinding = null;
				session = null;
				newRenderTarget = null;

				//

				animation.stop();

				scope.isPresenting = false;

				scope.dispatchEvent( { type: 'sessionend' } );

			}

			this.setFramebufferScaleFactor = function ( value ) {

				framebufferScaleFactor = value;

				if ( scope.isPresenting === true ) {

					console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

				}

			};

			this.setReferenceSpaceType = function ( value ) {

				referenceSpaceType = value;

				if ( scope.isPresenting === true ) {

					console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

				}

			};

			this.getReferenceSpace = function () {

				return referenceSpace;

			};

			this.getBaseLayer = function () {

				return glProjLayer !== null ? glProjLayer : glBaseLayer;

			};

			this.getBinding = function () {

				return glBinding;

			};

			this.getFrame = function () {

				return xrFrame;

			};

			this.getSession = function () {

				return session;

			};

			this.setSession = async function ( value ) {

				session = value;

				if ( session !== null ) {

					initialRenderTarget = renderer.getRenderTarget();

					session.addEventListener( 'select', onSessionEvent );
					session.addEventListener( 'selectstart', onSessionEvent );
					session.addEventListener( 'selectend', onSessionEvent );
					session.addEventListener( 'squeeze', onSessionEvent );
					session.addEventListener( 'squeezestart', onSessionEvent );
					session.addEventListener( 'squeezeend', onSessionEvent );
					session.addEventListener( 'end', onSessionEnd );
					session.addEventListener( 'inputsourceschange', onInputSourcesChange );

					if ( attributes.xrCompatible !== true ) {

						await gl.makeXRCompatible();

					}

					if ( ( session.renderState.layers === undefined ) || ( renderer.capabilities.isWebGL2 === false ) ) {

						const layerInit = {
							antialias: ( session.renderState.layers === undefined ) ? attributes.antialias : true,
							alpha: attributes.alpha,
							depth: attributes.depth,
							stencil: attributes.stencil,
							framebufferScaleFactor: framebufferScaleFactor
						};

						glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

						session.updateRenderState( { baseLayer: glBaseLayer } );

						newRenderTarget = new WebGLRenderTarget(
							glBaseLayer.framebufferWidth,
							glBaseLayer.framebufferHeight,
							{
								format: RGBAFormat,
								type: UnsignedByteType,
								encoding: renderer.outputEncoding
							}
						);

					} else {

						let depthFormat = null;
						let depthType = null;
						let glDepthFormat = null;

						if ( attributes.depth ) {

							glDepthFormat = attributes.stencil ? 35056 : 33190;
							depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
							depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;

						}

						const projectionlayerInit = {
							colorFormat: ( renderer.outputEncoding === sRGBEncoding ) ? 35907 : 32856,
							depthFormat: glDepthFormat,
							scaleFactor: framebufferScaleFactor
						};

						glBinding = new XRWebGLBinding( session, gl );

						glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

						session.updateRenderState( { layers: [ glProjLayer ] } );

						newRenderTarget = new WebGLRenderTarget(
							glProjLayer.textureWidth,
							glProjLayer.textureHeight,
							{
								format: RGBAFormat,
								type: UnsignedByteType,
								depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
								stencilBuffer: attributes.stencil,
								encoding: renderer.outputEncoding,
								samples: attributes.antialias ? 4 : 0
							} );

						const renderTargetProperties = renderer.properties.get( newRenderTarget );
						renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;

					}

					newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

					// Set foveation to maximum.
					this.setFoveation( 1.0 );

					referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

					animation.setContext( session );
					animation.start();

					scope.isPresenting = true;

					scope.dispatchEvent( { type: 'sessionstart' } );

				}

			};

			function onInputSourcesChange( event ) {

				const inputSources = session.inputSources;

				// Assign inputSources to available controllers

				for ( let i = 0; i < controllers.length; i ++ ) {

					inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

				}

				// Notify disconnected

				for ( let i = 0; i < event.removed.length; i ++ ) {

					const inputSource = event.removed[ i ];
					const controller = inputSourcesMap.get( inputSource );

					if ( controller ) {

						controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
						inputSourcesMap.delete( inputSource );

					}

				}

				// Notify connected

				for ( let i = 0; i < event.added.length; i ++ ) {

					const inputSource = event.added[ i ];
					const controller = inputSourcesMap.get( inputSource );

					if ( controller ) {

						controller.dispatchEvent( { type: 'connected', data: inputSource } );

					}

				}

			}

			//

			const cameraLPos = new Vector3();
			const cameraRPos = new Vector3();

			/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */
			function setProjectionFromUnion( camera, cameraL, cameraR ) {

				cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
				cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

				const ipd = cameraLPos.distanceTo( cameraRPos );

				const projL = cameraL.projectionMatrix.elements;
				const projR = cameraR.projectionMatrix.elements;

				// VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.
				const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
				const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
				const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
				const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

				const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
				const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
				const left = near * leftFov;
				const right = near * rightFov;

				// Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.
				const zOffset = ipd / ( - leftFov + rightFov );
				const xOffset = zOffset * - leftFov;

				// TODO: Better way to apply this offset?
				cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
				camera.translateX( xOffset );
				camera.translateZ( zOffset );
				camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
				camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

				// Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.
				const near2 = near + zOffset;
				const far2 = far + zOffset;
				const left2 = left - xOffset;
				const right2 = right + ( ipd - xOffset );
				const top2 = topFov * far / far2 * near2;
				const bottom2 = bottomFov * far / far2 * near2;

				camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

			}

			function updateCamera( camera, parent ) {

				if ( parent === null ) {

					camera.matrixWorld.copy( camera.matrix );

				} else {

					camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

				}

				camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			}

			this.updateCamera = function ( camera ) {

				if ( session === null ) return;

				cameraVR.near = cameraR.near = cameraL.near = camera.near;
				cameraVR.far = cameraR.far = cameraL.far = camera.far;

				if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

					// Note that the new renderState won't apply until the next frame. See #18320

					session.updateRenderState( {
						depthNear: cameraVR.near,
						depthFar: cameraVR.far
					} );

					_currentDepthNear = cameraVR.near;
					_currentDepthFar = cameraVR.far;

				}

				const parent = camera.parent;
				const cameras = cameraVR.cameras;

				updateCamera( cameraVR, parent );

				for ( let i = 0; i < cameras.length; i ++ ) {

					updateCamera( cameras[ i ], parent );

				}

				cameraVR.matrixWorld.decompose( cameraVR.position, cameraVR.quaternion, cameraVR.scale );

				// update user camera and its children

				camera.position.copy( cameraVR.position );
				camera.quaternion.copy( cameraVR.quaternion );
				camera.scale.copy( cameraVR.scale );
				camera.matrix.copy( cameraVR.matrix );
				camera.matrixWorld.copy( cameraVR.matrixWorld );

				const children = camera.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateMatrixWorld( true );

				}

				// update projection matrix for proper view frustum culling

				if ( cameras.length === 2 ) {

					setProjectionFromUnion( cameraVR, cameraL, cameraR );

				} else {

					// assume single camera setup (AR)

					cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

				}

			};

			this.getCamera = function () {

				return cameraVR;

			};

			this.getFoveation = function () {

				if ( glProjLayer !== null ) {

					return glProjLayer.fixedFoveation;

				}

				if ( glBaseLayer !== null ) {

					return glBaseLayer.fixedFoveation;

				}

				return undefined;

			};

			this.setFoveation = function ( foveation ) {

				// 0 = no foveation = full resolution
				// 1 = maximum foveation = the edges render at lower resolution

				if ( glProjLayer !== null ) {

					glProjLayer.fixedFoveation = foveation;

				}

				if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

					glBaseLayer.fixedFoveation = foveation;

				}

			};

			// Animation Loop

			let onAnimationFrameCallback = null;

			function onAnimationFrame( time, frame ) {

				pose = frame.getViewerPose( referenceSpace );
				xrFrame = frame;

				if ( pose !== null ) {

					const views = pose.views;

					if ( glBaseLayer !== null ) {

						renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
						renderer.setRenderTarget( newRenderTarget );

					}

					let cameraVRNeedsUpdate = false;

					// check if it's necessary to rebuild cameraVR's camera list

					if ( views.length !== cameraVR.cameras.length ) {

						cameraVR.cameras.length = 0;
						cameraVRNeedsUpdate = true;

					}

					for ( let i = 0; i < views.length; i ++ ) {

						const view = views[ i ];

						let viewport = null;

						if ( glBaseLayer !== null ) {

							viewport = glBaseLayer.getViewport( view );

						} else {

							const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
							viewport = glSubImage.viewport;

							// For side-by-side projection, we only produce a single texture for both eyes.
							if ( i === 0 ) {

								renderer.setRenderTargetTextures(
									newRenderTarget,
									glSubImage.colorTexture,
									glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );

								renderer.setRenderTarget( newRenderTarget );

							}

						}

						const camera = cameras[ i ];

						camera.matrix.fromArray( view.transform.matrix );
						camera.projectionMatrix.fromArray( view.projectionMatrix );
						camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

						if ( i === 0 ) {

							cameraVR.matrix.copy( camera.matrix );

						}

						if ( cameraVRNeedsUpdate === true ) {

							cameraVR.cameras.push( camera );

						}

					}

				}

				//

				const inputSources = session.inputSources;

				for ( let i = 0; i < controllers.length; i ++ ) {

					const controller = controllers[ i ];
					const inputSource = inputSources[ i ];

					controller.update( inputSource, frame, referenceSpace );

				}

				if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

				xrFrame = null;

			}

			const animation = new WebGLAnimation();

			animation.setAnimationLoop( onAnimationFrame );

			this.setAnimationLoop = function ( callback ) {

				onAnimationFrameCallback = callback;

			};

			this.dispose = function () {};

		}

	}

	function WebGLMaterials( renderer, properties ) {

		function refreshFogUniforms( uniforms, fog ) {

			uniforms.fogColor.value.copy( fog.color );

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

			if ( material.isMeshBasicMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshToonMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsToon( uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsPhong( uniforms, material );

			} else if ( material.isMeshStandardMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsStandard( uniforms, material );

				if ( material.isMeshPhysicalMaterial ) {

					refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

				}

			} else if ( material.isMeshMatcapMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsMatcap( uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshDistanceMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsDistance( uniforms, material );

			} else if ( material.isMeshNormalMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( uniforms, material );

				if ( material.isLineDashedMaterial ) {

					refreshUniformsDash( uniforms, material );

				}

			} else if ( material.isPointsMaterial ) {

				refreshUniformsPoints( uniforms, material, pixelRatio, height );

			} else if ( material.isSpriteMaterial ) {

				refreshUniformsSprites( uniforms, material );

			} else if ( material.isShadowMaterial ) {

				uniforms.color.value.copy( material.color );
				uniforms.opacity.value = material.opacity;

			} else if ( material.isShaderMaterial ) {

				material.uniformsNeedUpdate = false; // #15581

			}

		}

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value.copy( material.color );

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

			const envMap = properties.get( material ).envMap;

			if ( envMap ) {

				uniforms.envMap.value = envMap;

				uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.ior.value = material.ior;
				uniforms.refractionRatio.value = material.refractionRatio;

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;

				// artist-friendly light intensity scaling factor
				const scaleFactor = ( renderer.physicallyCorrectLights !== true ) ? Math.PI : 1;

				uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map
			// 13. specular intensity map
			// 14. specular tint map
			// 15. transmission map
			// 16. thickness map

			let uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.roughnessMap ) {

				uvScaleMap = material.roughnessMap;

			} else if ( material.metalnessMap ) {

				uvScaleMap = material.metalnessMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			} else if ( material.clearcoatMap ) {

				uvScaleMap = material.clearcoatMap;

			} else if ( material.clearcoatNormalMap ) {

				uvScaleMap = material.clearcoatNormalMap;

			} else if ( material.clearcoatRoughnessMap ) {

				uvScaleMap = material.clearcoatRoughnessMap;

			} else if ( material.specularIntensityMap ) {

				uvScaleMap = material.specularIntensityMap;

			} else if ( material.specularColorMap ) {

				uvScaleMap = material.specularColorMap;

			} else if ( material.transmissionMap ) {

				uvScaleMap = material.transmissionMap;

			} else if ( material.thicknessMap ) {

				uvScaleMap = material.thicknessMap;

			} else if ( material.sheenColorMap ) {

				uvScaleMap = material.sheenColorMap;

			} else if ( material.sheenRoughnessMap ) {

				uvScaleMap = material.sheenRoughnessMap;

			}

			if ( uvScaleMap !== undefined ) {

				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {

					uvScaleMap = uvScaleMap.texture;

				}

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

			// uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map

			let uv2ScaleMap;

			if ( material.aoMap ) {

				uv2ScaleMap = material.aoMap;

			} else if ( material.lightMap ) {

				uv2ScaleMap = material.lightMap;

			}

			if ( uv2ScaleMap !== undefined ) {

				// backwards compatibility
				if ( uv2ScaleMap.isWebGLRenderTarget ) {

					uv2ScaleMap = uv2ScaleMap.texture;

				}

				if ( uv2ScaleMap.matrixAutoUpdate === true ) {

					uv2ScaleMap.updateMatrix();

				}

				uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			let uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsSprites( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			let uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value.copy( material.specular );
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		}

		function refreshUniformsToon( uniforms, material ) {

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

			}

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

			}

			const envMap = properties.get( material ).envMap;

			if ( envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

			uniforms.ior.value = material.ior; // also part of uniforms common

			if ( material.sheen > 0 ) {

				uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

				uniforms.sheenRoughness.value = material.sheenRoughness;

				if ( material.sheenColorMap ) {

					uniforms.sheenColorMap.value = material.sheenColorMap;

				}

				if ( material.sheenRoughnessMap ) {

					uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

				}

			}

			if ( material.clearcoat > 0 ) {

				uniforms.clearcoat.value = material.clearcoat;
				uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

				if ( material.clearcoatMap ) {

					uniforms.clearcoatMap.value = material.clearcoatMap;

				}

				if ( material.clearcoatRoughnessMap ) {

					uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

				}

				if ( material.clearcoatNormalMap ) {

					uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
					uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

					if ( material.side === BackSide ) {

						uniforms.clearcoatNormalScale.value.negate();

					}

				}

			}

			if ( material.transmission > 0 ) {

				uniforms.transmission.value = material.transmission;
				uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
				uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

				if ( material.transmissionMap ) {

					uniforms.transmissionMap.value = material.transmissionMap;

				}

				uniforms.thickness.value = material.thickness;

				if ( material.thicknessMap ) {

					uniforms.thicknessMap.value = material.thicknessMap;

				}

				uniforms.attenuationDistance.value = material.attenuationDistance;
				uniforms.attenuationColor.value.copy( material.attenuationColor );

			}

			uniforms.specularIntensity.value = material.specularIntensity;
			uniforms.specularColor.value.copy( material.specularColor );

			if ( material.specularIntensityMap ) {

				uniforms.specularIntensityMap.value = material.specularIntensityMap;

			}

			if ( material.specularColorMap ) {

				uniforms.specularColorMap.value = material.specularColorMap;

			}

		}

		function refreshUniformsMatcap( uniforms, material ) {

			if ( material.matcap ) {

				uniforms.matcap.value = material.matcap;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			uniforms.referencePosition.value.copy( material.referencePosition );
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;

		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};

	}

	function createCanvasElement() {

		const canvas = createElementNS( 'canvas' );
		canvas.style.display = 'block';
		return canvas;

	}

	function WebGLRenderer( parameters = {} ) {

		const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
			_context = parameters.context !== undefined ? parameters.context : null,

			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
			_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

		let _alpha;

		if ( parameters.context !== undefined ) {

			_alpha = _context.getContextAttributes().alpha;

		} else {

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false;

		}

		let currentRenderList = null;
		let currentRenderState = null;

		// render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		const renderListStack = [];
		const renderStateStack = [];

		// public properties

		this.domElement = _canvas;

		// Debug configuration container
		this.debug = {

			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		};

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.outputEncoding = LinearEncoding;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0;

		// internal properties

		const _this = this;

		let _isContextLost = false;

		// internal state cache

		let _currentActiveCubeFace = 0;
		let _currentActiveMipmapLevel = 0;
		let _currentRenderTarget = null;
		let _currentMaterialId = - 1;

		let _currentCamera = null;

		const _currentViewport = new Vector4();
		const _currentScissor = new Vector4();
		let _currentScissorTest = null;

		//

		let _width = _canvas.width;
		let _height = _canvas.height;

		let _pixelRatio = 1;
		let _opaqueSort = null;
		let _transparentSort = null;

		const _viewport = new Vector4( 0, 0, _width, _height );
		const _scissor = new Vector4( 0, 0, _width, _height );
		let _scissorTest = false;

		// frustum

		const _frustum = new Frustum();

		// clipping

		let _clippingEnabled = false;
		let _localClippingEnabled = false;

		// transmission

		let _transmissionRenderTarget = null;

		// camera matrices cache

		const _projScreenMatrix = new Matrix4();

		const _vector2 = new Vector2();
		const _vector3 = new Vector3();

		const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		let _gl = _context;

		function getContext( contextNames, contextAttributes ) {

			for ( let i = 0; i < contextNames.length; i ++ ) {

				const contextName = contextNames[ i ];
				const context = _canvas.getContext( contextName, contextAttributes );
				if ( context !== null ) return context;

			}

			return null;

		}

		try {

			const contextAttributes = {
				alpha: true,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			};

			// OffscreenCanvas does not have setAttribute, see #22811
			if ( 'setAttribute' in _canvas ) _canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

			// event listeners must be registered before WebGL context is created, see #12753
			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

			if ( _gl === null ) {

				const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

				if ( _this.isWebGL1Renderer === true ) {

					contextNames.shift();

				}

				_gl = getContext( contextNames, contextAttributes );

				if ( _gl === null ) {

					if ( getContext( contextNames ) ) {

						throw new Error( 'Error creating WebGL context with your selected attributes.' );

					} else {

						throw new Error( 'Error creating WebGL context.' );

					}

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if ( _gl.getShaderPrecisionFormat === undefined ) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

				};

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );
			throw error;

		}

		let extensions, capabilities, state, info;
		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
		let programCache, materials, renderLists, renderStates, clipping, shadowMap;

		let background, morphtargets, bufferRenderer, indexedBufferRenderer;

		let utils, bindingStates;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			extensions.init( capabilities );

			utils = new WebGLUtils( _gl, extensions, capabilities );

			state = new WebGLState( _gl, extensions, capabilities );

			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			cubemaps = new WebGLCubeMaps( _this );
			cubeuvmaps = new WebGLCubeUVMaps( _this );
			attributes = new WebGLAttributes( _gl, capabilities );
			bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
			geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
			objects = new WebGLObjects( _gl, geometries, attributes, info );
			morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
			clipping = new WebGLClipping( properties );
			programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
			materials = new WebGLMaterials( _this, properties );
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates( extensions, capabilities );
			background = new WebGLBackground( _this, cubemaps, state, objects, _alpha, _premultipliedAlpha );
			shadowMap = new WebGLShadowMap( _this, objects, capabilities );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

			info.programs = programCache.programs;

			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.shadowMap = shadowMap;
			_this.state = state;
			_this.info = info;

		}

		initGLContext();

		// xr

		const xr = new WebXRManager( _this, _gl );

		this.xr = xr;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		this.forceContextRestore = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function ( target ) {

			return target.set( _width, _height );

		};

		this.setSize = function ( width, height, updateStyle ) {

			if ( xr.isPresenting ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			_canvas.width = Math.floor( width * _pixelRatio );
			_canvas.height = Math.floor( height * _pixelRatio );

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function ( target ) {

			return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			_canvas.width = Math.floor( width * pixelRatio );
			_canvas.height = Math.floor( height * pixelRatio );

			this.setViewport( 0, 0, width, height );

		};

		this.getCurrentViewport = function ( target ) {

			return target.copy( _currentViewport );

		};

		this.getViewport = function ( target ) {

			return target.copy( _viewport );

		};

		this.setViewport = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_viewport.set( x.x, x.y, x.z, x.w );

			} else {

				_viewport.set( x, y, width, height );

			}

			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

		};

		this.getScissor = function ( target ) {

			return target.copy( _scissor );

		};

		this.setScissor = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_scissor.set( x.x, x.y, x.z, x.w );

			} else {

				_scissor.set( x, y, width, height );

			}

			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

		};

		this.getScissorTest = function () {

			return _scissorTest;

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		this.setOpaqueSort = function ( method ) {

			_opaqueSort = method;

		};

		this.setTransparentSort = function ( method ) {

			_transparentSort = method;

		};

		// Clearing

		this.getClearColor = function ( target ) {

			return target.copy( background.getClearColor() );

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color = true, depth = true, stencil = true ) {

			let bits = 0;

			if ( color ) bits |= 16384;
			if ( depth ) bits |= 256;
			if ( stencil ) bits |= 1024;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		//

		this.dispose = function () {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			cubeuvmaps.dispose();
			objects.dispose();
			bindingStates.dispose();
			programCache.dispose();

			xr.dispose();

			xr.removeEventListener( 'sessionstart', onXRSessionStart );
			xr.removeEventListener( 'sessionend', onXRSessionEnd );

			if ( _transmissionRenderTarget ) {

				_transmissionRenderTarget.dispose();
				_transmissionRenderTarget = null;

			}

			animation.stop();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			const infoAutoReset = info.autoReset;
			const shadowMapEnabled = shadowMap.enabled;
			const shadowMapAutoUpdate = shadowMap.autoUpdate;
			const shadowMapNeedsUpdate = shadowMap.needsUpdate;
			const shadowMapType = shadowMap.type;

			initGLContext();

			info.autoReset = infoAutoReset;
			shadowMap.enabled = shadowMapEnabled;
			shadowMap.autoUpdate = shadowMapAutoUpdate;
			shadowMap.needsUpdate = shadowMapNeedsUpdate;
			shadowMap.type = shadowMapType;

		}

		function onMaterialDispose( event ) {

			const material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReferences( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReferences( material ) {

			const programs = properties.get( material ).programs;

			if ( programs !== undefined ) {

				programs.forEach( function ( program ) {

					programCache.releaseProgram( program );

				} );

				if ( material.isShaderMaterial ) {

					programCache.releaseShaderCache( material );

				}

			}

		}

		// Buffer rendering

		this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

			if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

			const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			const program = setProgram( camera, scene, geometry, material, object );

			state.setMaterial( material, frontFaceCW );

			//

			let index = geometry.index;
			const position = geometry.attributes.position;

			//

			if ( index === null ) {

				if ( position === undefined || position.count === 0 ) return;

			} else if ( index.count === 0 ) {

				return;

			}

			//

			let rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;

			}

			bindingStates.setup( object, material, program, geometry, index );

			let attribute;
			let renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			//

			const dataCount = ( index !== null ) ? index.count : position.count;

			const rangeStart = geometry.drawRange.start * rangeFactor;
			const rangeCount = geometry.drawRange.count * rangeFactor;

			const groupStart = group !== null ? group.start * rangeFactor : 0;
			const groupCount = group !== null ? group.count * rangeFactor : Infinity;

			const drawStart = Math.max( rangeStart, groupStart );
			const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

			const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

			if ( drawCount === 0 ) return;

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( 1 );

				} else {

					renderer.setMode( 4 );

				}

			} else if ( object.isLine ) {

				let lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( 1 );

				} else if ( object.isLineLoop ) {

					renderer.setMode( 2 );

				} else {

					renderer.setMode( 3 );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( 0 );

			} else if ( object.isSprite ) {

				renderer.setMode( 4 );

			}

			if ( object.isInstancedMesh ) {

				renderer.renderInstances( drawStart, drawCount, object.count );

			} else if ( geometry.isInstancedBufferGeometry ) {

				const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

				renderer.renderInstances( drawStart, drawCount, instanceCount );

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		// Compile

		this.compile = function ( scene, camera ) {

			currentRenderState = renderStates.get( scene );
			currentRenderState.init();

			renderStateStack.push( currentRenderState );

			scene.traverseVisible( function ( object ) {

				if ( object.isLight && object.layers.test( camera.layers ) ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				}

			} );

			currentRenderState.setupLights( _this.physicallyCorrectLights );

			scene.traverse( function ( object ) {

				const material = object.material;

				if ( material ) {

					if ( Array.isArray( material ) ) {

						for ( let i = 0; i < material.length; i ++ ) {

							const material2 = material[ i ];

							getProgram( material2, scene, object );

						}

					} else {

						getProgram( material, scene, object );

					}

				}

			} );

			renderStateStack.pop();
			currentRenderState = null;

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time ) {

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		function onXRSessionStart() {

			animation.stop();

		}

		function onXRSessionEnd() {

			animation.start();

		}

		const animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		if ( typeof self !== 'undefined' ) animation.setContext( self );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;
			xr.setAnimationLoop( callback );

			( callback === null ) ? animation.stop() : animation.start();

		};

		xr.addEventListener( 'sessionstart', onXRSessionStart );
		xr.addEventListener( 'sessionend', onXRSessionEnd );

		// Rendering

		this.render = function ( scene, camera ) {

			if ( camera !== undefined && camera.isCamera !== true ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost === true ) return;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			if ( xr.enabled === true && xr.isPresenting === true ) {

				if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

				camera = xr.getCamera(); // use XR camera for rendering

			}

			//
			if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

			currentRenderState = renderStates.get( scene, renderStateStack.length );
			currentRenderState.init();

			renderStateStack.push( currentRenderState );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromProjectionMatrix( _projScreenMatrix );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

			currentRenderList = renderLists.get( scene, renderListStack.length );
			currentRenderList.init();

			renderListStack.push( currentRenderList );

			projectObject( scene, camera, 0, _this.sortObjects );

			currentRenderList.finish();

			if ( _this.sortObjects === true ) {

				currentRenderList.sort( _opaqueSort, _transparentSort );

			}

			//

			if ( _clippingEnabled === true ) clipping.beginShadows();

			const shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			if ( _clippingEnabled === true ) clipping.endShadows();

			//

			if ( this.info.autoReset === true ) this.info.reset();

			//

			background.render( currentRenderList, scene );

			// render scene

			currentRenderState.setupLights( _this.physicallyCorrectLights );

			if ( camera.isArrayCamera ) {

				const cameras = camera.cameras;

				for ( let i = 0, l = cameras.length; i < l; i ++ ) {

					const camera2 = cameras[ i ];

					renderScene( currentRenderList, scene, camera2, camera2.viewport );

				}

			} else {

				renderScene( currentRenderList, scene, camera );

			}

			//

			if ( _currentRenderTarget !== null ) {

				// resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget( _currentRenderTarget );

				// Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap( _currentRenderTarget );

			}

			//

			if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

			// _gl.finish();

			bindingStates.resetDefaultState();
			_currentMaterialId = - 1;
			_currentCamera = null;

			renderStateStack.pop();

			if ( renderStateStack.length > 0 ) {

				currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

			} else {

				currentRenderState = null;

			}

			renderListStack.pop();

			if ( renderListStack.length > 0 ) {

				currentRenderList = renderListStack[ renderListStack.length - 1 ];

			} else {

				currentRenderList = null;

			}

		};

		function projectObject( object, camera, groupOrder, sortObjects ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isGroup ) {

					groupOrder = object.renderOrder;

				} else if ( object.isLOD ) {

					if ( object.autoUpdate === true ) object.update( camera );

				} else if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						const geometry = objects.update( object );
						const material = object.material;

						if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( object.isSkinnedMesh ) {

						// update skeleton only once in a frame

						if ( object.skeleton.frame !== info.render.frame ) {

							object.skeleton.update();
							object.skeleton.frame = info.render.frame;

						}

					}

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						const geometry = objects.update( object );
						const material = object.material;

						if ( Array.isArray( material ) ) {

							const groups = geometry.groups;

							for ( let i = 0, l = groups.length; i < l; i ++ ) {

								const group = groups[ i ];
								const groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, groupOrder, sortObjects );

			}

		}

		function renderScene( currentRenderList, scene, camera, viewport ) {

			const opaqueObjects = currentRenderList.opaque;
			const transmissiveObjects = currentRenderList.transmissive;
			const transparentObjects = currentRenderList.transparent;

			currentRenderState.setupLightsView( camera );

			if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, scene, camera );

			if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

			if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
			if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
			if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

		}

		function renderTransmissionPass( opaqueObjects, scene, camera ) {

			const isWebGL2 = capabilities.isWebGL2;

			if ( _transmissionRenderTarget === null ) {

				_transmissionRenderTarget = new WebGLRenderTarget( 1, 1, {
					generateMipmaps: true,
					type: utils.convert( HalfFloatType ) !== null ? HalfFloatType : UnsignedByteType,
					minFilter: LinearMipmapLinearFilter,
					samples: ( isWebGL2 && _antialias === true ) ? 4 : 0
				} );

			}

			_this.getDrawingBufferSize( _vector2 );

			if ( isWebGL2 ) {

				_transmissionRenderTarget.setSize( _vector2.x, _vector2.y );

			} else {

				_transmissionRenderTarget.setSize( floorPowerOfTwo( _vector2.x ), floorPowerOfTwo( _vector2.y ) );

			}

			//

			const currentRenderTarget = _this.getRenderTarget();
			_this.setRenderTarget( _transmissionRenderTarget );
			_this.clear();

			// Turn off the features which can affect the frag color for opaque objects pass.
			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
			const currentToneMapping = _this.toneMapping;
			_this.toneMapping = NoToneMapping;

			renderObjects( opaqueObjects, scene, camera );

			_this.toneMapping = currentToneMapping;

			textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
			textures.updateRenderTargetMipmap( _transmissionRenderTarget );

			_this.setRenderTarget( currentRenderTarget );

		}

		function renderObjects( renderList, scene, camera ) {

			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			for ( let i = 0, l = renderList.length; i < l; i ++ ) {

				const renderItem = renderList[ i ];

				const object = renderItem.object;
				const geometry = renderItem.geometry;
				const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
				const group = renderItem.group;

				if ( object.layers.test( camera.layers ) ) {

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			material.onBeforeRender( _this, scene, camera, geometry, object, group );

			if ( material.transparent === true && material.side === DoubleSide ) {

				material.side = BackSide;
				material.needsUpdate = true;
				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				material.side = FrontSide;
				material.needsUpdate = true;
				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				material.side = DoubleSide;

			} else {

				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );

		}

		function getProgram( material, scene, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			const materialProperties = properties.get( material );

			const lights = currentRenderState.state.lights;
			const shadowsArray = currentRenderState.state.shadowsArray;

			const lightsStateVersion = lights.state.version;

			const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
			const programCacheKey = programCache.getProgramCacheKey( parameters );

			let programs = materialProperties.programs;

			// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );

			if ( programs === undefined ) {

				// new material

				material.addEventListener( 'dispose', onMaterialDispose );

				programs = new Map();
				materialProperties.programs = programs;

			}

			let program = programs.get( programCacheKey );

			if ( program !== undefined ) {

				// early out if program and light state is identical

				if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

					updateCommonMaterialProperties( material, parameters );

					return program;

				}

			} else {

				parameters.uniforms = programCache.getUniforms( material );

				material.onBuild( object, parameters, _this );

				material.onBeforeCompile( parameters, _this );

				program = programCache.acquireProgram( parameters, programCacheKey );
				programs.set( programCacheKey, program );

				materialProperties.uniforms = parameters.uniforms;

			}

			const uniforms = materialProperties.uniforms;

			if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

				uniforms.clippingPlanes = clipping.uniform;

			}

			updateCommonMaterialProperties( material, parameters );

			// store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights( material );
			materialProperties.lightsStateVersion = lightsStateVersion;

			if ( materialProperties.needsLights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			const progUniforms = program.getUniforms();
			const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

			materialProperties.currentProgram = program;
			materialProperties.uniformsList = uniformsList;

			return program;

		}

		function updateCommonMaterialProperties( material, parameters ) {

			const materialProperties = properties.get( material );

			materialProperties.outputEncoding = parameters.outputEncoding;
			materialProperties.instancing = parameters.instancing;
			materialProperties.skinning = parameters.skinning;
			materialProperties.morphTargets = parameters.morphTargets;
			materialProperties.morphNormals = parameters.morphNormals;
			materialProperties.morphColors = parameters.morphColors;
			materialProperties.morphTargetsCount = parameters.morphTargetsCount;
			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
			materialProperties.numIntersection = parameters.numClipIntersection;
			materialProperties.vertexAlphas = parameters.vertexAlphas;
			materialProperties.vertexTangents = parameters.vertexTangents;
			materialProperties.toneMapping = parameters.toneMapping;

		}

		function setProgram( camera, scene, geometry, material, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();

			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding );
			const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
			const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
			const vertexTangents = !! material.normalMap && !! geometry.attributes.tangent;
			const morphTargets = !! geometry.morphAttributes.position;
			const morphNormals = !! geometry.morphAttributes.normal;
			const morphColors = !! geometry.morphAttributes.color;
			const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			const materialProperties = properties.get( material );
			const lights = currentRenderState.state.lights;

			if ( _clippingEnabled === true ) {

				if ( _localClippingEnabled === true || camera !== _currentCamera ) {

					const useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					clipping.setState( material, camera, useCache );

				}

			}

			//

			let needsProgramChange = false;

			if ( material.version === materialProperties.__version ) {

				if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

					needsProgramChange = true;

				} else if ( materialProperties.outputEncoding !== encoding ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

					needsProgramChange = true;

				} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

					needsProgramChange = true;

				} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

					needsProgramChange = true;

				} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

					needsProgramChange = true;

				} else if ( materialProperties.envMap !== envMap ) {

					needsProgramChange = true;

				} else if ( material.fog && materialProperties.fog !== fog ) {

					needsProgramChange = true;

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== clipping.numPlanes ||
					materialProperties.numIntersection !== clipping.numIntersection ) ) {

					needsProgramChange = true;

				} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

					needsProgramChange = true;

				} else if ( materialProperties.vertexTangents !== vertexTangents ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphTargets !== morphTargets ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphNormals !== morphNormals ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphColors !== morphColors ) {

					needsProgramChange = true;

				} else if ( materialProperties.toneMapping !== toneMapping ) {

					needsProgramChange = true;

				} else if ( capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount ) {

					needsProgramChange = true;

				}

			} else {

				needsProgramChange = true;
				materialProperties.__version = material.version;

			}

			//

			let program = materialProperties.currentProgram;

			if ( needsProgramChange === true ) {

				program = getProgram( material, scene, object );

			}

			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;

			const p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || _currentCamera !== camera ) {

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				if ( _currentCamera !== camera ) {

					_currentCamera = camera;

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap ) {

					const uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ) {

					p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.isShadowMaterial ||
					object.isSkinnedMesh ) {

					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				}

			}

			// skinning and morph target uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone and morph texture must go before other textures
			// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

			if ( object.isSkinnedMesh ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				const skeleton = object.skeleton;

				if ( skeleton ) {

					if ( capabilities.floatVertexTextures ) {

						if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

					} else {

						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

					}

				}

			}

			const morphAttributes = geometry.morphAttributes;

			if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined && capabilities.isWebGL2 === true ) ) {

				morphtargets.update( object, geometry, material, program );

			}


			if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

				if ( materialProperties.needsLights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					materials.refreshFogUniforms( m_uniforms, fog );

				}

				materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

			}

			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
				material.uniformsNeedUpdate = false;

			}

			if ( material.isSpriteMaterial ) {

				p_uniforms.setValue( _gl, 'center', object.center );

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			return program;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		function materialNeedsLights( material ) {

			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial || material.isShadowMaterial ||
				( material.isShaderMaterial && material.lights === true );

		}

		this.getActiveCubeFace = function () {

			return _currentActiveCubeFace;

		};

		this.getActiveMipmapLevel = function () {

			return _currentActiveMipmapLevel;

		};

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

			properties.get( renderTarget.texture ).__webglTexture = colorTexture;
			properties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;

			const renderTargetProperties = properties.get( renderTarget );
			renderTargetProperties.__hasExternalTextures = true;

			if ( renderTargetProperties.__hasExternalTextures ) {

				renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;

				if ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {

					// The multisample_render_to_texture extension doesn't work properly if there
					// are midframe flushes and an external depth buffer. Disable use of the extension.
					if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {

						console.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );
						renderTargetProperties.__useRenderToTexture = false;

					}

				}

			}

		};

		this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

			const renderTargetProperties = properties.get( renderTarget );
			renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
			renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

		};

		this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			let useDefaultFramebuffer = true;

			if ( renderTarget ) {

				const renderTargetProperties = properties.get( renderTarget );

				if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

					// We need to make sure to rebind the framebuffer.
					state.bindFramebuffer( 36160, null );
					useDefaultFramebuffer = false;

				} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

					textures.setupRenderTarget( renderTarget );

				} else if ( renderTargetProperties.__hasExternalTextures ) {

					// Color and depth texture must be rebound in order for the swapchain to update.
					textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

				}

			}

			let framebuffer = null;
			let isCube = false;
			let isRenderTarget3D = false;

			if ( renderTarget ) {

				const texture = renderTarget.texture;

				if ( texture.isData3DTexture || texture.isDataArrayTexture ) {

					isRenderTarget3D = true;

				}

				const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLCubeRenderTarget ) {

					framebuffer = __webglFramebuffer[ activeCubeFace ];
					isCube = true;

				} else if ( ( capabilities.isWebGL2 && renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

				} else {

					framebuffer = __webglFramebuffer;

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
				_currentScissorTest = _scissorTest;

			}

			const framebufferBound = state.bindFramebuffer( 36160, framebuffer );

			if ( framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer ) {

				state.drawBuffers( renderTarget, framebuffer );

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				const textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

			} else if ( isRenderTarget3D ) {

				const textureProperties = properties.get( renderTarget.texture );
				const layer = activeCubeFace || 0;
				_gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

			}

			_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

				framebuffer = framebuffer[ activeCubeFaceIndex ];

			}

			if ( framebuffer ) {

				state.bindFramebuffer( 36160, framebuffer );

				try {

					const texture = renderTarget.texture;
					const textureFormat = texture.format;
					const textureType = texture.type;

					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
						! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						! halfFloatSupportedByExt ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					}

				} finally {

					// restore framebuffer of current render target if necessary

					const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
					state.bindFramebuffer( 36160, framebuffer );

				}

			}

		};

		this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

			if ( texture.isFramebufferTexture !== true ) {

				console.error( 'THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.' );
				return;

			}

			const levelScale = Math.pow( 2, - level );
			const width = Math.floor( texture.image.width * levelScale );
			const height = Math.floor( texture.image.height * levelScale );

			textures.setTexture2D( texture, 0 );

			_gl.copyTexSubImage2D( 3553, level, 0, 0, position.x, position.y, width, height );

			state.unbindTexture();

		};

		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

			const width = srcTexture.image.width;
			const height = srcTexture.image.height;
			const glFormat = utils.convert( dstTexture.format );
			const glType = utils.convert( dstTexture.type );

			textures.setTexture2D( dstTexture, 0 );

			// As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture
			_gl.pixelStorei( 37440, dstTexture.flipY );
			_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

			if ( srcTexture.isDataTexture ) {

				_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

			} else {

				if ( srcTexture.isCompressedTexture ) {

					_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

				} else {

					_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

				}

			}

			// Generate mipmaps only when copying level 0
			if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

			state.unbindTexture();

		};

		this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

			if ( _this.isWebGL1Renderer ) {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
				return;

			}

			const width = sourceBox.max.x - sourceBox.min.x + 1;
			const height = sourceBox.max.y - sourceBox.min.y + 1;
			const depth = sourceBox.max.z - sourceBox.min.z + 1;
			const glFormat = utils.convert( dstTexture.format );
			const glType = utils.convert( dstTexture.type );
			let glTarget;

			if ( dstTexture.isData3DTexture ) {

				textures.setTexture3D( dstTexture, 0 );
				glTarget = 32879;

			} else if ( dstTexture.isDataArrayTexture ) {

				textures.setTexture2DArray( dstTexture, 0 );
				glTarget = 35866;

			} else {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
				return;

			}

			_gl.pixelStorei( 37440, dstTexture.flipY );
			_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

			const unpackRowLen = _gl.getParameter( 3314 );
			const unpackImageHeight = _gl.getParameter( 32878 );
			const unpackSkipPixels = _gl.getParameter( 3316 );
			const unpackSkipRows = _gl.getParameter( 3315 );
			const unpackSkipImages = _gl.getParameter( 32877 );

			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;

			_gl.pixelStorei( 3314, image.width );
			_gl.pixelStorei( 32878, image.height );
			_gl.pixelStorei( 3316, sourceBox.min.x );
			_gl.pixelStorei( 3315, sourceBox.min.y );
			_gl.pixelStorei( 32877, sourceBox.min.z );

			if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

				_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );

			} else {

				if ( srcTexture.isCompressedTexture ) {

					console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );
					_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );

				} else {

					_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );

				}

			}

			_gl.pixelStorei( 3314, unpackRowLen );
			_gl.pixelStorei( 32878, unpackImageHeight );
			_gl.pixelStorei( 3316, unpackSkipPixels );
			_gl.pixelStorei( 3315, unpackSkipRows );
			_gl.pixelStorei( 32877, unpackSkipImages );

			// Generate mipmaps only when copying level 0
			if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

			state.unbindTexture();

		};

		this.initTexture = function ( texture ) {

			textures.setTexture2D( texture, 0 );

			state.unbindTexture();

		};

		this.resetState = function () {

			_currentActiveCubeFace = 0;
			_currentActiveMipmapLevel = 0;
			_currentRenderTarget = null;

			state.reset();
			bindingStates.reset();

		};

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

		}

	}

	WebGLRenderer.prototype.isWebGLRenderer = true;

	class WebGL1Renderer extends WebGLRenderer {}

	WebGL1Renderer.prototype.isWebGL1Renderer = true;

	class Scene extends Object3D {

		constructor() {

			super();

			this.type = 'Scene';

			this.background = null;
			this.environment = null;
			this.fog = null;

			this.overrideMaterial = null;

			this.autoUpdate = true; // checked by the renderer

			if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

				__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

			}

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.environment !== null ) this.environment = source.environment.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();

			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		}

	}

	Scene.prototype.isScene = true;

	class InterleavedBuffer {

		constructor( array, stride ) {

			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;

			this.usage = StaticDrawUsage;
			this.updateRange = { offset: 0, count: - 1 };

			this.version = 0;

			this.uuid = generateUUID();

		}

		onUploadCallback() {}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		setUsage( value ) {

			this.usage = value;

			return this;

		}

		copy( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;

			return this;

		}

		copyAt( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( let i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		}

		set( value, offset = 0 ) {

			this.array.set( value, offset );

			return this;

		}

		clone( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = generateUUID();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

			}

			const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

			const ib = new this.constructor( array, this.stride );
			ib.setUsage( this.usage );

			return ib;

		}

		onUpload( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

		toJSON( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			// generate UUID for array buffer if necessary

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = generateUUID();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

			}

			//

			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};

		}

	}

	InterleavedBuffer.prototype.isInterleavedBuffer = true;

	const _vector$6 = /*@__PURE__*/ new Vector3();

	class InterleavedBufferAttribute {

		constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

			this.name = '';

			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;

			this.normalized = normalized === true;

		}

		get count() {

			return this.data.count;

		}

		get array() {

			return this.data.array;

		}

		set needsUpdate( value ) {

			this.data.needsUpdate = value;

		}

		applyMatrix4( m ) {

			for ( let i = 0, l = this.data.count; i < l; i ++ ) {

				_vector$6.fromBufferAttribute( this, i );

				_vector$6.applyMatrix4( m );

				this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

			}

			return this;

		}

		applyNormalMatrix( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$6.fromBufferAttribute( this, i );

				_vector$6.applyNormalMatrix( m );

				this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

			}

			return this;

		}

		transformDirection( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$6.fromBufferAttribute( this, i );

				_vector$6.transformDirection( m );

				this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

			}

			return this;

		}

		setX( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		}

		setY( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		}

		setZ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		}

		setW( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		}

		getX( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		}

		getY( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		}

		getZ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		}

		getW( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		}

		setXY( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		}

		setXYZ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		}

		setXYZW( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

		clone( data ) {

			if ( data === undefined ) {

				console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

				const array = [];

				for ( let i = 0; i < this.count; i ++ ) {

					const index = i * this.data.stride + this.offset;

					for ( let j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

			} else {

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

				}

				return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

			}

		}

		toJSON( data ) {

			if ( data === undefined ) {

				console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

				const array = [];

				for ( let i = 0; i < this.count; i ++ ) {

					const index = i * this.data.stride + this.offset;

					for ( let j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				// deinterleave data and save it as an ordinary buffer attribute for now

				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};

			} else {

				// save as true interlaved attribtue

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};

			}

		}

	}

	InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;

	class SpriteMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'SpriteMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.alphaMap = null;

			this.rotation = 0;

			this.sizeAttenuation = true;

			this.transparent = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.rotation = source.rotation;

			this.sizeAttenuation = source.sizeAttenuation;

			return this;

		}

	}

	SpriteMaterial.prototype.isSpriteMaterial = true;

	let _geometry;

	const _intersectPoint = /*@__PURE__*/ new Vector3();
	const _worldScale = /*@__PURE__*/ new Vector3();
	const _mvPosition = /*@__PURE__*/ new Vector3();

	const _alignedPosition = /*@__PURE__*/ new Vector2();
	const _rotatedPosition = /*@__PURE__*/ new Vector2();
	const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

	const _vA = /*@__PURE__*/ new Vector3();
	const _vB = /*@__PURE__*/ new Vector3();
	const _vC = /*@__PURE__*/ new Vector3();

	const _uvA = /*@__PURE__*/ new Vector2();
	const _uvB = /*@__PURE__*/ new Vector2();
	const _uvC = /*@__PURE__*/ new Vector2();

	class Sprite extends Object3D {

		constructor( material ) {

			super();

			this.type = 'Sprite';

			if ( _geometry === undefined ) {

				_geometry = new BufferGeometry();

				const float32Array = new Float32Array( [
					- 0.5, - 0.5, 0, 0, 0,
					0.5, - 0.5, 0, 1, 0,
					0.5, 0.5, 0, 1, 1,
					- 0.5, 0.5, 0, 0, 1
				] );

				const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

				_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
				_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
				_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

			}

			this.geometry = _geometry;
			this.material = ( material !== undefined ) ? material : new SpriteMaterial();

			this.center = new Vector2( 0.5, 0.5 );

		}

		raycast( raycaster, intersects ) {

			if ( raycaster.camera === null ) {

				console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

			}

			_worldScale.setFromMatrixScale( this.matrixWorld );

			_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
			this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

			_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

			if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

				_worldScale.multiplyScalar( - _mvPosition.z );

			}

			const rotation = this.material.rotation;
			let sin, cos;

			if ( rotation !== 0 ) {

				cos = Math.cos( rotation );
				sin = Math.sin( rotation );

			}

			const center = this.center;

			transformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			transformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			transformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

			_uvA.set( 0, 0 );
			_uvB.set( 1, 0 );
			_uvC.set( 1, 1 );

			// check first triangle
			let intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );

			if ( intersect === null ) {

				// check second triangle
				transformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
				_uvB.set( 0, 1 );

				intersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );
				if ( intersect === null ) {

					return;

				}

			}

			const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

			if ( distance < raycaster.near || distance > raycaster.far ) return;

			intersects.push( {

				distance: distance,
				point: _intersectPoint.clone(),
				uv: Triangle.getUV( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),
				face: null,
				object: this

			} );

		}

		copy( source ) {

			super.copy( source );

			if ( source.center !== undefined ) this.center.copy( source.center );

			this.material = source.material;

			return this;

		}

	}

	Sprite.prototype.isSprite = true;

	function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

		// compute position in camera space
		_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

		// to check if rotation is not zero
		if ( sin !== undefined ) {

			_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
			_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

		} else {

			_rotatedPosition.copy( _alignedPosition );

		}


		vertexPosition.copy( mvPosition );
		vertexPosition.x += _rotatedPosition.x;
		vertexPosition.y += _rotatedPosition.y;

		// transform to world space
		vertexPosition.applyMatrix4( _viewWorldMatrix );

	}

	const _basePosition = /*@__PURE__*/ new Vector3();

	const _skinIndex = /*@__PURE__*/ new Vector4();
	const _skinWeight = /*@__PURE__*/ new Vector4();

	const _vector$5 = /*@__PURE__*/ new Vector3();
	const _matrix = /*@__PURE__*/ new Matrix4();

	class SkinnedMesh extends Mesh {

		constructor( geometry, material ) {

			super( geometry, material );

			this.type = 'SkinnedMesh';

			this.bindMode = 'attached';
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();

		}

		copy( source ) {

			super.copy( source );

			this.bindMode = source.bindMode;
			this.bindMatrix.copy( source.bindMatrix );
			this.bindMatrixInverse.copy( source.bindMatrixInverse );

			this.skeleton = source.skeleton;

			return this;

		}

		bind( skeleton, bindMatrix ) {

			this.skeleton = skeleton;

			if ( bindMatrix === undefined ) {

				this.updateMatrixWorld( true );

				this.skeleton.calculateInverses();

				bindMatrix = this.matrixWorld;

			}

			this.bindMatrix.copy( bindMatrix );
			this.bindMatrixInverse.copy( bindMatrix ).invert();

		}

		pose() {

			this.skeleton.pose();

		}

		normalizeSkinWeights() {

			const vector = new Vector4();

			const skinWeight = this.geometry.attributes.skinWeight;

			for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

				vector.fromBufferAttribute( skinWeight, i );

				const scale = 1.0 / vector.manhattanLength();

				if ( scale !== Infinity ) {

					vector.multiplyScalar( scale );

				} else {

					vector.set( 1, 0, 0, 0 ); // do something reasonable

				}

				skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

			}

		}

		updateMatrixWorld( force ) {

			super.updateMatrixWorld( force );

			if ( this.bindMode === 'attached' ) {

				this.bindMatrixInverse.copy( this.matrixWorld ).invert();

			} else if ( this.bindMode === 'detached' ) {

				this.bindMatrixInverse.copy( this.bindMatrix ).invert();

			} else {

				console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

			}

		}

		boneTransform( index, target ) {

			const skeleton = this.skeleton;
			const geometry = this.geometry;

			_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
			_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

			_basePosition.copy( target ).applyMatrix4( this.bindMatrix );

			target.set( 0, 0, 0 );

			for ( let i = 0; i < 4; i ++ ) {

				const weight = _skinWeight.getComponent( i );

				if ( weight !== 0 ) {

					const boneIndex = _skinIndex.getComponent( i );

					_matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

					target.addScaledVector( _vector$5.copy( _basePosition ).applyMatrix4( _matrix ), weight );

				}

			}

			return target.applyMatrix4( this.bindMatrixInverse );

		}

	}

	SkinnedMesh.prototype.isSkinnedMesh = true;

	class Bone extends Object3D {

		constructor() {

			super();

			this.type = 'Bone';

		}

	}

	Bone.prototype.isBone = true;

	class DataTexture extends Texture {

		constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding ) {

			super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { data: data, width: width, height: height };

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

	}

	DataTexture.prototype.isDataTexture = true;

	const _offsetMatrix = /*@__PURE__*/ new Matrix4();
	const _identityMatrix = /*@__PURE__*/ new Matrix4();

	class Skeleton {

		constructor( bones = [], boneInverses = [] ) {

			this.uuid = generateUUID();

			this.bones = bones.slice( 0 );
			this.boneInverses = boneInverses;
			this.boneMatrices = null;

			this.boneTexture = null;
			this.boneTextureSize = 0;

			this.frame = - 1;

			this.init();

		}

		init() {

			const bones = this.bones;
			const boneInverses = this.boneInverses;

			this.boneMatrices = new Float32Array( bones.length * 16 );

			// calculate inverse bone matrices if necessary

			if ( boneInverses.length === 0 ) {

				this.calculateInverses();

			} else {

				// handle special case

				if ( bones.length !== boneInverses.length ) {

					console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

					this.boneInverses = [];

					for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

						this.boneInverses.push( new Matrix4() );

					}

				}

			}

		}

		calculateInverses() {

			this.boneInverses.length = 0;

			for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

				const inverse = new Matrix4();

				if ( this.bones[ i ] ) {

					inverse.copy( this.bones[ i ].matrixWorld ).invert();

				}

				this.boneInverses.push( inverse );

			}

		}

		pose() {

			// recover the bind-time world matrices

			for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

				const bone = this.bones[ i ];

				if ( bone ) {

					bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

				}

			}

			// compute the local matrices, positions, rotations and scales

			for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

				const bone = this.bones[ i ];

				if ( bone ) {

					if ( bone.parent && bone.parent.isBone ) {

						bone.matrix.copy( bone.parent.matrixWorld ).invert();
						bone.matrix.multiply( bone.matrixWorld );

					} else {

						bone.matrix.copy( bone.matrixWorld );

					}

					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

				}

			}

		}

		update() {

			const bones = this.bones;
			const boneInverses = this.boneInverses;
			const boneMatrices = this.boneMatrices;
			const boneTexture = this.boneTexture;

			// flatten bone matrices to array

			for ( let i = 0, il = bones.length; i < il; i ++ ) {

				// compute the offset between the current and the original transform

				const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

				_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
				_offsetMatrix.toArray( boneMatrices, i * 16 );

			}

			if ( boneTexture !== null ) {

				boneTexture.needsUpdate = true;

			}

		}

		clone() {

			return new Skeleton( this.bones, this.boneInverses );

		}

		computeBoneTexture() {

			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
			//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
			//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
			//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

			let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
			size = ceilPowerOfTwo( size );
			size = Math.max( size, 4 );

			const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
			boneMatrices.set( this.boneMatrices ); // copy current values

			const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
			boneTexture.needsUpdate = true;

			this.boneMatrices = boneMatrices;
			this.boneTexture = boneTexture;
			this.boneTextureSize = size;

			return this;

		}

		getBoneByName( name ) {

			for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

				const bone = this.bones[ i ];

				if ( bone.name === name ) {

					return bone;

				}

			}

			return undefined;

		}

		dispose( ) {

			if ( this.boneTexture !== null ) {

				this.boneTexture.dispose();

				this.boneTexture = null;

			}

		}

		fromJSON( json, bones ) {

			this.uuid = json.uuid;

			for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

				const uuid = json.bones[ i ];
				let bone = bones[ uuid ];

				if ( bone === undefined ) {

					console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
					bone = new Bone();

				}

				this.bones.push( bone );
				this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

			}

			this.init();

			return this;

		}

		toJSON() {

			const data = {
				metadata: {
					version: 4.5,
					type: 'Skeleton',
					generator: 'Skeleton.toJSON'
				},
				bones: [],
				boneInverses: []
			};

			data.uuid = this.uuid;

			const bones = this.bones;
			const boneInverses = this.boneInverses;

			for ( let i = 0, l = bones.length; i < l; i ++ ) {

				const bone = bones[ i ];
				data.bones.push( bone.uuid );

				const boneInverse = boneInverses[ i ];
				data.boneInverses.push( boneInverse.toArray() );

			}

			return data;

		}

	}

	class InstancedBufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

			if ( typeof normalized === 'number' ) {

				meshPerAttribute = normalized;

				normalized = false;

				console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

			}

			super( array, itemSize, normalized );

			this.meshPerAttribute = meshPerAttribute;

		}

		copy( source ) {

			super.copy( source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.meshPerAttribute = this.meshPerAttribute;

			data.isInstancedBufferAttribute = true;

			return data;

		}

	}

	InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

	const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
	const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();

	const _instanceIntersects = [];

	const _mesh = /*@__PURE__*/ new Mesh();

	class InstancedMesh extends Mesh {

		constructor( geometry, material, count ) {

			super( geometry, material );

			this.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );
			this.instanceColor = null;

			this.count = count;

			this.frustumCulled = false;

		}

		copy( source ) {

			super.copy( source );

			this.instanceMatrix.copy( source.instanceMatrix );

			if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

			this.count = source.count;

			return this;

		}

		getColorAt( index, color ) {

			color.fromArray( this.instanceColor.array, index * 3 );

		}

		getMatrixAt( index, matrix ) {

			matrix.fromArray( this.instanceMatrix.array, index * 16 );

		}

		raycast( raycaster, intersects ) {

			const matrixWorld = this.matrixWorld;
			const raycastTimes = this.count;

			_mesh.geometry = this.geometry;
			_mesh.material = this.material;

			if ( _mesh.material === undefined ) return;

			for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

				// calculate the world matrix for each instance

				this.getMatrixAt( instanceId, _instanceLocalMatrix );

				_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

				// the mesh represents this single instance

				_mesh.matrixWorld = _instanceWorldMatrix;

				_mesh.raycast( raycaster, _instanceIntersects );

				// process the result of raycast

				for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

					const intersect = _instanceIntersects[ i ];
					intersect.instanceId = instanceId;
					intersect.object = this;
					intersects.push( intersect );

				}

				_instanceIntersects.length = 0;

			}

		}

		setColorAt( index, color ) {

			if ( this.instanceColor === null ) {

				this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );

			}

			color.toArray( this.instanceColor.array, index * 3 );

		}

		setMatrixAt( index, matrix ) {

			matrix.toArray( this.instanceMatrix.array, index * 16 );

		}

		updateMorphTargets() {

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

	}

	InstancedMesh.prototype.isInstancedMesh = true;

	class LineBasicMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'LineBasicMaterial';

			this.color = new Color( 0xffffff );

			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';

			this.setValues( parameters );

		}


		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;

			return this;

		}

	}

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	const _start$1 = /*@__PURE__*/ new Vector3();
	const _end$1 = /*@__PURE__*/ new Vector3();
	const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
	const _ray$1 = /*@__PURE__*/ new Ray();
	const _sphere$1 = /*@__PURE__*/ new Sphere();

	class Line extends Object3D {

		constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

			super();

			this.type = 'Line';

			this.geometry = geometry;
			this.material = material;

			this.updateMorphTargets();

		}

		copy( source ) {

			super.copy( source );

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		}

		computeLineDistances() {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				// we assume non-indexed geometry

				if ( geometry.index === null ) {

					const positionAttribute = geometry.attributes.position;
					const lineDistances = [ 0 ];

					for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

						_start$1.fromBufferAttribute( positionAttribute, i - 1 );
						_end$1.fromBufferAttribute( positionAttribute, i );

						lineDistances[ i ] = lineDistances[ i - 1 ];
						lineDistances[ i ] += _start$1.distanceTo( _end$1 );

					}

					geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

				} else {

					console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

				}

			} else if ( geometry.isGeometry ) {

				console.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

			return this;

		}

		raycast( raycaster, intersects ) {

			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Line.threshold;
			const drawRange = geometry.drawRange;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$1.copy( geometry.boundingSphere );
			_sphere$1.applyMatrix4( matrixWorld );
			_sphere$1.radius += threshold;

			if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

			//

			_inverseMatrix$1.copy( matrixWorld ).invert();
			_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

			const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			const localThresholdSq = localThreshold * localThreshold;

			const vStart = new Vector3();
			const vEnd = new Vector3();
			const interSegment = new Vector3();
			const interRay = new Vector3();
			const step = this.isLineSegments ? 2 : 1;

			if ( geometry.isBufferGeometry ) {

				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if ( index !== null ) {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, l = end - 1; i < l; i += step ) {

						const a = index.getX( i );
						const b = index.getX( i + 1 );

						vStart.fromBufferAttribute( positionAttribute, a );
						vEnd.fromBufferAttribute( positionAttribute, b );

						const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > localThresholdSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, l = end - 1; i < l; i += step ) {

						vStart.fromBufferAttribute( positionAttribute, i );
						vEnd.fromBufferAttribute( positionAttribute, i + 1 );

						const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > localThresholdSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry.isGeometry ) {

				console.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

		updateMorphTargets() {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					const morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							const name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				const morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		}

	}

	Line.prototype.isLine = true;

	const _start = /*@__PURE__*/ new Vector3();
	const _end = /*@__PURE__*/ new Vector3();

	class LineSegments extends Line {

		constructor( geometry, material ) {

			super( geometry, material );

			this.type = 'LineSegments';

		}

		computeLineDistances() {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				// we assume non-indexed geometry

				if ( geometry.index === null ) {

					const positionAttribute = geometry.attributes.position;
					const lineDistances = [];

					for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

						_start.fromBufferAttribute( positionAttribute, i );
						_end.fromBufferAttribute( positionAttribute, i + 1 );

						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
						lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

					}

					geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

				} else {

					console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

				}

			} else if ( geometry.isGeometry ) {

				console.error( 'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

			return this;

		}

	}

	LineSegments.prototype.isLineSegments = true;

	class LineLoop extends Line {

		constructor( geometry, material ) {

			super( geometry, material );

			this.type = 'LineLoop';

		}

	}

	LineLoop.prototype.isLineLoop = true;

	class PointsMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'PointsMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.alphaMap = null;

			this.size = 1;
			this.sizeAttenuation = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;

			return this;

		}

	}

	PointsMaterial.prototype.isPointsMaterial = true;

	const _inverseMatrix = /*@__PURE__*/ new Matrix4();
	const _ray = /*@__PURE__*/ new Ray();
	const _sphere = /*@__PURE__*/ new Sphere();
	const _position$2 = /*@__PURE__*/ new Vector3();

	class Points extends Object3D {

		constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

			super();

			this.type = 'Points';

			this.geometry = geometry;
			this.material = material;

			this.updateMorphTargets();

		}

		copy( source ) {

			super.copy( source );

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		}

		raycast( raycaster, intersects ) {

			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Points.threshold;
			const drawRange = geometry.drawRange;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere.copy( geometry.boundingSphere );
			_sphere.applyMatrix4( matrixWorld );
			_sphere.radius += threshold;

			if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

			//

			_inverseMatrix.copy( matrixWorld ).invert();
			_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

			const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			const localThresholdSq = localThreshold * localThreshold;

			if ( geometry.isBufferGeometry ) {

				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if ( index !== null ) {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i ++ ) {

						const a = index.getX( i );

						_position$2.fromBufferAttribute( positionAttribute, a );

						testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, l = end; i < l; i ++ ) {

						_position$2.fromBufferAttribute( positionAttribute, i );

						testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

					}

				}

			} else {

				console.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

		updateMorphTargets() {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					const morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							const name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				const morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		}

	}

	Points.prototype.isPoints = true;

	function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

		const rayPointDistanceSq = _ray.distanceSqToPoint( point );

		if ( rayPointDistanceSq < localThresholdSq ) {

			const intersectPoint = new Vector3();

			_ray.closestPointToPoint( point, intersectPoint );
			intersectPoint.applyMatrix4( matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( intersectPoint );

			if ( distance < raycaster.near || distance > raycaster.far ) return;

			intersects.push( {

				distance: distance,
				distanceToRay: Math.sqrt( rayPointDistanceSq ),
				point: intersectPoint,
				index: index,
				face: null,
				object: object

			} );

		}

	}

	class VideoTexture extends Texture {

		constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

			this.generateMipmaps = false;

			const scope = this;

			function updateVideo() {

				scope.needsUpdate = true;
				video.requestVideoFrameCallback( updateVideo );

			}

			if ( 'requestVideoFrameCallback' in video ) {

				video.requestVideoFrameCallback( updateVideo );

			}

		}

		clone() {

			return new this.constructor( this.image ).copy( this );

		}

		update() {

			const video = this.image;
			const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

			if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

				this.needsUpdate = true;

			}

		}

	}

	VideoTexture.prototype.isVideoTexture = true;

	class FramebufferTexture extends Texture {

		constructor( width, height, format ) {

			super( { width, height } );

			this.format = format;

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.generateMipmaps = false;

			this.needsUpdate = true;

		}

	}

	FramebufferTexture.prototype.isFramebufferTexture = true;

	class CompressedTexture extends Texture {

		constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

			super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { width: width, height: height };
			this.mipmaps = mipmaps;

			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			this.flipY = false;

			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			this.generateMipmaps = false;

		}

	}

	CompressedTexture.prototype.isCompressedTexture = true;

	class CanvasTexture extends Texture {

		constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.needsUpdate = true;

		}

	}

	CanvasTexture.prototype.isCanvasTexture = true;

	/**
	 * Extensible curve object.
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	class Curve {

		constructor() {

			this.type = 'Curve';

			this.arcLengthDivisions = 200;

		}

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint( /* t, optionalTarget */ ) {

			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
			return null;

		}

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt( u, optionalTarget ) {

			const t = this.getUtoTmapping( u );
			return this.getPoint( t, optionalTarget );

		}

		// Get sequence of points using getPoint( t )

		getPoints( divisions = 5 ) {

			const points = [];

			for ( let d = 0; d <= divisions; d ++ ) {

				points.push( this.getPoint( d / divisions ) );

			}

			return points;

		}

		// Get sequence of points using getPointAt( u )

		getSpacedPoints( divisions = 5 ) {

			const points = [];

			for ( let d = 0; d <= divisions; d ++ ) {

				points.push( this.getPointAt( d / divisions ) );

			}

			return points;

		}

		// Get total curve arc length

		getLength() {

			const lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];

		}

		// Get list of cumulative segment lengths

		getLengths( divisions = this.arcLengthDivisions ) {

			if ( this.cacheArcLengths &&
				( this.cacheArcLengths.length === divisions + 1 ) &&
				! this.needsUpdate ) {

				return this.cacheArcLengths;

			}

			this.needsUpdate = false;

			const cache = [];
			let current, last = this.getPoint( 0 );
			let sum = 0;

			cache.push( 0 );

			for ( let p = 1; p <= divisions; p ++ ) {

				current = this.getPoint( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;

			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum: sum }; Sum is in the last element.

		}

		updateArcLengths() {

			this.needsUpdate = true;
			this.getLengths();

		}

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping( u, distance ) {

			const arcLengths = this.getLengths();

			let i = 0;
			const il = arcLengths.length;

			let targetArcLength; // The targeted u distance value to get

			if ( distance ) {

				targetArcLength = distance;

			} else {

				targetArcLength = u * arcLengths[ il - 1 ];

			}

			// binary search for the index with largest value smaller than target u distance

			let low = 0, high = il - 1, comparison;

			while ( low <= high ) {

				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[ i ] - targetArcLength;

				if ( comparison < 0 ) {

					low = i + 1;

				} else if ( comparison > 0 ) {

					high = i - 1;

				} else {

					high = i;
					break;

					// DONE

				}

			}

			i = high;

			if ( arcLengths[ i ] === targetArcLength ) {

				return i / ( il - 1 );

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			const lengthBefore = arcLengths[ i ];
			const lengthAfter = arcLengths[ i + 1 ];

			const segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

			// add that fractional amount to t

			const t = ( i + segmentFraction ) / ( il - 1 );

			return t;

		}

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent( t, optionalTarget ) {

			const delta = 0.0001;
			let t1 = t - delta;
			let t2 = t + delta;

			// Capping in case of danger

			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;

			const pt1 = this.getPoint( t1 );
			const pt2 = this.getPoint( t2 );

			const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

			tangent.copy( pt2 ).sub( pt1 ).normalize();

			return tangent;

		}

		getTangentAt( u, optionalTarget ) {

			const t = this.getUtoTmapping( u );
			return this.getTangent( t, optionalTarget );

		}

		computeFrenetFrames( segments, closed ) {

			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

			const normal = new Vector3();

			const tangents = [];
			const normals = [];
			const binormals = [];

			const vec = new Vector3();
			const mat = new Matrix4();

			// compute the tangent vectors for each segment on the curve

			for ( let i = 0; i <= segments; i ++ ) {

				const u = i / segments;

				tangents[ i ] = this.getTangentAt( u, new Vector3() );

			}

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component

			normals[ 0 ] = new Vector3();
			binormals[ 0 ] = new Vector3();
			let min = Number.MAX_VALUE;
			const tx = Math.abs( tangents[ 0 ].x );
			const ty = Math.abs( tangents[ 0 ].y );
			const tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= min ) {

				min = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= min ) {

				min = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= min ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


			// compute the slowly-varying normal and binormal vectors for each segment on the curve

			for ( let i = 1; i <= segments; i ++ ) {

				normals[ i ] = normals[ i - 1 ].clone();

				binormals[ i ] = binormals[ i - 1 ].clone();

				vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

				if ( vec.length() > Number.EPSILON ) {

					vec.normalize();

					const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

					normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

				}

				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

			if ( closed === true ) {

				let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
				theta /= segments;

				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

					theta = - theta;

				}

				for ( let i = 1; i <= segments; i ++ ) {

					// twist a little...
					normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.arcLengthDivisions = source.arcLengthDivisions;

			return this;

		}

		toJSON() {

			const data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};

			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;

			return data;

		}

		fromJSON( json ) {

			this.arcLengthDivisions = json.arcLengthDivisions;

			return this;

		}

	}

	class EllipseCurve extends Curve {

		constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

			super();

			this.type = 'EllipseCurve';

			this.aX = aX;
			this.aY = aY;

			this.xRadius = xRadius;
			this.yRadius = yRadius;

			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;

			this.aClockwise = aClockwise;

			this.aRotation = aRotation;

		}

		getPoint( t, optionalTarget ) {

			const point = optionalTarget || new Vector2();

			const twoPi = Math.PI * 2;
			let deltaAngle = this.aEndAngle - this.aStartAngle;
			const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

			// ensures that deltaAngle is 0 .. 2 PI
			while ( deltaAngle < 0 ) deltaAngle += twoPi;
			while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

			if ( deltaAngle < Number.EPSILON ) {

				if ( samePoints ) {

					deltaAngle = 0;

				} else {

					deltaAngle = twoPi;

				}

			}

			if ( this.aClockwise === true && ! samePoints ) {

				if ( deltaAngle === twoPi ) {

					deltaAngle = - twoPi;

				} else {

					deltaAngle = deltaAngle - twoPi;

				}

			}

			const angle = this.aStartAngle + t * deltaAngle;
			let x = this.aX + this.xRadius * Math.cos( angle );
			let y = this.aY + this.yRadius * Math.sin( angle );

			if ( this.aRotation !== 0 ) {

				const cos = Math.cos( this.aRotation );
				const sin = Math.sin( this.aRotation );

				const tx = x - this.aX;
				const ty = y - this.aY;

				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;

			}

			return point.set( x, y );

		}

		copy( source ) {

			super.copy( source );

			this.aX = source.aX;
			this.aY = source.aY;

			this.xRadius = source.xRadius;
			this.yRadius = source.yRadius;

			this.aStartAngle = source.aStartAngle;
			this.aEndAngle = source.aEndAngle;

			this.aClockwise = source.aClockwise;

			this.aRotation = source.aRotation;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.aX = this.aX;
			data.aY = this.aY;

			data.xRadius = this.xRadius;
			data.yRadius = this.yRadius;

			data.aStartAngle = this.aStartAngle;
			data.aEndAngle = this.aEndAngle;

			data.aClockwise = this.aClockwise;

			data.aRotation = this.aRotation;

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.aX = json.aX;
			this.aY = json.aY;

			this.xRadius = json.xRadius;
			this.yRadius = json.yRadius;

			this.aStartAngle = json.aStartAngle;
			this.aEndAngle = json.aEndAngle;

			this.aClockwise = json.aClockwise;

			this.aRotation = json.aRotation;

			return this;

		}

	}

	EllipseCurve.prototype.isEllipseCurve = true;

	class ArcCurve extends EllipseCurve {

		constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

			this.type = 'ArcCurve';

		}

	}

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */


	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

		let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init( x0, x1, t0, t1 ) {

			c0 = x0;
			c1 = t0;
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;

		}

		return {

			initCatmullRom: function ( x0, x1, x2, x3, tension ) {

				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

			},

			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

				// compute tangents when parameterized in [t1,t2]
				let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				init( x1, x2, t1, t2 );

			},

			calc: function ( t ) {

				const t2 = t * t;
				const t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;

			}

		};

	}

	//

	const tmp = new Vector3();
	const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

	class CatmullRomCurve3 extends Curve {

		constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

			super();

			this.type = 'CatmullRomCurve3';

			this.points = points;
			this.closed = closed;
			this.curveType = curveType;
			this.tension = tension;

		}

		getPoint( t, optionalTarget = new Vector3() ) {

			const point = optionalTarget;

			const points = this.points;
			const l = points.length;

			const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
			let intPoint = Math.floor( p );
			let weight = p - intPoint;

			if ( this.closed ) {

				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

			} else if ( weight === 0 && intPoint === l - 1 ) {

				intPoint = l - 2;
				weight = 1;

			}

			let p0, p3; // 4 points (p1 & p2 defined below)

			if ( this.closed || intPoint > 0 ) {

				p0 = points[ ( intPoint - 1 ) % l ];

			} else {

				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;

			}

			const p1 = points[ intPoint % l ];
			const p2 = points[ ( intPoint + 1 ) % l ];

			if ( this.closed || intPoint + 2 < l ) {

				p3 = points[ ( intPoint + 2 ) % l ];

			} else {

				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
				p3 = tmp;

			}

			if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

				// init Centripetal / Chordal Catmull-Rom
				const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
				let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

				// safety check for repeated points
				if ( dt1 < 1e-4 ) dt1 = 1.0;
				if ( dt0 < 1e-4 ) dt0 = dt1;
				if ( dt2 < 1e-4 ) dt2 = dt1;

				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

			} else if ( this.curveType === 'catmullrom' ) {

				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

			}

			point.set(
				px.calc( weight ),
				py.calc( weight ),
				pz.calc( weight )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.points = [];

			for ( let i = 0, l = source.points.length; i < l; i ++ ) {

				const point = source.points[ i ];

				this.points.push( point.clone() );

			}

			this.closed = source.closed;
			this.curveType = source.curveType;
			this.tension = source.tension;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.points = [];

			for ( let i = 0, l = this.points.length; i < l; i ++ ) {

				const point = this.points[ i ];
				data.points.push( point.toArray() );

			}

			data.closed = this.closed;
			data.curveType = this.curveType;
			data.tension = this.tension;

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.points = [];

			for ( let i = 0, l = json.points.length; i < l; i ++ ) {

				const point = json.points[ i ];
				this.points.push( new Vector3().fromArray( point ) );

			}

			this.closed = json.closed;
			this.curveType = json.curveType;
			this.tension = json.tension;

			return this;

		}

	}

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	/**
	 * Bezier Curves formulas obtained from
	 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
	 */

	function CatmullRom( t, p0, p1, p2, p3 ) {

		const v0 = ( p2 - p0 ) * 0.5;
		const v1 = ( p3 - p1 ) * 0.5;
		const t2 = t * t;
		const t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

	//

	function QuadraticBezierP0( t, p ) {

		const k = 1 - t;
		return k * k * p;

	}

	function QuadraticBezierP1( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	}

	function QuadraticBezierP2( t, p ) {

		return t * t * p;

	}

	function QuadraticBezier( t, p0, p1, p2 ) {

		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
			QuadraticBezierP2( t, p2 );

	}

	//

	function CubicBezierP0( t, p ) {

		const k = 1 - t;
		return k * k * k * p;

	}

	function CubicBezierP1( t, p ) {

		const k = 1 - t;
		return 3 * k * k * t * p;

	}

	function CubicBezierP2( t, p ) {

		return 3 * ( 1 - t ) * t * t * p;

	}

	function CubicBezierP3( t, p ) {

		return t * t * t * p;

	}

	function CubicBezier( t, p0, p1, p2, p3 ) {

		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
			CubicBezierP3( t, p3 );

	}

	class CubicBezierCurve extends Curve {

		constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

			super();

			this.type = 'CubicBezierCurve';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		}

		getPoint( t, optionalTarget = new Vector2() ) {

			const point = optionalTarget;

			const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

			point.set(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );
			this.v3.copy( source.v3 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );
			this.v3.fromArray( json.v3 );

			return this;

		}

	}

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	class CubicBezierCurve3 extends Curve {

		constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

			super();

			this.type = 'CubicBezierCurve3';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		}

		getPoint( t, optionalTarget = new Vector3() ) {

			const point = optionalTarget;

			const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

			point.set(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
				CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );
			this.v3.copy( source.v3 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );
			this.v3.fromArray( json.v3 );

			return this;

		}

	}

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	class LineCurve extends Curve {

		constructor( v1 = new Vector2(), v2 = new Vector2() ) {

			super();

			this.type = 'LineCurve';

			this.v1 = v1;
			this.v2 = v2;

		}

		getPoint( t, optionalTarget = new Vector2() ) {

			const point = optionalTarget;

			if ( t === 1 ) {

				point.copy( this.v2 );

			} else {

				point.copy( this.v2 ).sub( this.v1 );
				point.multiplyScalar( t ).add( this.v1 );

			}

			return point;

		}

		// Line curve is linear, so we can overwrite default getPointAt
		getPointAt( u, optionalTarget ) {

			return this.getPoint( u, optionalTarget );

		}

		getTangent( t, optionalTarget ) {

			const tangent = optionalTarget || new Vector2();

			tangent.copy( this.v2 ).sub( this.v1 ).normalize();

			return tangent;

		}

		copy( source ) {

			super.copy( source );

			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		}

	}

	LineCurve.prototype.isLineCurve = true;

	class LineCurve3 extends Curve {

		constructor( v1 = new Vector3(), v2 = new Vector3() ) {

			super();

			this.type = 'LineCurve3';
			this.isLineCurve3 = true;

			this.v1 = v1;
			this.v2 = v2;

		}
		getPoint( t, optionalTarget = new Vector3() ) {

			const point = optionalTarget;

			if ( t === 1 ) {

				point.copy( this.v2 );

			} else {

				point.copy( this.v2 ).sub( this.v1 );
				point.multiplyScalar( t ).add( this.v1 );

			}

			return point;

		}
		// Line curve is linear, so we can overwrite default getPointAt
		getPointAt( u, optionalTarget ) {

			return this.getPoint( u, optionalTarget );

		}
		copy( source ) {

			super.copy( source );

			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		}
		toJSON() {

			const data = super.toJSON();

			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		}
		fromJSON( json ) {

			super.fromJSON( json );

			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		}

	}

	class QuadraticBezierCurve extends Curve {

		constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

			super();

			this.type = 'QuadraticBezierCurve';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		}

		getPoint( t, optionalTarget = new Vector2() ) {

			const point = optionalTarget;

			const v0 = this.v0, v1 = this.v1, v2 = this.v2;

			point.set(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		}

	}

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	class QuadraticBezierCurve3 extends Curve {

		constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

			super();

			this.type = 'QuadraticBezierCurve3';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		}

		getPoint( t, optionalTarget = new Vector3() ) {

			const point = optionalTarget;

			const v0 = this.v0, v1 = this.v1, v2 = this.v2;

			point.set(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y ),
				QuadraticBezier( t, v0.z, v1.z, v2.z )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		}

	}

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	class SplineCurve extends Curve {

		constructor( points = [] ) {

			super();

			this.type = 'SplineCurve';

			this.points = points;

		}

		getPoint( t, optionalTarget = new Vector2() ) {

			const point = optionalTarget;

			const points = this.points;
			const p = ( points.length - 1 ) * t;

			const intPoint = Math.floor( p );
			const weight = p - intPoint;

			const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
			const p1 = points[ intPoint ];
			const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			point.set(
				CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
				CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.points = [];

			for ( let i = 0, l = source.points.length; i < l; i ++ ) {

				const point = source.points[ i ];

				this.points.push( point.clone() );

			}

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.points = [];

			for ( let i = 0, l = this.points.length; i < l; i ++ ) {

				const point = this.points[ i ];
				data.points.push( point.toArray() );

			}

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.points = [];

			for ( let i = 0, l = json.points.length; i < l; i ++ ) {

				const point = json.points[ i ];
				this.points.push( new Vector2().fromArray( point ) );

			}

			return this;

		}

	}

	SplineCurve.prototype.isSplineCurve = true;

	var Curves = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	class CurvePath extends Curve {

		constructor() {

			super();

			this.type = 'CurvePath';

			this.curves = [];
			this.autoClose = false; // Automatically closes the path

		}

		add( curve ) {

			this.curves.push( curve );

		}

		closePath() {

			// Add a line curve if start and end of lines are not connected
			const startPoint = this.curves[ 0 ].getPoint( 0 );
			const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

			if ( ! startPoint.equals( endPoint ) ) {

				this.curves.push( new LineCurve( endPoint, startPoint ) );

			}

		}

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		getPoint( t, optionalTarget ) {

			const d = t * this.getLength();
			const curveLengths = this.getCurveLengths();
			let i = 0;

			// To think about boundaries points.

			while ( i < curveLengths.length ) {

				if ( curveLengths[ i ] >= d ) {

					const diff = curveLengths[ i ] - d;
					const curve = this.curves[ i ];

					const segmentLength = curve.getLength();
					const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

					return curve.getPointAt( u, optionalTarget );

				}

				i ++;

			}

			return null;

			// loop where sum != 0, sum > d , sum+1 <d

		}

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		getLength() {

			const lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];

		}

		// cacheLengths must be recalculated.
		updateArcLengths() {

			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();

		}

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		getCurveLengths() {

			// We use cache values if curves and cache array are same length

			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

				return this.cacheLengths;

			}

			// Get length of sub-curve
			// Push sums into cached array

			const lengths = [];
			let sums = 0;

			for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

				sums += this.curves[ i ].getLength();
				lengths.push( sums );

			}

			this.cacheLengths = lengths;

			return lengths;

		}

		getSpacedPoints( divisions = 40 ) {

			const points = [];

			for ( let i = 0; i <= divisions; i ++ ) {

				points.push( this.getPoint( i / divisions ) );

			}

			if ( this.autoClose ) {

				points.push( points[ 0 ] );

			}

			return points;

		}

		getPoints( divisions = 12 ) {

			const points = [];
			let last;

			for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

				const curve = curves[ i ];
				const resolution = curve.isEllipseCurve ? divisions * 2
					: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1
						: curve.isSplineCurve ? divisions * curve.points.length
							: divisions;

				const pts = curve.getPoints( resolution );

				for ( let j = 0; j < pts.length; j ++ ) {

					const point = pts[ j ];

					if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

					points.push( point );
					last = point;

				}

			}

			if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

				points.push( points[ 0 ] );

			}

			return points;

		}

		copy( source ) {

			super.copy( source );

			this.curves = [];

			for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

				const curve = source.curves[ i ];

				this.curves.push( curve.clone() );

			}

			this.autoClose = source.autoClose;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.autoClose = this.autoClose;
			data.curves = [];

			for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

				const curve = this.curves[ i ];
				data.curves.push( curve.toJSON() );

			}

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.autoClose = json.autoClose;
			this.curves = [];

			for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

				const curve = json.curves[ i ];
				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

			}

			return this;

		}

	}

	class Path extends CurvePath {

		constructor( points ) {

			super();
			this.type = 'Path';

			this.currentPoint = new Vector2();

			if ( points ) {

				this.setFromPoints( points );

			}

		}

		setFromPoints( points ) {

			this.moveTo( points[ 0 ].x, points[ 0 ].y );

			for ( let i = 1, l = points.length; i < l; i ++ ) {

				this.lineTo( points[ i ].x, points[ i ].y );

			}

			return this;

		}

		moveTo( x, y ) {

			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

			return this;

		}

		lineTo( x, y ) {

			const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
			this.curves.push( curve );

			this.currentPoint.set( x, y );

			return this;

		}

		quadraticCurveTo( aCPx, aCPy, aX, aY ) {

			const curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCPx, aCPy ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

			return this;

		}

		bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			const curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCP1x, aCP1y ),
				new Vector2( aCP2x, aCP2y ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

			return this;

		}

		splineThru( pts /*Array of Vector*/ ) {

			const npts = [ this.currentPoint.clone() ].concat( pts );

			const curve = new SplineCurve( npts );
			this.curves.push( curve );

			this.currentPoint.copy( pts[ pts.length - 1 ] );

			return this;

		}

		arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;

			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );

			return this;

		}

		absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

			return this;

		}

		ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;

			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			return this;

		}

		absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			if ( this.curves.length > 0 ) {

				// if a previous curve is present, attempt to join
				const firstPoint = curve.getPoint( 0 );

				if ( ! firstPoint.equals( this.currentPoint ) ) {

					this.lineTo( firstPoint.x, firstPoint.y );

				}

			}

			this.curves.push( curve );

			const lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );

			return this;

		}

		copy( source ) {

			super.copy( source );

			this.currentPoint.copy( source.currentPoint );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.currentPoint = this.currentPoint.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.currentPoint.fromArray( json.currentPoint );

			return this;

		}

	}

	new Vector3();
	new Vector3();
	new Vector3();
	new Triangle();

	class Shape extends Path {

		constructor( points ) {

			super( points );

			this.uuid = generateUUID();

			this.type = 'Shape';

			this.holes = [];

		}

		getPointsHoles( divisions ) {

			const holesPts = [];

			for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

				holesPts[ i ] = this.holes[ i ].getPoints( divisions );

			}

			return holesPts;

		}

		// get points of shape and holes (keypoints based on segments parameter)

		extractPoints( divisions ) {

			return {

				shape: this.getPoints( divisions ),
				holes: this.getPointsHoles( divisions )

			};

		}

		copy( source ) {

			super.copy( source );

			this.holes = [];

			for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

				const hole = source.holes[ i ];

				this.holes.push( hole.clone() );

			}

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.uuid = this.uuid;
			data.holes = [];

			for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

				const hole = this.holes[ i ];
				data.holes.push( hole.toJSON() );

			}

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.uuid = json.uuid;
			this.holes = [];

			for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

				const hole = json.holes[ i ];
				this.holes.push( new Path().fromJSON( hole ) );

			}

			return this;

		}

	}

	/**
	 * Port from https://github.com/mapbox/earcut (v2.2.2)
	 */

	const Earcut = {

		triangulate: function ( data, holeIndices, dim = 2 ) {

			const hasHoles = holeIndices && holeIndices.length;
			const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
			let outerNode = linkedList( data, 0, outerLen, dim, true );
			const triangles = [];

			if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

			let minX, minY, maxX, maxY, x, y, invSize;

			if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
			if ( data.length > 80 * dim ) {

				minX = maxX = data[ 0 ];
				minY = maxY = data[ 1 ];

				for ( let i = dim; i < outerLen; i += dim ) {

					x = data[ i ];
					y = data[ i + 1 ];
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;

				}

				// minX, minY and invSize are later used to transform coords into integers for z-order calculation
				invSize = Math.max( maxX - minX, maxY - minY );
				invSize = invSize !== 0 ? 1 / invSize : 0;

			}

			earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

			return triangles;

		}

	};

	// create a circular doubly linked list from polygon points in the specified winding order
	function linkedList( data, start, end, dim, clockwise ) {

		let i, last;

		if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

			for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		} else {

			for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		}

		if ( last && equals( last, last.next ) ) {

			removeNode( last );
			last = last.next;

		}

		return last;

	}

	// eliminate colinear or duplicate points
	function filterPoints( start, end ) {

		if ( ! start ) return start;
		if ( ! end ) end = start;

		let p = start,
			again;
		do {

			again = false;

			if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

				removeNode( p );
				p = end = p.prev;
				if ( p === p.next ) break;
				again = true;

			} else {

				p = p.next;

			}

		} while ( again || p !== end );

		return end;

	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)
	function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

		if ( ! ear ) return;

		// interlink polygon nodes in z-order
		if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

		let stop = ear,
			prev, next;

		// iterate through ears, slicing them one by one
		while ( ear.prev !== ear.next ) {

			prev = ear.prev;
			next = ear.next;

			if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

				// cut off the triangle
				triangles.push( prev.i / dim );
				triangles.push( ear.i / dim );
				triangles.push( next.i / dim );

				removeNode( ear );

				// skipping the next vertex leads to less sliver triangles
				ear = next.next;
				stop = next.next;

				continue;

			}

			ear = next;

			// if we looped through the whole remaining polygon and can't find any more ears
			if ( ear === stop ) {

				// try filtering points and slicing again
				if ( ! pass ) {

					earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

					// if this didn't work, try curing all small self-intersections locally

				} else if ( pass === 1 ) {

					ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
					earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

					// as a last resort, try splitting the remaining polygon into two

				} else if ( pass === 2 ) {

					splitEarcut( ear, triangles, dim, minX, minY, invSize );

				}

				break;

			}

		}

	}

	// check whether a polygon node forms a valid ear with adjacent nodes
	function isEar( ear ) {

		const a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// now make sure we don't have other points inside the potential ear
		let p = ear.next.next;

		while ( p !== ear.prev ) {

			if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
				area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.next;

		}

		return true;

	}

	function isEarHashed( ear, minX, minY, invSize ) {

		const a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// triangle bbox; min & max are calculated like this for speed
		const minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
			minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
			maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
			maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

		// z-order range for the current triangle bbox;
		const minZ = zOrder( minTX, minTY, minX, minY, invSize ),
			maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

		let p = ear.prevZ,
			n = ear.nextZ;

		// look for points inside the triangle in both directions
		while ( p && p.z >= minZ && n && n.z <= maxZ ) {

			if ( p !== ear.prev && p !== ear.next &&
				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
				area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.prevZ;

			if ( n !== ear.prev && n !== ear.next &&
				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
				area( n.prev, n, n.next ) >= 0 ) return false;
			n = n.nextZ;

		}

		// look for remaining points in decreasing z-order
		while ( p && p.z >= minZ ) {

			if ( p !== ear.prev && p !== ear.next &&
				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
				area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.prevZ;

		}

		// look for remaining points in increasing z-order
		while ( n && n.z <= maxZ ) {

			if ( n !== ear.prev && n !== ear.next &&
				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
				area( n.prev, n, n.next ) >= 0 ) return false;
			n = n.nextZ;

		}

		return true;

	}

	// go through all polygon nodes and cure small local self-intersections
	function cureLocalIntersections( start, triangles, dim ) {

		let p = start;
		do {

			const a = p.prev,
				b = p.next.next;

			if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

				triangles.push( a.i / dim );
				triangles.push( p.i / dim );
				triangles.push( b.i / dim );

				// remove two nodes involved
				removeNode( p );
				removeNode( p.next );

				p = start = b;

			}

			p = p.next;

		} while ( p !== start );

		return filterPoints( p );

	}

	// try splitting polygon into two and triangulate them independently
	function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

		// look for a valid diagonal that divides the polygon into two
		let a = start;
		do {

			let b = a.next.next;
			while ( b !== a.prev ) {

				if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

					// split the polygon in two by the diagonal
					let c = splitPolygon( a, b );

					// filter colinear points around the cuts
					a = filterPoints( a, a.next );
					c = filterPoints( c, c.next );

					// run earcut on each half
					earcutLinked( a, triangles, dim, minX, minY, invSize );
					earcutLinked( c, triangles, dim, minX, minY, invSize );
					return;

				}

				b = b.next;

			}

			a = a.next;

		} while ( a !== start );

	}

	// link every hole into the outer loop, producing a single-ring polygon without holes
	function eliminateHoles( data, holeIndices, outerNode, dim ) {

		const queue = [];
		let i, len, start, end, list;

		for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

			start = holeIndices[ i ] * dim;
			end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
			list = linkedList( data, start, end, dim, false );
			if ( list === list.next ) list.steiner = true;
			queue.push( getLeftmost( list ) );

		}

		queue.sort( compareX );

		// process holes from left to right
		for ( i = 0; i < queue.length; i ++ ) {

			eliminateHole( queue[ i ], outerNode );
			outerNode = filterPoints( outerNode, outerNode.next );

		}

		return outerNode;

	}

	function compareX( a, b ) {

		return a.x - b.x;

	}

	// find a bridge between vertices that connects hole with an outer ring and link it
	function eliminateHole( hole, outerNode ) {

		outerNode = findHoleBridge( hole, outerNode );
		if ( outerNode ) {

			const b = splitPolygon( outerNode, hole );

			// filter collinear points around the cuts
			filterPoints( outerNode, outerNode.next );
			filterPoints( b, b.next );

		}

	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	function findHoleBridge( hole, outerNode ) {

		let p = outerNode;
		const hx = hole.x;
		const hy = hole.y;
		let qx = - Infinity, m;

		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point
		do {

			if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

				const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
				if ( x <= hx && x > qx ) {

					qx = x;
					if ( x === hx ) {

						if ( hy === p.y ) return p;
						if ( hy === p.next.y ) return p.next;

					}

					m = p.x < p.next.x ? p : p.next;

				}

			}

			p = p.next;

		} while ( p !== outerNode );

		if ( ! m ) return null;

		if ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint

		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		const stop = m,
			mx = m.x,
			my = m.y;
		let tanMin = Infinity, tan;

		p = m;

		do {

			if ( hx >= p.x && p.x >= mx && hx !== p.x &&
					pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

				tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

				if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

					m = p;
					tanMin = tan;

				}

			}

			p = p.next;

		} while ( p !== stop );

		return m;

	}

	// whether sector in vertex m contains sector in vertex p in the same coordinates
	function sectorContainsSector( m, p ) {

		return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

	}

	// interlink polygon nodes in z-order
	function indexCurve( start, minX, minY, invSize ) {

		let p = start;
		do {

			if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;

		} while ( p !== start );

		p.prevZ.nextZ = null;
		p.prevZ = null;

		sortLinked( p );

	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	function sortLinked( list ) {

		let i, p, q, e, tail, numMerges, pSize, qSize,
			inSize = 1;

		do {

			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while ( p ) {

				numMerges ++;
				q = p;
				pSize = 0;
				for ( i = 0; i < inSize; i ++ ) {

					pSize ++;
					q = q.nextZ;
					if ( ! q ) break;

				}

				qSize = inSize;

				while ( pSize > 0 || ( qSize > 0 && q ) ) {

					if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

						e = p;
						p = p.nextZ;
						pSize --;

					} else {

						e = q;
						q = q.nextZ;
						qSize --;

					}

					if ( tail ) tail.nextZ = e;
					else list = e;

					e.prevZ = tail;
					tail = e;

				}

				p = q;

			}

			tail.nextZ = null;
			inSize *= 2;

		} while ( numMerges > 1 );

		return list;

	}

	// z-order of a point given coords and inverse of the longer side of data bbox
	function zOrder( x, y, minX, minY, invSize ) {

		// coords are transformed into non-negative 15-bit integer range
		x = 32767 * ( x - minX ) * invSize;
		y = 32767 * ( y - minY ) * invSize;

		x = ( x | ( x << 8 ) ) & 0x00FF00FF;
		x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
		x = ( x | ( x << 2 ) ) & 0x33333333;
		x = ( x | ( x << 1 ) ) & 0x55555555;

		y = ( y | ( y << 8 ) ) & 0x00FF00FF;
		y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
		y = ( y | ( y << 2 ) ) & 0x33333333;
		y = ( y | ( y << 1 ) ) & 0x55555555;

		return x | ( y << 1 );

	}

	// find the leftmost node of a polygon ring
	function getLeftmost( start ) {

		let p = start,
			leftmost = start;
		do {

			if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
			p = p.next;

		} while ( p !== start );

		return leftmost;

	}

	// check if a point lies within a convex triangle
	function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

		return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
				( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
				( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	function isValidDiagonal( a, b ) {

		return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // doesn't intersect other edges
			( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
			( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
			equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

	}

	// signed area of a triangle
	function area( p, q, r ) {

		return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

	}

	// check if two points are equal
	function equals( p1, p2 ) {

		return p1.x === p2.x && p1.y === p2.y;

	}

	// check if two segments intersect
	function intersects( p1, q1, p2, q2 ) {

		const o1 = sign( area( p1, q1, p2 ) );
		const o2 = sign( area( p1, q1, q2 ) );
		const o3 = sign( area( p2, q2, p1 ) );
		const o4 = sign( area( p2, q2, q1 ) );

		if ( o1 !== o2 && o3 !== o4 ) return true; // general case

		if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
		if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
		if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
		if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

		return false;

	}

	// for collinear points p, q, r, check if point q lies on segment pr
	function onSegment( p, q, r ) {

		return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

	}

	function sign( num ) {

		return num > 0 ? 1 : num < 0 ? - 1 : 0;

	}

	// check if a polygon diagonal intersects any polygon segments
	function intersectsPolygon( a, b ) {

		let p = a;
		do {

			if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
					intersects( p, p.next, a, b ) ) return true;
			p = p.next;

		} while ( p !== a );

		return false;

	}

	// check if a polygon diagonal is locally inside the polygon
	function locallyInside( a, b ) {

		return area( a.prev, a, a.next ) < 0 ?
			area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
			area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

	}

	// check if the middle point of a polygon diagonal is inside the polygon
	function middleInside( a, b ) {

		let p = a,
			inside = false;
		const px = ( a.x + b.x ) / 2,
			py = ( a.y + b.y ) / 2;
		do {

			if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
					( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
				inside = ! inside;
			p = p.next;

		} while ( p !== a );

		return inside;

	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	function splitPolygon( a, b ) {

		const a2 = new Node( a.i, a.x, a.y ),
			b2 = new Node( b.i, b.x, b.y ),
			an = a.next,
			bp = b.prev;

		a.next = b;
		b.prev = a;

		a2.next = an;
		an.prev = a2;

		b2.next = a2;
		a2.prev = b2;

		bp.next = b2;
		b2.prev = bp;

		return b2;

	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)
	function insertNode( i, x, y, last ) {

		const p = new Node( i, x, y );

		if ( ! last ) {

			p.prev = p;
			p.next = p;

		} else {

			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;

		}

		return p;

	}

	function removeNode( p ) {

		p.next.prev = p.prev;
		p.prev.next = p.next;

		if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
		if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

	}

	function Node( i, x, y ) {

		// vertex index in coordinates array
		this.i = i;

		// vertex coordinates
		this.x = x;
		this.y = y;

		// previous and next vertex nodes in a polygon ring
		this.prev = null;
		this.next = null;

		// z-order curve value
		this.z = null;

		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;

		// indicates whether this is a steiner point
		this.steiner = false;

	}

	function signedArea( data, start, end, dim ) {

		let sum = 0;
		for ( let i = start, j = end - dim; i < end; i += dim ) {

			sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
			j = i;

		}

		return sum;

	}

	class ShapeUtils {

		// calculate area of the contour polygon

		static area( contour ) {

			const n = contour.length;
			let a = 0.0;

			for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		}

		static isClockWise( pts ) {

			return ShapeUtils.area( pts ) < 0;

		}

		static triangulateShape( contour, holes ) {

			const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			const holeIndices = []; // array of hole indices
			const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts( contour );
			addContour( vertices, contour );

			//

			let holeIndex = contour.length;

			holes.forEach( removeDupEndPts );

			for ( let i = 0; i < holes.length; i ++ ) {

				holeIndices.push( holeIndex );
				holeIndex += holes[ i ].length;
				addContour( vertices, holes[ i ] );

			}

			//

			const triangles = Earcut.triangulate( vertices, holeIndices );

			//

			for ( let i = 0; i < triangles.length; i += 3 ) {

				faces.push( triangles.slice( i, i + 3 ) );

			}

			return faces;

		}

	}

	function removeDupEndPts( points ) {

		const l = points.length;

		if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

			points.pop();

		}

	}

	function addContour( vertices, contour ) {

		for ( let i = 0; i < contour.length; i ++ ) {

			vertices.push( contour[ i ].x );
			vertices.push( contour[ i ].y );

		}

	}

	/**
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  depth: <float>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
	 *  bevelOffset: <float>, // how far from shape outline does bevel start
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	class ExtrudeGeometry extends BufferGeometry {

		constructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {

			super();

			this.type = 'ExtrudeGeometry';

			this.parameters = {
				shapes: shapes,
				options: options
			};

			shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

			const scope = this;

			const verticesArray = [];
			const uvArray = [];

			for ( let i = 0, l = shapes.length; i < l; i ++ ) {

				const shape = shapes[ i ];
				addShape( shape );

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

			this.computeVertexNormals();

			// functions

			function addShape( shape ) {

				const placeholder = [];

				// options

				const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
				const steps = options.steps !== undefined ? options.steps : 1;
				let depth = options.depth !== undefined ? options.depth : 1;

				let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
				let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
				let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
				let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
				let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

				const extrudePath = options.extrudePath;

				const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

				// deprecated options

				if ( options.amount !== undefined ) {

					console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
					depth = options.amount;

				}

				//

				let extrudePts, extrudeByPath = false;
				let splineTube, binormal, normal, position2;

				if ( extrudePath ) {

					extrudePts = extrudePath.getSpacedPoints( steps );

					extrudeByPath = true;
					bevelEnabled = false; // bevels not supported for path extrusion

					// SETUP TNB variables

					// TODO1 - have a .isClosed in spline?

					splineTube = extrudePath.computeFrenetFrames( steps, false );

					// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

					binormal = new Vector3();
					normal = new Vector3();
					position2 = new Vector3();

				}

				// Safeguards if bevels are not enabled

				if ( ! bevelEnabled ) {

					bevelSegments = 0;
					bevelThickness = 0;
					bevelSize = 0;
					bevelOffset = 0;

				}

				// Variables initialization

				const shapePoints = shape.extractPoints( curveSegments );

				let vertices = shapePoints.shape;
				const holes = shapePoints.holes;

				const reverse = ! ShapeUtils.isClockWise( vertices );

				if ( reverse ) {

					vertices = vertices.reverse();

					// Maybe we should also check if holes are in the opposite direction, just to be safe ...

					for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

						const ahole = holes[ h ];

						if ( ShapeUtils.isClockWise( ahole ) ) {

							holes[ h ] = ahole.reverse();

						}

					}

				}


				const faces = ShapeUtils.triangulateShape( vertices, holes );

				/* Vertices */

				const contour = vertices; // vertices has all points but contour has only points of circumference

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					vertices = vertices.concat( ahole );

				}


				function scalePt2( pt, vec, size ) {

					if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

					return vec.clone().multiplyScalar( size ).add( pt );

				}

				const vlen = vertices.length, flen = faces.length;


				// Find directions for point movement


				function getBevelVec( inPt, inPrev, inNext ) {

					// computes for inPt the corresponding point inPt' on a new contour
					//   shifted by 1 unit (length of normalized vector) to the left
					// if we walk along contour clockwise, this new contour is outside the old one
					//
					// inPt' is the intersection of the two lines parallel to the two
					//  adjacent edges of inPt at a distance of 1 unit on the left side.

					let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

					// good reading for geometry algorithms (here: line-line intersection)
					// http://geomalgorithms.com/a05-_intersect-1.html

					const v_prev_x = inPt.x - inPrev.x,
						v_prev_y = inPt.y - inPrev.y;
					const v_next_x = inNext.x - inPt.x,
						v_next_y = inNext.y - inPt.y;

					const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

					// check for collinear edges
					const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

					if ( Math.abs( collinear0 ) > Number.EPSILON ) {

						// not collinear

						// length of vectors for normalizing

						const v_prev_len = Math.sqrt( v_prev_lensq );
						const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

						// shift adjacent points by unit vectors to the left

						const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
						const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

						const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
						const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

						// scaling factor for v_prev to intersection point

						const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
								( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
							( v_prev_x * v_next_y - v_prev_y * v_next_x );

						// vector from inPt to intersection point

						v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
						v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

						// Don't normalize!, otherwise sharp corners become ugly
						//  but prevent crazy spikes
						const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
						if ( v_trans_lensq <= 2 ) {

							return new Vector2( v_trans_x, v_trans_y );

						} else {

							shrink_by = Math.sqrt( v_trans_lensq / 2 );

						}

					} else {

						// handle special case of collinear edges

						let direction_eq = false; // assumes: opposite

						if ( v_prev_x > Number.EPSILON ) {

							if ( v_next_x > Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( v_prev_x < - Number.EPSILON ) {

								if ( v_next_x < - Number.EPSILON ) {

									direction_eq = true;

								}

							} else {

								if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

									direction_eq = true;

								}

							}

						}

						if ( direction_eq ) {

							// console.log("Warning: lines are a straight sequence");
							v_trans_x = - v_prev_y;
							v_trans_y = v_prev_x;
							shrink_by = Math.sqrt( v_prev_lensq );

						} else {

							// console.log("Warning: lines are a straight spike");
							v_trans_x = v_prev_x;
							v_trans_y = v_prev_y;
							shrink_by = Math.sqrt( v_prev_lensq / 2 );

						}

					}

					return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

				}


				const contourMovements = [];

				for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					// console.log('i,j,k', i, j , k)

					contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

				}

				const holesMovements = [];
				let oneHoleMovements, verticesMovements = contourMovements.concat();

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					oneHoleMovements = [];

					for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

						if ( j === il ) j = 0;
						if ( k === il ) k = 0;

						//  (j)---(i)---(k)
						oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

					}

					holesMovements.push( oneHoleMovements );
					verticesMovements = verticesMovements.concat( oneHoleMovements );

				}


				// Loop bevelSegments, 1 for the front, 1 for the back

				for ( let b = 0; b < bevelSegments; b ++ ) {

					//for ( b = bevelSegments; b > 0; b -- ) {

					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos( t * Math.PI / 2 );
					const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

					// contract shape

					for ( let i = 0, il = contour.length; i < il; i ++ ) {

						const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

					// expand holes

					for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

						const ahole = holes[ h ];
						oneHoleMovements = holesMovements[ h ];

						for ( let i = 0, il = ahole.length; i < il; i ++ ) {

							const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

							v( vert.x, vert.y, - z );

						}

					}

				}

				const bs = bevelSize + bevelOffset;

				// Back facing vertices

				for ( let i = 0; i < vlen; i ++ ) {

					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, 0 );

					} else {

						// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

						normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

				// Add stepped vertices...
				// Including front facing vertices

				for ( let s = 1; s <= steps; s ++ ) {

					for ( let i = 0; i < vlen; i ++ ) {

						const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth / steps * s );

						} else {

							// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

							normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
							binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

							position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

							v( position2.x, position2.y, position2.z );

						}

					}

				}


				// Add bevel segments planes

				//for ( b = 1; b <= bevelSegments; b ++ ) {
				for ( let b = bevelSegments - 1; b >= 0; b -- ) {

					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos( t * Math.PI / 2 );
					const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

					// contract shape

					for ( let i = 0, il = contour.length; i < il; i ++ ) {

						const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
						v( vert.x, vert.y, depth + z );

					}

					// expand holes

					for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

						const ahole = holes[ h ];
						oneHoleMovements = holesMovements[ h ];

						for ( let i = 0, il = ahole.length; i < il; i ++ ) {

							const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

							if ( ! extrudeByPath ) {

								v( vert.x, vert.y, depth + z );

							} else {

								v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

							}

						}

					}

				}

				/* Faces */

				// Top and bottom faces

				buildLidFaces();

				// Sides faces

				buildSideFaces();


				/////  Internal functions

				function buildLidFaces() {

					const start = verticesArray.length / 3;

					if ( bevelEnabled ) {

						let layer = 0; // steps + 1
						let offset = vlen * layer;

						// Bottom faces

						for ( let i = 0; i < flen; i ++ ) {

							const face = faces[ i ];
							f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

						}

						layer = steps + bevelSegments * 2;
						offset = vlen * layer;

						// Top faces

						for ( let i = 0; i < flen; i ++ ) {

							const face = faces[ i ];
							f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

						}

					} else {

						// Bottom faces

						for ( let i = 0; i < flen; i ++ ) {

							const face = faces[ i ];
							f3( face[ 2 ], face[ 1 ], face[ 0 ] );

						}

						// Top faces

						for ( let i = 0; i < flen; i ++ ) {

							const face = faces[ i ];
							f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

						}

					}

					scope.addGroup( start, verticesArray.length / 3 - start, 0 );

				}

				// Create faces for the z-sides of the shape

				function buildSideFaces() {

					const start = verticesArray.length / 3;
					let layeroffset = 0;
					sidewalls( contour, layeroffset );
					layeroffset += contour.length;

					for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

						const ahole = holes[ h ];
						sidewalls( ahole, layeroffset );

						//, true
						layeroffset += ahole.length;

					}


					scope.addGroup( start, verticesArray.length / 3 - start, 1 );


				}

				function sidewalls( contour, layeroffset ) {

					let i = contour.length;

					while ( -- i >= 0 ) {

						const j = i;
						let k = i - 1;
						if ( k < 0 ) k = contour.length - 1;

						//console.log('b', i,j, i-1, k,vertices.length);

						for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

							const slen1 = vlen * s;
							const slen2 = vlen * ( s + 1 );

							const a = layeroffset + j + slen1,
								b = layeroffset + k + slen1,
								c = layeroffset + k + slen2,
								d = layeroffset + j + slen2;

							f4( a, b, c, d );

						}

					}

				}

				function v( x, y, z ) {

					placeholder.push( x );
					placeholder.push( y );
					placeholder.push( z );

				}


				function f3( a, b, c ) {

					addVertex( a );
					addVertex( b );
					addVertex( c );

					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

					addUV( uvs[ 0 ] );
					addUV( uvs[ 1 ] );
					addUV( uvs[ 2 ] );

				}

				function f4( a, b, c, d ) {

					addVertex( a );
					addVertex( b );
					addVertex( d );

					addVertex( b );
					addVertex( c );
					addVertex( d );


					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

					addUV( uvs[ 0 ] );
					addUV( uvs[ 1 ] );
					addUV( uvs[ 3 ] );

					addUV( uvs[ 1 ] );
					addUV( uvs[ 2 ] );
					addUV( uvs[ 3 ] );

				}

				function addVertex( index ) {

					verticesArray.push( placeholder[ index * 3 + 0 ] );
					verticesArray.push( placeholder[ index * 3 + 1 ] );
					verticesArray.push( placeholder[ index * 3 + 2 ] );

				}


				function addUV( vector2 ) {

					uvArray.push( vector2.x );
					uvArray.push( vector2.y );

				}

			}

		}

		toJSON() {

			const data = super.toJSON();

			const shapes = this.parameters.shapes;
			const options = this.parameters.options;

			return toJSON$1( shapes, options, data );

		}

		static fromJSON( data, shapes ) {

			const geometryShapes = [];

			for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

				const shape = shapes[ data.shapes[ j ] ];

				geometryShapes.push( shape );

			}

			const extrudePath = data.options.extrudePath;

			if ( extrudePath !== undefined ) {

				data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

			}

			return new ExtrudeGeometry( geometryShapes, data.options );

		}

	}

	const WorldUVGenerator = {

		generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

			const a_x = vertices[ indexA * 3 ];
			const a_y = vertices[ indexA * 3 + 1 ];
			const b_x = vertices[ indexB * 3 ];
			const b_y = vertices[ indexB * 3 + 1 ];
			const c_x = vertices[ indexC * 3 ];
			const c_y = vertices[ indexC * 3 + 1 ];

			return [
				new Vector2( a_x, a_y ),
				new Vector2( b_x, b_y ),
				new Vector2( c_x, c_y )
			];

		},

		generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

			const a_x = vertices[ indexA * 3 ];
			const a_y = vertices[ indexA * 3 + 1 ];
			const a_z = vertices[ indexA * 3 + 2 ];
			const b_x = vertices[ indexB * 3 ];
			const b_y = vertices[ indexB * 3 + 1 ];
			const b_z = vertices[ indexB * 3 + 2 ];
			const c_x = vertices[ indexC * 3 ];
			const c_y = vertices[ indexC * 3 + 1 ];
			const c_z = vertices[ indexC * 3 + 2 ];
			const d_x = vertices[ indexD * 3 ];
			const d_y = vertices[ indexD * 3 + 1 ];
			const d_z = vertices[ indexD * 3 + 2 ];

			if ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {

				return [
					new Vector2( a_x, 1 - a_z ),
					new Vector2( b_x, 1 - b_z ),
					new Vector2( c_x, 1 - c_z ),
					new Vector2( d_x, 1 - d_z )
				];

			} else {

				return [
					new Vector2( a_y, 1 - a_z ),
					new Vector2( b_y, 1 - b_z ),
					new Vector2( c_y, 1 - c_z ),
					new Vector2( d_y, 1 - d_z )
				];

			}

		}

	};

	function toJSON$1( shapes, options, data ) {

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( let i = 0, l = shapes.length; i < l; i ++ ) {

				const shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

		return data;

	}

	class ShapeGeometry extends BufferGeometry {

		constructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {

			super();
			this.type = 'ShapeGeometry';

			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let groupStart = 0;
			let groupCount = 0;

			// allow single and array values for "shapes" parameter

			if ( Array.isArray( shapes ) === false ) {

				addShape( shapes );

			} else {

				for ( let i = 0; i < shapes.length; i ++ ) {

					addShape( shapes[ i ] );

					this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

					groupStart += groupCount;
					groupCount = 0;

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


			// helper functions

			function addShape( shape ) {

				const indexOffset = vertices.length / 3;
				const points = shape.extractPoints( curveSegments );

				let shapeVertices = points.shape;
				const shapeHoles = points.holes;

				// check direction of vertices

				if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

					shapeVertices = shapeVertices.reverse();

				}

				for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

					const shapeHole = shapeHoles[ i ];

					if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

						shapeHoles[ i ] = shapeHole.reverse();

					}

				}

				const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

				// join vertices of inner and outer paths to a single array

				for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

					const shapeHole = shapeHoles[ i ];
					shapeVertices = shapeVertices.concat( shapeHole );

				}

				// vertices, normals, uvs

				for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

					const vertex = shapeVertices[ i ];

					vertices.push( vertex.x, vertex.y, 0 );
					normals.push( 0, 0, 1 );
					uvs.push( vertex.x, vertex.y ); // world uvs

				}

				// incides

				for ( let i = 0, l = faces.length; i < l; i ++ ) {

					const face = faces[ i ];

					const a = face[ 0 ] + indexOffset;
					const b = face[ 1 ] + indexOffset;
					const c = face[ 2 ] + indexOffset;

					indices.push( a, b, c );
					groupCount += 3;

				}

			}

		}

		toJSON() {

			const data = super.toJSON();

			const shapes = this.parameters.shapes;

			return toJSON( shapes, data );

		}

		static fromJSON( data, shapes ) {

			const geometryShapes = [];

			for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

				const shape = shapes[ data.shapes[ j ] ];

				geometryShapes.push( shape );

			}

			return new ShapeGeometry( geometryShapes, data.curveSegments );

		}

	}

	function toJSON( shapes, data ) {

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( let i = 0, l = shapes.length; i < l; i ++ ) {

				const shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		return data;

	}

	class ShadowMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'ShadowMaterial';

			this.color = new Color( 0x000000 );
			this.transparent = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			return this;

		}

	}

	ShadowMaterial.prototype.isShadowMaterial = true;

	class RawShaderMaterial extends ShaderMaterial {

		constructor( parameters ) {

			super( parameters );

			this.type = 'RawShaderMaterial';

		}

	}

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	class MeshStandardMaterial extends Material {

		constructor( parameters ) {

			super();

			this.defines = { 'STANDARD': '' };

			this.type = 'MeshStandardMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.roughness = 1.0;
			this.metalness = 0.0;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.roughnessMap = null;

			this.metalnessMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.envMapIntensity = 1.0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.flatShading = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.defines = { 'STANDARD': '' };

			this.color.copy( source.color );
			this.roughness = source.roughness;
			this.metalness = source.metalness;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.roughnessMap = source.roughnessMap;

			this.metalnessMap = source.metalnessMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.flatShading = source.flatShading;

			return this;

		}

	}

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	class MeshPhysicalMaterial extends MeshStandardMaterial {

		constructor( parameters ) {

			super();

			this.defines = {

				'STANDARD': '',
				'PHYSICAL': ''

			};

			this.type = 'MeshPhysicalMaterial';

			this.clearcoatMap = null;
			this.clearcoatRoughness = 0.0;
			this.clearcoatRoughnessMap = null;
			this.clearcoatNormalScale = new Vector2( 1, 1 );
			this.clearcoatNormalMap = null;

			this.ior = 1.5;

			Object.defineProperty( this, 'reflectivity', {
				get: function () {

					return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

				},
				set: function ( reflectivity ) {

					this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

				}
			} );

			this.sheenColor = new Color( 0x000000 );
			this.sheenColorMap = null;
			this.sheenRoughness = 1.0;
			this.sheenRoughnessMap = null;

			this.transmissionMap = null;

			this.thickness = 0;
			this.thicknessMap = null;
			this.attenuationDistance = 0.0;
			this.attenuationColor = new Color( 1, 1, 1 );

			this.specularIntensity = 1.0;
			this.specularIntensityMap = null;
			this.specularColor = new Color( 1, 1, 1 );
			this.specularColorMap = null;

			this._sheen = 0.0;
			this._clearcoat = 0;
			this._transmission = 0;

			this.setValues( parameters );

		}

		get sheen() {

			return this._sheen;

		}

		set sheen( value ) {

			if ( this._sheen > 0 !== value > 0 ) {

				this.version ++;

			}

			this._sheen = value;

		}

		get clearcoat() {

			return this._clearcoat;

		}

		set clearcoat( value ) {

			if ( this._clearcoat > 0 !== value > 0 ) {

				this.version ++;

			}

			this._clearcoat = value;

		}

		get transmission() {

			return this._transmission;

		}

		set transmission( value ) {

			if ( this._transmission > 0 !== value > 0 ) {

				this.version ++;

			}

			this._transmission = value;

		}

		copy( source ) {

			super.copy( source );

			this.defines = {

				'STANDARD': '',
				'PHYSICAL': ''

			};

			this.clearcoat = source.clearcoat;
			this.clearcoatMap = source.clearcoatMap;
			this.clearcoatRoughness = source.clearcoatRoughness;
			this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
			this.clearcoatNormalMap = source.clearcoatNormalMap;
			this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

			this.ior = source.ior;

			this.sheen = source.sheen;
			this.sheenColor.copy( source.sheenColor );
			this.sheenColorMap = source.sheenColorMap;
			this.sheenRoughness = source.sheenRoughness;
			this.sheenRoughnessMap = source.sheenRoughnessMap;

			this.transmission = source.transmission;
			this.transmissionMap = source.transmissionMap;

			this.thickness = source.thickness;
			this.thicknessMap = source.thicknessMap;
			this.attenuationDistance = source.attenuationDistance;
			this.attenuationColor.copy( source.attenuationColor );

			this.specularIntensity = source.specularIntensity;
			this.specularIntensityMap = source.specularIntensityMap;
			this.specularColor.copy( source.specularColor );
			this.specularColorMap = source.specularColorMap;

			return this;

		}

	}

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	class MeshPhongMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'MeshPhongMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.flatShading = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.flatShading = source.flatShading;

			return this;

		}

	}

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	class MeshToonMaterial extends Material {

		constructor( parameters ) {

			super();

			this.defines = { 'TOON': '' };

			this.type = 'MeshToonMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;
			this.gradientMap = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.alphaMap = null;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;
			this.gradientMap = source.gradientMap;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.alphaMap = source.alphaMap;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			return this;

		}

	}

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	class MeshNormalMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'MeshNormalMaterial';

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;

			this.flatShading = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.flatShading = source.flatShading;

			return this;

		}

	}

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	class MeshLambertMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'MeshLambertMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			return this;

		}

	}

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	class MeshMatcapMaterial extends Material {

		constructor( parameters ) {

			super();

			this.defines = { 'MATCAP': '' };

			this.type = 'MeshMatcapMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.matcap = null;

			this.map = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.alphaMap = null;

			this.flatShading = false;

			this.setValues( parameters );

		}


		copy( source ) {

			super.copy( source );

			this.defines = { 'MATCAP': '' };

			this.color.copy( source.color );

			this.matcap = source.matcap;

			this.map = source.map;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.alphaMap = source.alphaMap;

			this.flatShading = source.flatShading;

			return this;

		}

	}

	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

	class LineDashedMaterial extends LineBasicMaterial {

		constructor( parameters ) {

			super();

			this.type = 'LineDashedMaterial';

			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;

			return this;

		}

	}

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	const materialLib = {
		ShadowMaterial,
		SpriteMaterial,
		RawShaderMaterial,
		ShaderMaterial,
		PointsMaterial,
		MeshPhysicalMaterial,
		MeshStandardMaterial,
		MeshPhongMaterial,
		MeshToonMaterial,
		MeshNormalMaterial,
		MeshLambertMaterial,
		MeshDepthMaterial,
		MeshDistanceMaterial,
		MeshBasicMaterial,
		MeshMatcapMaterial,
		LineDashedMaterial,
		LineBasicMaterial,
		Material
	};

	Material.fromType = function ( type ) {

		return new materialLib[ type ]();

	};

	const AnimationUtils = {

		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function ( array, from, to ) {

			if ( AnimationUtils.isTypedArray( array ) ) {

				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

			}

			return array.slice( from, to );

		},

		// converts an array to a specific type
		convertArray: function ( array, type, forceClone ) {

			if ( ! array || // let 'undefined' and 'null' pass
				! forceClone && array.constructor === type ) return array;

			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

				return new type( array ); // create typed array

			}

			return Array.prototype.slice.call( array ); // create Array

		},

		isTypedArray: function ( object ) {

			return ArrayBuffer.isView( object ) &&
				! ( object instanceof DataView );

		},

		// returns an array by which times and values can be sorted
		getKeyframeOrder: function ( times ) {

			function compareTime( i, j ) {

				return times[ i ] - times[ j ];

			}

			const n = times.length;
			const result = new Array( n );
			for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

			result.sort( compareTime );

			return result;

		},

		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function ( values, stride, order ) {

			const nValues = values.length;
			const result = new values.constructor( nValues );

			for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

				const srcOffset = order[ i ] * stride;

				for ( let j = 0; j !== stride; ++ j ) {

					result[ dstOffset ++ ] = values[ srcOffset + j ];

				}

			}

			return result;

		},

		// function for parsing AOS keyframe formats
		flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

			let i = 1, key = jsonKeys[ 0 ];

			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

				key = jsonKeys[ i ++ ];

			}

			if ( key === undefined ) return; // no data

			let value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data

			if ( Array.isArray( value ) ) {

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push.apply( values, value ); // push all elements

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else if ( value.toArray !== undefined ) {

				// ...assume THREE.Math-ish

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						value.toArray( values, values.length );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else {

				// otherwise push as-is

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push( value );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			}

		},

		subclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {

			const clip = sourceClip.clone();

			clip.name = name;

			const tracks = [];

			for ( let i = 0; i < clip.tracks.length; ++ i ) {

				const track = clip.tracks[ i ];
				const valueSize = track.getValueSize();

				const times = [];
				const values = [];

				for ( let j = 0; j < track.times.length; ++ j ) {

					const frame = track.times[ j ] * fps;

					if ( frame < startFrame || frame >= endFrame ) continue;

					times.push( track.times[ j ] );

					for ( let k = 0; k < valueSize; ++ k ) {

						values.push( track.values[ j * valueSize + k ] );

					}

				}

				if ( times.length === 0 ) continue;

				track.times = AnimationUtils.convertArray( times, track.times.constructor );
				track.values = AnimationUtils.convertArray( values, track.values.constructor );

				tracks.push( track );

			}

			clip.tracks = tracks;

			// find minimum .times value across all tracks in the trimmed clip

			let minStartTime = Infinity;

			for ( let i = 0; i < clip.tracks.length; ++ i ) {

				if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

					minStartTime = clip.tracks[ i ].times[ 0 ];

				}

			}

			// shift all tracks such that clip begins at t=0

			for ( let i = 0; i < clip.tracks.length; ++ i ) {

				clip.tracks[ i ].shift( - 1 * minStartTime );

			}

			clip.resetDuration();

			return clip;

		},

		makeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

			if ( fps <= 0 ) fps = 30;

			const numTracks = referenceClip.tracks.length;
			const referenceTime = referenceFrame / fps;

			// Make each track's values relative to the values at the reference frame
			for ( let i = 0; i < numTracks; ++ i ) {

				const referenceTrack = referenceClip.tracks[ i ];
				const referenceTrackType = referenceTrack.ValueTypeName;

				// Skip this track if it's non-numeric
				if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

				// Find the track in the target clip whose name and type matches the reference track
				const targetTrack = targetClip.tracks.find( function ( track ) {

					return track.name === referenceTrack.name
						&& track.ValueTypeName === referenceTrackType;

				} );

				if ( targetTrack === undefined ) continue;

				let referenceOffset = 0;
				const referenceValueSize = referenceTrack.getValueSize();

				if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

					referenceOffset = referenceValueSize / 3;

				}

				let targetOffset = 0;
				const targetValueSize = targetTrack.getValueSize();

				if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

					targetOffset = targetValueSize / 3;

				}

				const lastIndex = referenceTrack.times.length - 1;
				let referenceValue;

				// Find the value to subtract out of the track
				if ( referenceTime <= referenceTrack.times[ 0 ] ) {

					// Reference frame is earlier than the first keyframe, so just use the first keyframe
					const startIndex = referenceOffset;
					const endIndex = referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

				} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

					// Reference frame is after the last keyframe, so just use the last keyframe
					const startIndex = lastIndex * referenceValueSize + referenceOffset;
					const endIndex = startIndex + referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

				} else {

					// Interpolate to the reference value
					const interpolant = referenceTrack.createInterpolant();
					const startIndex = referenceOffset;
					const endIndex = referenceValueSize - referenceOffset;
					interpolant.evaluate( referenceTime );
					referenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );

				}

				// Conjugate the quaternion
				if ( referenceTrackType === 'quaternion' ) {

					const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
					referenceQuat.toArray( referenceValue );

				}

				// Subtract the reference value from all of the track values

				const numTimes = targetTrack.times.length;
				for ( let j = 0; j < numTimes; ++ j ) {

					const valueStart = j * targetValueSize + targetOffset;

					if ( referenceTrackType === 'quaternion' ) {

						// Multiply the conjugate for quaternion track types
						Quaternion.multiplyQuaternionsFlat(
							targetTrack.values,
							valueStart,
							referenceValue,
							0,
							targetTrack.values,
							valueStart
						);

					} else {

						const valueEnd = targetValueSize - targetOffset * 2;

						// Subtract each value for all other numeric track types
						for ( let k = 0; k < valueEnd; ++ k ) {

							targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

						}

					}

				}

			}

			targetClip.blendMode = AdditiveAnimationBlendMode;

			return targetClip;

		}

	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 */

	class Interpolant {

		constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;

			this.resultBuffer = resultBuffer !== undefined ?
				resultBuffer : new sampleValues.constructor( sampleSize );
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;

			this.settings = null;
			this.DefaultSettings_ = {};

		}

		evaluate( t ) {

			const pp = this.parameterPositions;
			let i1 = this._cachedIndex,
				t1 = pp[ i1 ],
				t0 = pp[ i1 - 1 ];

			validate_interval: {

				seek: {

					let right;

					linear_scan: {

						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {

							for ( let giveUpAt = i1 + 2; ; ) {

								if ( t1 === undefined ) {

									if ( t < t0 ) break forward_scan;

									// after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t0 = t1;
								t1 = pp[ ++ i1 ];

								if ( t < t1 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;

						}

						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {

							// looping?

							const t1global = pp[ 1 ];

							if ( t < t1global ) {

								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;

							}

							// linear reverse scan

							for ( let giveUpAt = i1 - 2; ; ) {

								if ( t0 === undefined ) {

									// before start

									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t1 = t0;
								t0 = pp[ -- i1 - 1 ];

								if ( t >= t0 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;

						}

						// the interval is valid

						break validate_interval;

					} // linear scan

					// binary search

					while ( i1 < right ) {

						const mid = ( i1 + right ) >>> 1;

						if ( t < pp[ mid ] ) {

							right = mid;

						} else {

							i1 = mid + 1;

						}

					}

					t1 = pp[ i1 ];
					t0 = pp[ i1 - 1 ];

					// check boundary cases, again

					if ( t0 === undefined ) {

						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );

					}

					if ( t1 === undefined ) {

						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );

					}

				} // seek

				this._cachedIndex = i1;

				this.intervalChanged_( i1, t0, t1 );

			} // validate_interval

			return this.interpolate_( i1, t0, t, t1 );

		}

		getSettings_() {

			return this.settings || this.DefaultSettings_;

		}

		copySampleValue_( index ) {

			// copies a sample value to the result buffer

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;

			for ( let i = 0; i !== stride; ++ i ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		}

		// Template methods for derived classes:

		interpolate_( /* i1, t0, t, t1 */ ) {

			throw new Error( 'call to abstract method' );
			// implementations shall return this.resultBuffer

		}

		intervalChanged_( /* i1, t0, t1 */ ) {

			// empty

		}

	}

	// ALIAS DEFINITIONS

	Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
	Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 */

	class CubicInterpolant extends Interpolant {

		constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			super( parameterPositions, sampleValues, sampleSize, resultBuffer );

			this._weightPrev = - 0;
			this._offsetPrev = - 0;
			this._weightNext = - 0;
			this._offsetNext = - 0;

			this.DefaultSettings_ = {

				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding

			};

		}

		intervalChanged_( i1, t0, t1 ) {

			const pp = this.parameterPositions;
			let iPrev = i1 - 2,
				iNext = i1 + 1,

				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];

			if ( tPrev === undefined ) {

				switch ( this.getSettings_().endingStart ) {

					case ZeroSlopeEnding:

						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;

				}

			}

			if ( tNext === undefined ) {

				switch ( this.getSettings_().endingEnd ) {

					case ZeroSlopeEnding:

						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;

				}

			}

			const halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;

			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;

		}

		interpolate_( i1, t0, t, t1 ) {

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,

				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;

			// evaluate polynomials

			const sP = - wP * ppp + 2 * wP * pp - wP * p;
			const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
			const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
			const sN = wN * ppp - wN * pp;

			// combine data linearly

			for ( let i = 0; i !== stride; ++ i ) {

				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];

			}

			return result;

		}

	}

	class LinearInterpolant extends Interpolant {

		constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		interpolate_( i1, t0, t, t1 ) {

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset1 = i1 * stride,
				offset0 = offset1 - stride,

				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;

			for ( let i = 0; i !== stride; ++ i ) {

				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;

			}

			return result;

		}

	}

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceding
	 * the parameter.
	 */

	class DiscreteInterpolant extends Interpolant {

		constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		interpolate_( i1 /*, t0, t, t1 */ ) {

			return this.copySampleValue_( i1 - 1 );

		}

	}

	class KeyframeTrack {

		constructor( name, times, values, interpolation ) {

			if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
			if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

			this.name = name;

			this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
			this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

			this.setInterpolation( interpolation || this.DefaultInterpolation );

		}

		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):

		static toJSON( track ) {

			const trackType = track.constructor;

			let json;

			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== this.toJSON ) {

				json = trackType.toJSON( track );

			} else {

				// by default, we assume the data can be serialized as-is
				json = {

					'name': track.name,
					'times': AnimationUtils.convertArray( track.times, Array ),
					'values': AnimationUtils.convertArray( track.values, Array )

				};

				const interpolation = track.getInterpolation();

				if ( interpolation !== track.DefaultInterpolation ) {

					json.interpolation = interpolation;

				}

			}

			json.type = track.ValueTypeName; // mandatory

			return json;

		}

		InterpolantFactoryMethodDiscrete( result ) {

			return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

		}

		InterpolantFactoryMethodLinear( result ) {

			return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

		}

		InterpolantFactoryMethodSmooth( result ) {

			return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

		}

		setInterpolation( interpolation ) {

			let factoryMethod;

			switch ( interpolation ) {

				case InterpolateDiscrete:

					factoryMethod = this.InterpolantFactoryMethodDiscrete;

					break;

				case InterpolateLinear:

					factoryMethod = this.InterpolantFactoryMethodLinear;

					break;

				case InterpolateSmooth:

					factoryMethod = this.InterpolantFactoryMethodSmooth;

					break;

			}

			if ( factoryMethod === undefined ) {

				const message = 'unsupported interpolation for ' +
					this.ValueTypeName + ' keyframe track named ' + this.name;

				if ( this.createInterpolant === undefined ) {

					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {

						this.setInterpolation( this.DefaultInterpolation );

					} else {

						throw new Error( message ); // fatal, in this case

					}

				}

				console.warn( 'THREE.KeyframeTrack:', message );
				return this;

			}

			this.createInterpolant = factoryMethod;

			return this;

		}

		getInterpolation() {

			switch ( this.createInterpolant ) {

				case this.InterpolantFactoryMethodDiscrete:

					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:

					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:

					return InterpolateSmooth;

			}

		}

		getValueSize() {

			return this.values.length / this.times.length;

		}

		// move all keyframes either forwards or backwards in time
		shift( timeOffset ) {

			if ( timeOffset !== 0.0 ) {

				const times = this.times;

				for ( let i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] += timeOffset;

				}

			}

			return this;

		}

		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale( timeScale ) {

			if ( timeScale !== 1.0 ) {

				const times = this.times;

				for ( let i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] *= timeScale;

				}

			}

			return this;

		}

		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim( startTime, endTime ) {

			const times = this.times,
				nKeys = times.length;

			let from = 0,
				to = nKeys - 1;

			while ( from !== nKeys && times[ from ] < startTime ) {

				++ from;

			}

			while ( to !== - 1 && times[ to ] > endTime ) {

				-- to;

			}

			++ to; // inclusive -> exclusive bound

			if ( from !== 0 || to !== nKeys ) {

				// empty tracks are forbidden, so keep at least one keyframe
				if ( from >= to ) {

					to = Math.max( to, 1 );
					from = to - 1;

				}

				const stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice( times, from, to );
				this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

			}

			return this;

		}

		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate() {

			let valid = true;

			const valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {

				console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
				valid = false;

			}

			const times = this.times,
				values = this.values,

				nKeys = times.length;

			if ( nKeys === 0 ) {

				console.error( 'THREE.KeyframeTrack: Track is empty.', this );
				valid = false;

			}

			let prevTime = null;

			for ( let i = 0; i !== nKeys; i ++ ) {

				const currTime = times[ i ];

				if ( typeof currTime === 'number' && isNaN( currTime ) ) {

					console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
					valid = false;
					break;

				}

				if ( prevTime !== null && prevTime > currTime ) {

					console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
					valid = false;
					break;

				}

				prevTime = currTime;

			}

			if ( values !== undefined ) {

				if ( AnimationUtils.isTypedArray( values ) ) {

					for ( let i = 0, n = values.length; i !== n; ++ i ) {

						const value = values[ i ];

						if ( isNaN( value ) ) {

							console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
							valid = false;
							break;

						}

					}

				}

			}

			return valid;

		}

		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize() {

			// times or values may be shared with other tracks, so overwriting is unsafe
			const times = AnimationUtils.arraySlice( this.times ),
				values = AnimationUtils.arraySlice( this.values ),
				stride = this.getValueSize(),

				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

				lastIndex = times.length - 1;

			let writeIndex = 1;

			for ( let i = 1; i < lastIndex; ++ i ) {

				let keep = false;

				const time = times[ i ];
				const timeNext = times[ i + 1 ];

				// remove adjacent keyframes scheduled at the same time

				if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

					if ( ! smoothInterpolation ) {

						// remove unnecessary keyframes same as their neighbors

						const offset = i * stride,
							offsetP = offset - stride,
							offsetN = offset + stride;

						for ( let j = 0; j !== stride; ++ j ) {

							const value = values[ offset + j ];

							if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {

								keep = true;
								break;

							}

						}

					} else {

						keep = true;

					}

				}

				// in-place compaction

				if ( keep ) {

					if ( i !== writeIndex ) {

						times[ writeIndex ] = times[ i ];

						const readOffset = i * stride,
							writeOffset = writeIndex * stride;

						for ( let j = 0; j !== stride; ++ j ) {

							values[ writeOffset + j ] = values[ readOffset + j ];

						}

					}

					++ writeIndex;

				}

			}

			// flush last keyframe (compaction looks ahead)

			if ( lastIndex > 0 ) {

				times[ writeIndex ] = times[ lastIndex ];

				for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

					values[ writeOffset + j ] = values[ readOffset + j ];

				}

				++ writeIndex;

			}

			if ( writeIndex !== times.length ) {

				this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
				this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

			} else {

				this.times = times;
				this.values = values;

			}

			return this;

		}

		clone() {

			const times = AnimationUtils.arraySlice( this.times, 0 );
			const values = AnimationUtils.arraySlice( this.values, 0 );

			const TypedKeyframeTrack = this.constructor;
			const track = new TypedKeyframeTrack( this.name, times, values );

			// Interpolant argument to constructor is not saved, so copy the factory method directly.
			track.createInterpolant = this.createInterpolant;

			return track;

		}

	}

	KeyframeTrack.prototype.TimeBufferType = Float32Array;
	KeyframeTrack.prototype.ValueBufferType = Float32Array;
	KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

	/**
	 * A Track of Boolean keyframe values.
	 */
	class BooleanKeyframeTrack extends KeyframeTrack {}

	BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
	BooleanKeyframeTrack.prototype.ValueBufferType = Array;
	BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track of keyframe values that represent color.
	 */
	class ColorKeyframeTrack extends KeyframeTrack {}

	ColorKeyframeTrack.prototype.ValueTypeName = 'color';

	/**
	 * A Track of numeric keyframe values.
	 */
	class NumberKeyframeTrack extends KeyframeTrack {}

	NumberKeyframeTrack.prototype.ValueTypeName = 'number';

	/**
	 * Spherical linear unit quaternion interpolant.
	 */

	class QuaternionLinearInterpolant extends Interpolant {

		constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		interpolate_( i1, t0, t, t1 ) {

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				alpha = ( t - t0 ) / ( t1 - t0 );

			let offset = i1 * stride;

			for ( let end = offset + stride; offset !== end; offset += 4 ) {

				Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

			}

			return result;

		}

	}

	/**
	 * A Track of quaternion keyframe values.
	 */
	class QuaternionKeyframeTrack extends KeyframeTrack {

		InterpolantFactoryMethodLinear( result ) {

			return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

		}

	}

	QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
	// ValueBufferType is inherited
	QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
	QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track that interpolates Strings
	 */
	class StringKeyframeTrack extends KeyframeTrack {}

	StringKeyframeTrack.prototype.ValueTypeName = 'string';
	StringKeyframeTrack.prototype.ValueBufferType = Array;
	StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track of vectored keyframe values.
	 */
	class VectorKeyframeTrack extends KeyframeTrack {}

	VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

	class AnimationClip {

		constructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {

			this.name = name;
			this.tracks = tracks;
			this.duration = duration;
			this.blendMode = blendMode;

			this.uuid = generateUUID();

			// this means it should figure out its duration by scanning the tracks
			if ( this.duration < 0 ) {

				this.resetDuration();

			}

		}


		static parse( json ) {

			const tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );

			for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

				tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

			}

			const clip = new this( json.name, json.duration, tracks, json.blendMode );
			clip.uuid = json.uuid;

			return clip;

		}

		static toJSON( clip ) {

			const tracks = [],
				clipTracks = clip.tracks;

			const json = {

				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid,
				'blendMode': clip.blendMode

			};

			for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

				tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

			}

			return json;

		}

		static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

			const numMorphTargets = morphTargetSequence.length;
			const tracks = [];

			for ( let i = 0; i < numMorphTargets; i ++ ) {

				let times = [];
				let values = [];

				times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

				values.push( 0, 1, 0 );

				const order = AnimationUtils.getKeyframeOrder( times );
				times = AnimationUtils.sortedArray( times, 1, order );
				values = AnimationUtils.sortedArray( values, 1, order );

				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( ! noLoop && times[ 0 ] === 0 ) {

					times.push( numMorphTargets );
					values.push( values[ 0 ] );

				}

				tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );

			}

			return new this( name, - 1, tracks );

		}

		static findByName( objectOrClipArray, name ) {

			let clipArray = objectOrClipArray;

			if ( ! Array.isArray( objectOrClipArray ) ) {

				const o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;

			}

			for ( let i = 0; i < clipArray.length; i ++ ) {

				if ( clipArray[ i ].name === name ) {

					return clipArray[ i ];

				}

			}

			return null;

		}

		static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

			const animationToMorphTargets = {};

			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			const pattern = /^([\w-]*?)([\d]+)$/;

			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

				const morphTarget = morphTargets[ i ];
				const parts = morphTarget.name.match( pattern );

				if ( parts && parts.length > 1 ) {

					const name = parts[ 1 ];

					let animationMorphTargets = animationToMorphTargets[ name ];

					if ( ! animationMorphTargets ) {

						animationToMorphTargets[ name ] = animationMorphTargets = [];

					}

					animationMorphTargets.push( morphTarget );

				}

			}

			const clips = [];

			for ( const name in animationToMorphTargets ) {

				clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

			}

			return clips;

		}

		// parse the animation.hierarchy format
		static parseAnimation( animation, bones ) {

			if ( ! animation ) {

				console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
				return null;

			}

			const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {

					const times = [];
					const values = [];

					AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {

						destTracks.push( new trackType( trackName, times, values ) );

					}

				}

			};

			const tracks = [];

			const clipName = animation.name || 'default';
			const fps = animation.fps || 30;
			const blendMode = animation.blendMode;

			// automatic length determination in AnimationClip.
			let duration = animation.length || - 1;

			const hierarchyTracks = animation.hierarchy || [];

			for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

				const animationKeys = hierarchyTracks[ h ].keys;

				// skip empty tracks
				if ( ! animationKeys || animationKeys.length === 0 ) continue;

				// process morph targets
				if ( animationKeys[ 0 ].morphTargets ) {

					// figure out all morph targets used in this track
					const morphTargetNames = {};

					let k;

					for ( k = 0; k < animationKeys.length; k ++ ) {

						if ( animationKeys[ k ].morphTargets ) {

							for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

								morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

							}

						}

					}

					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( const morphTargetName in morphTargetNames ) {

						const times = [];
						const values = [];

						for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

							const animationKey = animationKeys[ k ];

							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

						}

						tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

					}

					duration = morphTargetNames.length * fps;

				} else {

					// ...assume skeletal animation

					const boneName = '.bones[' + bones[ h ].name + ']';

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

					addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

				}

			}

			if ( tracks.length === 0 ) {

				return null;

			}

			const clip = new this( clipName, duration, tracks, blendMode );

			return clip;

		}

		resetDuration() {

			const tracks = this.tracks;
			let duration = 0;

			for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

				const track = this.tracks[ i ];

				duration = Math.max( duration, track.times[ track.times.length - 1 ] );

			}

			this.duration = duration;

			return this;

		}

		trim() {

			for ( let i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].trim( 0, this.duration );

			}

			return this;

		}

		validate() {

			let valid = true;

			for ( let i = 0; i < this.tracks.length; i ++ ) {

				valid = valid && this.tracks[ i ].validate();

			}

			return valid;

		}

		optimize() {

			for ( let i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].optimize();

			}

			return this;

		}

		clone() {

			const tracks = [];

			for ( let i = 0; i < this.tracks.length; i ++ ) {

				tracks.push( this.tracks[ i ].clone() );

			}

			return new this.constructor( this.name, this.duration, tracks, this.blendMode );

		}

		toJSON() {

			return this.constructor.toJSON( this );

		}

	}

	function getTrackTypeForValueTypeName( typeName ) {

		switch ( typeName.toLowerCase() ) {

			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':

				return NumberKeyframeTrack;

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':

				return VectorKeyframeTrack;

			case 'color':

				return ColorKeyframeTrack;

			case 'quaternion':

				return QuaternionKeyframeTrack;

			case 'bool':
			case 'boolean':

				return BooleanKeyframeTrack;

			case 'string':

				return StringKeyframeTrack;

		}

		throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

	}

	function parseKeyframeTrack( json ) {

		if ( json.type === undefined ) {

			throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

		}

		const trackType = getTrackTypeForValueTypeName( json.type );

		if ( json.times === undefined ) {

			const times = [], values = [];

			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

			json.times = times;
			json.values = values;

		}

		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {

			return trackType.parse( json );

		} else {

			// by default, we assume a constructor compatible with the base
			return new trackType( json.name, json.times, json.values, json.interpolation );

		}

	}

	const Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	class LoadingManager {

		constructor( onLoad, onProgress, onError ) {

			const scope = this;

			let isLoading = false;
			let itemsLoaded = 0;
			let itemsTotal = 0;
			let urlModifier = undefined;
			const handlers = [];

			// Refer to #5689 for the reason why we don't set .onStart
			// in the constructor

			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;

			this.itemStart = function ( url ) {

				itemsTotal ++;

				if ( isLoading === false ) {

					if ( scope.onStart !== undefined ) {

						scope.onStart( url, itemsLoaded, itemsTotal );

					}

				}

				isLoading = true;

			};

			this.itemEnd = function ( url ) {

				itemsLoaded ++;

				if ( scope.onProgress !== undefined ) {

					scope.onProgress( url, itemsLoaded, itemsTotal );

				}

				if ( itemsLoaded === itemsTotal ) {

					isLoading = false;

					if ( scope.onLoad !== undefined ) {

						scope.onLoad();

					}

				}

			};

			this.itemError = function ( url ) {

				if ( scope.onError !== undefined ) {

					scope.onError( url );

				}

			};

			this.resolveURL = function ( url ) {

				if ( urlModifier ) {

					return urlModifier( url );

				}

				return url;

			};

			this.setURLModifier = function ( transform ) {

				urlModifier = transform;

				return this;

			};

			this.addHandler = function ( regex, loader ) {

				handlers.push( regex, loader );

				return this;

			};

			this.removeHandler = function ( regex ) {

				const index = handlers.indexOf( regex );

				if ( index !== - 1 ) {

					handlers.splice( index, 2 );

				}

				return this;

			};

			this.getHandler = function ( file ) {

				for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

					const regex = handlers[ i ];
					const loader = handlers[ i + 1 ];

					if ( regex.global ) regex.lastIndex = 0; // see #17920

					if ( regex.test( file ) ) {

						return loader;

					}

				}

				return null;

			};

		}

	}

	const DefaultLoadingManager = new LoadingManager();

	class Loader {

		constructor( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			this.crossOrigin = 'anonymous';
			this.withCredentials = false;
			this.path = '';
			this.resourcePath = '';
			this.requestHeader = {};

		}

		load( /* url, onLoad, onProgress, onError */ ) {}

		loadAsync( url, onProgress ) {

			const scope = this;

			return new Promise( function ( resolve, reject ) {

				scope.load( url, resolve, onProgress, reject );

			} );

		}

		parse( /* data */ ) {}

		setCrossOrigin( crossOrigin ) {

			this.crossOrigin = crossOrigin;
			return this;

		}

		setWithCredentials( value ) {

			this.withCredentials = value;
			return this;

		}

		setPath( path ) {

			this.path = path;
			return this;

		}

		setResourcePath( resourcePath ) {

			this.resourcePath = resourcePath;
			return this;

		}

		setRequestHeader( requestHeader ) {

			this.requestHeader = requestHeader;
			return this;

		}

	}

	const loading = {};

	class FileLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			const cached = Cache.get( url );

			if ( cached !== undefined ) {

				this.manager.itemStart( url );

				setTimeout( () => {

					if ( onLoad ) onLoad( cached );

					this.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			// Check if request is duplicate

			if ( loading[ url ] !== undefined ) {

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				return;

			}

			// Initialise array for duplicate requests
			loading[ url ] = [];

			loading[ url ].push( {
				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError,
			} );

			// create request
			const req = new Request( url, {
				headers: new Headers( this.requestHeader ),
				credentials: this.withCredentials ? 'include' : 'same-origin',
				// An abort controller could be added within a future PR
			} );

			// record states ( avoid data race )
			const mimeType = this.mimeType;
			const responseType = this.responseType;

			// start the fetch
			fetch( req )
				.then( response => {

					if ( response.status === 200 || response.status === 0 ) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						if ( response.status === 0 ) {

							console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

						}

						// Workaround: Checking if response.body === undefined for Alipay browser #23548

						if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {

							return response;

						}

						const callbacks = loading[ url ];
						const reader = response.body.getReader();
						const contentLength = response.headers.get( 'Content-Length' );
						const total = contentLength ? parseInt( contentLength ) : 0;
						const lengthComputable = total !== 0;
						let loaded = 0;

						// periodically read data into the new stream tracking while download progress
						const stream = new ReadableStream( {
							start( controller ) {

								readData();

								function readData() {

									reader.read().then( ( { done, value } ) => {

										if ( done ) {

											controller.close();

										} else {

											loaded += value.byteLength;

											const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
											for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

												const callback = callbacks[ i ];
												if ( callback.onProgress ) callback.onProgress( event );

											}

											controller.enqueue( value );
											readData();

										}

									} );

								}

							}

						} );

						return new Response( stream );

					} else {

						throw Error( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}` );

					}

				} )
				.then( response => {

					switch ( responseType ) {

						case 'arraybuffer':

							return response.arrayBuffer();

						case 'blob':

							return response.blob();

						case 'document':

							return response.text()
								.then( text => {

									const parser = new DOMParser();
									return parser.parseFromString( text, mimeType );

								} );

						case 'json':

							return response.json();

						default:

							if ( mimeType === undefined ) {

								return response.text();

							} else {

								// sniff encoding
								const re = /charset="?([^;"\s]*)"?/i;
								const exec = re.exec( mimeType );
								const label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;
								const decoder = new TextDecoder( label );
								return response.arrayBuffer().then( ab => decoder.decode( ab ) );

							}

					}

				} )
				.then( data => {

					// Add to cache only on HTTP success, so that we do not cache
					// error response bodies as proper responses to requests.
					Cache.add( url, data );

					const callbacks = loading[ url ];
					delete loading[ url ];

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onLoad ) callback.onLoad( data );

					}

				} )
				.catch( err => {

					// Abort errors and other errors are handled the same

					const callbacks = loading[ url ];

					if ( callbacks === undefined ) {

						// When onLoad was called and url was deleted in `loading`
						this.manager.itemError( url );
						throw err;

					}

					delete loading[ url ];

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( err );

					}

					this.manager.itemError( url );

				} )
				.finally( () => {

					this.manager.itemEnd( url );

				} );

			this.manager.itemStart( url );

		}

		setResponseType( value ) {

			this.responseType = value;
			return this;

		}

		setMimeType( value ) {

			this.mimeType = value;
			return this;

		}

	}

	class ImageLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			const scope = this;

			const cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			const image = createElementNS( 'img' );

			function onImageLoad() {

				removeEventListeners();

				Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}

			function onImageError( event ) {

				removeEventListeners();

				if ( onError ) onError( event );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}

			function removeEventListeners() {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

			}

			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );

			if ( url.slice( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		}

	}

	class CubeTextureLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( urls, onLoad, onProgress, onError ) {

			const texture = new CubeTexture();

			const loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			let loaded = 0;

			function loadTexture( i ) {

				loader.load( urls[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded ++;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, undefined, onError );

			}

			for ( let i = 0; i < urls.length; ++ i ) {

				loadTexture( i );

			}

			return texture;

		}

	}

	class TextureLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			const texture = new Texture();

			const loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		}

	}

	class Light extends Object3D {

		constructor( color, intensity = 1 ) {

			super();

			this.type = 'Light';

			this.color = new Color( color );
			this.intensity = intensity;

		}

		dispose() {

			// Empty here in base class; some subclasses override.

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

			return data;

		}

	}

	Light.prototype.isLight = true;

	class HemisphereLight extends Light {

		constructor( skyColor, groundColor, intensity ) {

			super( skyColor, intensity );

			this.type = 'HemisphereLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.groundColor = new Color( groundColor );

		}

		copy( source ) {

			Light.prototype.copy.call( this, source );

			this.groundColor.copy( source.groundColor );

			return this;

		}

	}

	HemisphereLight.prototype.isHemisphereLight = true;

	const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
	const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
	const _lookTarget$1 = /*@__PURE__*/ new Vector3();

	class LightShadow {

		constructor( camera ) {

			this.camera = camera;

			this.bias = 0;
			this.normalBias = 0;
			this.radius = 1;
			this.blurSamples = 8;

			this.mapSize = new Vector2( 512, 512 );

			this.map = null;
			this.mapPass = null;
			this.matrix = new Matrix4();

			this.autoUpdate = true;
			this.needsUpdate = false;

			this._frustum = new Frustum();
			this._frameExtents = new Vector2( 1, 1 );

			this._viewportCount = 1;

			this._viewports = [

				new Vector4( 0, 0, 1, 1 )

			];

		}

		getViewportCount() {

			return this._viewportCount;

		}

		getFrustum() {

			return this._frustum;

		}

		updateMatrices( light ) {

			const shadowCamera = this.camera;
			const shadowMatrix = this.matrix;

			_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( _lightPositionWorld$1 );

			_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( _lookTarget$1 );
			shadowCamera.updateMatrixWorld();

			_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);

			shadowMatrix.multiply( shadowCamera.projectionMatrix );
			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

		}

		getViewport( viewportIndex ) {

			return this._viewports[ viewportIndex ];

		}

		getFrameExtents() {

			return this._frameExtents;

		}

		dispose() {

			if ( this.map ) {

				this.map.dispose();

			}

			if ( this.mapPass ) {

				this.mapPass.dispose();

			}

		}

		copy( source ) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy( source.mapSize );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		toJSON() {

			const object = {};

			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;

			return object;

		}

	}

	class SpotLightShadow extends LightShadow {

		constructor() {

			super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

			this.focus = 1;

		}

		updateMatrices( light ) {

			const camera = this.camera;

			const fov = RAD2DEG * 2 * light.angle * this.focus;
			const aspect = this.mapSize.width / this.mapSize.height;
			const far = light.distance || camera.far;

			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();

			}

			super.updateMatrices( light );

		}

		copy( source ) {

			super.copy( source );

			this.focus = source.focus;

			return this;

		}

	}

	SpotLightShadow.prototype.isSpotLightShadow = true;

	class SpotLight extends Light {

		constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {

			super( color, intensity );

			this.type = 'SpotLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			this.distance = distance;
			this.angle = angle;
			this.penumbra = penumbra;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new SpotLightShadow();

		}

		get power() {

			// compute the light's luminous power (in lumens) from its intensity (in candela)
			// by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
			return this.intensity * Math.PI;

		}

		set power( power ) {

			// set the light's intensity (in candela) from the desired luminous power (in lumens)
			this.intensity = power / Math.PI;

		}

		dispose() {

			this.shadow.dispose();

		}

		copy( source ) {

			super.copy( source );

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	}

	SpotLight.prototype.isSpotLight = true;

	const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
	const _lightPositionWorld = /*@__PURE__*/ new Vector3();
	const _lookTarget = /*@__PURE__*/ new Vector3();

	class PointLightShadow extends LightShadow {

		constructor() {

			super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

			this._frameExtents = new Vector2( 4, 2 );

			this._viewportCount = 6;

			this._viewports = [
				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				new Vector4( 2, 1, 1, 1 ),
				// negative X
				new Vector4( 0, 1, 1, 1 ),
				// positive Z
				new Vector4( 3, 1, 1, 1 ),
				// negative Z
				new Vector4( 1, 1, 1, 1 ),
				// positive Y
				new Vector4( 3, 0, 1, 1 ),
				// negative Y
				new Vector4( 1, 0, 1, 1 )
			];

			this._cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
			];

			this._cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
			];

		}

		updateMatrices( light, viewportIndex = 0 ) {

			const camera = this.camera;
			const shadowMatrix = this.matrix;

			const far = light.distance || camera.far;

			if ( far !== camera.far ) {

				camera.far = far;
				camera.updateProjectionMatrix();

			}

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			camera.position.copy( _lightPositionWorld );

			_lookTarget.copy( camera.position );
			_lookTarget.add( this._cubeDirections[ viewportIndex ] );
			camera.up.copy( this._cubeUps[ viewportIndex ] );
			camera.lookAt( _lookTarget );
			camera.updateMatrixWorld();

			shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			this._frustum.setFromProjectionMatrix( _projScreenMatrix );

		}

	}

	PointLightShadow.prototype.isPointLightShadow = true;

	class PointLight extends Light {

		constructor( color, intensity, distance = 0, decay = 1 ) {

			super( color, intensity );

			this.type = 'PointLight';

			this.distance = distance;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new PointLightShadow();

		}

		get power() {

			// compute the light's luminous power (in lumens) from its intensity (in candela)
			// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
			return this.intensity * 4 * Math.PI;

		}

		set power( power ) {

			// set the light's intensity (in candela) from the desired luminous power (in lumens)
			this.intensity = power / ( 4 * Math.PI );

		}

		dispose() {

			this.shadow.dispose();

		}

		copy( source ) {

			super.copy( source );

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;

		}

	}

	PointLight.prototype.isPointLight = true;

	class DirectionalLightShadow extends LightShadow {

		constructor() {

			super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

		}

	}

	DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

	class DirectionalLight extends Light {

		constructor( color, intensity ) {

			super( color, intensity );

			this.type = 'DirectionalLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			this.shadow = new DirectionalLightShadow();

		}

		dispose() {

			this.shadow.dispose();

		}

		copy( source ) {

			super.copy( source );

			this.target = source.target.clone();
			this.shadow = source.shadow.clone();

			return this;

		}

	}

	DirectionalLight.prototype.isDirectionalLight = true;

	class AmbientLight extends Light {

		constructor( color, intensity ) {

			super( color, intensity );

			this.type = 'AmbientLight';

		}

	}

	AmbientLight.prototype.isAmbientLight = true;

	class RectAreaLight extends Light {

		constructor( color, intensity, width = 10, height = 10 ) {

			super( color, intensity );

			this.type = 'RectAreaLight';

			this.width = width;
			this.height = height;

		}

		get power() {

			// compute the light's luminous power (in lumens) from its intensity (in nits)
			return this.intensity * this.width * this.height * Math.PI;

		}

		set power( power ) {

			// set the light's intensity (in nits) from the desired luminous power (in lumens)
			this.intensity = power / ( this.width * this.height * Math.PI );

		}

		copy( source ) {

			super.copy( source );

			this.width = source.width;
			this.height = source.height;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.width = this.width;
			data.object.height = this.height;

			return data;

		}

	}

	RectAreaLight.prototype.isRectAreaLight = true;

	/**
	 * Primary reference:
	 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 *
	 * Secondary reference:
	 *   https://www.ppsloan.org/publications/StupidSH36.pdf
	 */

	// 3-band SH defined by 9 coefficients

	class SphericalHarmonics3 {

		constructor() {

			this.coefficients = [];

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients.push( new Vector3() );

			}

		}

		set( coefficients ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].copy( coefficients[ i ] );

			}

			return this;

		}

		zero() {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].set( 0, 0, 0 );

			}

			return this;

		}

		// get the radiance in the direction of the normal
		// target is a Vector3
		getAt( normal, target ) {

			// normal is assumed to be unit length

			const x = normal.x, y = normal.y, z = normal.z;

			const coeff = this.coefficients;

			// band 0
			target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

			// band 1
			target.addScaledVector( coeff[ 1 ], 0.488603 * y );
			target.addScaledVector( coeff[ 2 ], 0.488603 * z );
			target.addScaledVector( coeff[ 3 ], 0.488603 * x );

			// band 2
			target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
			target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
			target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
			target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
			target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

			return target;

		}

		// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
		// target is a Vector3
		// https://graphics.stanford.edu/papers/envmap/envmap.pdf
		getIrradianceAt( normal, target ) {

			// normal is assumed to be unit length

			const x = normal.x, y = normal.y, z = normal.z;

			const coeff = this.coefficients;

			// band 0
			target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); //  * 0.282095

			// band 1
			target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 *  / 3 ) * 0.488603
			target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
			target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

			// band 2
			target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // (  / 4 ) * 1.092548
			target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
			target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // (  / 4 ) * 0.315392 * 3
			target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
			target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // (  / 4 ) * 0.546274

			return target;

		}

		add( sh ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].add( sh.coefficients[ i ] );

			}

			return this;

		}

		addScaledSH( sh, s ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

			}

			return this;

		}

		scale( s ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].multiplyScalar( s );

			}

			return this;

		}

		lerp( sh, alpha ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

			}

			return this;

		}

		equals( sh ) {

			for ( let i = 0; i < 9; i ++ ) {

				if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

					return false;

				}

			}

			return true;

		}

		copy( sh ) {

			return this.set( sh.coefficients );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		fromArray( array, offset = 0 ) {

			const coefficients = this.coefficients;

			for ( let i = 0; i < 9; i ++ ) {

				coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const coefficients = this.coefficients;

			for ( let i = 0; i < 9; i ++ ) {

				coefficients[ i ].toArray( array, offset + ( i * 3 ) );

			}

			return array;

		}

		// evaluate the basis functions
		// shBasis is an Array[ 9 ]
		static getBasisAt( normal, shBasis ) {

			// normal is assumed to be unit length

			const x = normal.x, y = normal.y, z = normal.z;

			// band 0
			shBasis[ 0 ] = 0.282095;

			// band 1
			shBasis[ 1 ] = 0.488603 * y;
			shBasis[ 2 ] = 0.488603 * z;
			shBasis[ 3 ] = 0.488603 * x;

			// band 2
			shBasis[ 4 ] = 1.092548 * x * y;
			shBasis[ 5 ] = 1.092548 * y * z;
			shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
			shBasis[ 7 ] = 1.092548 * x * z;
			shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

		}

	}

	SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

	class LightProbe extends Light {

		constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

			super( undefined, intensity );

			this.sh = sh;

		}

		copy( source ) {

			super.copy( source );

			this.sh.copy( source.sh );

			return this;

		}

		fromJSON( json ) {

			this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
			this.sh.fromArray( json.sh );

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.sh = this.sh.toArray();

			return data;

		}

	}

	LightProbe.prototype.isLightProbe = true;

	class LoaderUtils {

		static decodeText( array ) {

			if ( typeof TextDecoder !== 'undefined' ) {

				return new TextDecoder().decode( array );

			}

			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.

			let s = '';

			for ( let i = 0, il = array.length; i < il; i ++ ) {

				// Implicitly assumes little-endian.
				s += String.fromCharCode( array[ i ] );

			}

			try {

				// merges multi-byte utf-8 characters.

				return decodeURIComponent( escape( s ) );

			} catch ( e ) { // see #16358

				return s;

			}

		}

		static extractUrlBase( url ) {

			const index = url.lastIndexOf( '/' );

			if ( index === - 1 ) return './';

			return url.slice( 0, index + 1 );

		}

		static resolveURL( url, path ) {

			// Invalid URL
			if ( typeof url !== 'string' || url === '' ) return '';

			// Host Relative URL
			if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

				path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

			}

			// Absolute URL http://,https://,//
			if ( /^(https?:)?\/\//i.test( url ) ) return url;

			// Data URI
			if ( /^data:.*,.*$/i.test( url ) ) return url;

			// Blob URL
			if ( /^blob:.*$/i.test( url ) ) return url;

			// Relative URL
			return path + url;

		}

	}

	class InstancedBufferGeometry extends BufferGeometry {

		constructor() {

			super();

			this.type = 'InstancedBufferGeometry';
			this.instanceCount = Infinity;

		}

		copy( source ) {

			super.copy( source );

			this.instanceCount = source.instanceCount;

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		toJSON() {

			const data = super.toJSON( this );

			data.instanceCount = this.instanceCount;

			data.isInstancedBufferGeometry = true;

			return data;

		}

	}

	InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

	class ImageBitmapLoader extends Loader {

		constructor( manager ) {

			super( manager );

			if ( typeof createImageBitmap === 'undefined' ) {

				console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

			}

			if ( typeof fetch === 'undefined' ) {

				console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

			}

			this.options = { premultiplyAlpha: 'none' };

		}

		setOptions( options ) {

			this.options = options;

			return this;

		}

		load( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			const scope = this;

			const cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			const fetchOptions = {};
			fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
			fetchOptions.headers = this.requestHeader;

			fetch( url, fetchOptions ).then( function ( res ) {

				return res.blob();

			} ).then( function ( blob ) {

				return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

			} ).then( function ( imageBitmap ) {

				Cache.add( url, imageBitmap );

				if ( onLoad ) onLoad( imageBitmap );

				scope.manager.itemEnd( url );

			} ).catch( function ( e ) {

				if ( onError ) onError( e );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

			scope.manager.itemStart( url );

		}

	}

	ImageBitmapLoader.prototype.isImageBitmapLoader = true;

	let _context;

	const AudioContext = {

		getContext: function () {

			if ( _context === undefined ) {

				_context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return _context;

		},

		setContext: function ( value ) {

			_context = value;

		}

	};

	class AudioLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;

			const loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.setPath( this.path );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( buffer ) {

				try {

					// Create a copy of the buffer. The `decodeAudioData` method
					// detaches the buffer when complete, preventing reuse.
					const bufferCopy = buffer.slice( 0 );

					const context = AudioContext.getContext();
					context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

						onLoad( audioBuffer );

					} );

				} catch ( e ) {

					if ( onError ) {

						onError( e );

					} else {

						console.error( e );

					}

					scope.manager.itemError( url );

				}

			}, onProgress, onError );

		}

	}

	class HemisphereLightProbe extends LightProbe {

		constructor( skyColor, groundColor, intensity = 1 ) {

			super( undefined, intensity );

			const color1 = new Color().set( skyColor );
			const color2 = new Color().set( groundColor );

			const sky = new Vector3( color1.r, color1.g, color1.b );
			const ground = new Vector3( color2.r, color2.g, color2.b );

			// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
			const c0 = Math.sqrt( Math.PI );
			const c1 = c0 * Math.sqrt( 0.75 );

			this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
			this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

		}

	}

	HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

	class AmbientLightProbe extends LightProbe {

		constructor( color, intensity = 1 ) {

			super( undefined, intensity );

			const color1 = new Color().set( color );

			// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
			this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

		}

	}

	AmbientLightProbe.prototype.isAmbientLightProbe = true;

	class Clock {

		constructor( autoStart = true ) {

			this.autoStart = autoStart;

			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;

			this.running = false;

		}

		start() {

			this.startTime = now();

			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;

		}

		stop() {

			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;

		}

		getElapsedTime() {

			this.getDelta();
			return this.elapsedTime;

		}

		getDelta() {

			let diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();
				return 0;

			}

			if ( this.running ) {

				const newTime = now();

				diff = ( newTime - this.oldTime ) / 1000;
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	}

	function now() {

		return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

	}

	class Audio extends Object3D {

		constructor( listener ) {

			super();

			this.type = 'Audio';

			this.listener = listener;
			this.context = listener.context;

			this.gain = this.context.createGain();
			this.gain.connect( listener.getInput() );

			this.autoplay = false;

			this.buffer = null;
			this.detune = 0;
			this.loop = false;
			this.loopStart = 0;
			this.loopEnd = 0;
			this.offset = 0;
			this.duration = undefined;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.source = null;
			this.sourceType = 'empty';

			this._startedAt = 0;
			this._progress = 0;
			this._connected = false;

			this.filters = [];

		}

		getOutput() {

			return this.gain;

		}

		setNodeSource( audioNode ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();

			return this;

		}

		setMediaElementSource( mediaElement ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource( mediaElement );
			this.connect();

			return this;

		}

		setMediaStreamSource( mediaStream ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'mediaStreamNode';
			this.source = this.context.createMediaStreamSource( mediaStream );
			this.connect();

			return this;

		}

		setBuffer( audioBuffer ) {

			this.buffer = audioBuffer;
			this.sourceType = 'buffer';

			if ( this.autoplay ) this.play();

			return this;

		}

		play( delay = 0 ) {

			if ( this.isPlaying === true ) {

				console.warn( 'THREE.Audio: Audio is already playing.' );
				return;

			}

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this._startedAt = this.context.currentTime + delay;

			const source = this.context.createBufferSource();
			source.buffer = this.buffer;
			source.loop = this.loop;
			source.loopStart = this.loopStart;
			source.loopEnd = this.loopEnd;
			source.onended = this.onEnded.bind( this );
			source.start( this._startedAt, this._progress + this.offset, this.duration );

			this.isPlaying = true;

			this.source = source;

			this.setDetune( this.detune );
			this.setPlaybackRate( this.playbackRate );

			return this.connect();

		}

		pause() {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			if ( this.isPlaying === true ) {

				// update current progress

				this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

				if ( this.loop === true ) {

					// ensure _progress does not exceed duration with looped audios

					this._progress = this._progress % ( this.duration || this.buffer.duration );

				}

				this.source.stop();
				this.source.onended = null;

				this.isPlaying = false;

			}

			return this;

		}

		stop() {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this._progress = 0;

			this.source.stop();
			this.source.onended = null;
			this.isPlaying = false;

			return this;

		}

		connect() {

			if ( this.filters.length > 0 ) {

				this.source.connect( this.filters[ 0 ] );

				for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].connect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

			} else {

				this.source.connect( this.getOutput() );

			}

			this._connected = true;

			return this;

		}

		disconnect() {

			if ( this.filters.length > 0 ) {

				this.source.disconnect( this.filters[ 0 ] );

				for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].disconnect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

			} else {

				this.source.disconnect( this.getOutput() );

			}

			this._connected = false;

			return this;

		}

		getFilters() {

			return this.filters;

		}

		setFilters( value ) {

			if ( ! value ) value = [];

			if ( this._connected === true ) {

				this.disconnect();
				this.filters = value.slice();
				this.connect();

			} else {

				this.filters = value.slice();

			}

			return this;

		}

		setDetune( value ) {

			this.detune = value;

			if ( this.source.detune === undefined ) return; // only set detune when available

			if ( this.isPlaying === true ) {

				this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

			}

			return this;

		}

		getDetune() {

			return this.detune;

		}

		getFilter() {

			return this.getFilters()[ 0 ];

		}

		setFilter( filter ) {

			return this.setFilters( filter ? [ filter ] : [] );

		}

		setPlaybackRate( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.playbackRate = value;

			if ( this.isPlaying === true ) {

				this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

			}

			return this;

		}

		getPlaybackRate() {

			return this.playbackRate;

		}

		onEnded() {

			this.isPlaying = false;

		}

		getLoop() {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;

			}

			return this.loop;

		}

		setLoop( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.loop = value;

			if ( this.isPlaying === true ) {

				this.source.loop = this.loop;

			}

			return this;

		}

		setLoopStart( value ) {

			this.loopStart = value;

			return this;

		}

		setLoopEnd( value ) {

			this.loopEnd = value;

			return this;

		}

		getVolume() {

			return this.gain.gain.value;

		}

		setVolume( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		}

	}

	class PropertyMixer {

		constructor( binding, typeName, valueSize ) {

			this.binding = binding;
			this.valueSize = valueSize;

			let mixFunction,
				mixFunctionAdditive,
				setIdentity;

			// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
			//
			// 'add' is used for additive cumulative results
			//
			// 'work' is optional and is only present for quaternion types. It is used
			// to store intermediate quaternion multiplication results

			switch ( typeName ) {

				case 'quaternion':
					mixFunction = this._slerp;
					mixFunctionAdditive = this._slerpAdditive;
					setIdentity = this._setAdditiveIdentityQuaternion;

					this.buffer = new Float64Array( valueSize * 6 );
					this._workIndex = 5;
					break;

				case 'string':
				case 'bool':
					mixFunction = this._select;

					// Use the regular mix function and for additive on these types,
					// additive is not relevant for non-numeric types
					mixFunctionAdditive = this._select;

					setIdentity = this._setAdditiveIdentityOther;

					this.buffer = new Array( valueSize * 5 );
					break;

				default:
					mixFunction = this._lerp;
					mixFunctionAdditive = this._lerpAdditive;
					setIdentity = this._setAdditiveIdentityNumeric;

					this.buffer = new Float64Array( valueSize * 5 );

			}

			this._mixBufferRegion = mixFunction;
			this._mixBufferRegionAdditive = mixFunctionAdditive;
			this._setIdentity = setIdentity;
			this._origIndex = 3;
			this._addIndex = 4;

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

			this.useCount = 0;
			this.referenceCount = 0;

		}

		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate( accuIndex, weight ) {

			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place

			const buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride;

			let currentWeight = this.cumulativeWeight;

			if ( currentWeight === 0 ) {

				// accuN := incoming * weight

				for ( let i = 0; i !== stride; ++ i ) {

					buffer[ offset + i ] = buffer[ i ];

				}

				currentWeight = weight;

			} else {

				// accuN := accuN + incoming * weight

				currentWeight += weight;
				const mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );

			}

			this.cumulativeWeight = currentWeight;

		}

		// accumulate data in the 'incoming' region into 'add'
		accumulateAdditive( weight ) {

			const buffer = this.buffer,
				stride = this.valueSize,
				offset = stride * this._addIndex;

			if ( this.cumulativeWeightAdditive === 0 ) {

				// add = identity

				this._setIdentity();

			}

			// add := add + incoming * weight

			this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
			this.cumulativeWeightAdditive += weight;

		}

		// apply the state of 'accu<i>' to the binding when accus differ
		apply( accuIndex ) {

			const stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,

				weight = this.cumulativeWeight,
				weightAdditive = this.cumulativeWeightAdditive,

				binding = this.binding;

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

			if ( weight < 1 ) {

				// accuN := accuN + original * ( 1 - cumulativeWeight )

				const originalValueOffset = stride * this._origIndex;

				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );

			}

			if ( weightAdditive > 0 ) {

				// accuN := accuN + additive accuN

				this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

			}

			for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

				if ( buffer[ i ] !== buffer[ i + stride ] ) {

					// value has changed -> update scene graph

					binding.setValue( buffer, offset );
					break;

				}

			}

		}

		// remember the state of the bound property and copy it to both accus
		saveOriginalState() {

			const binding = this.binding;

			const buffer = this.buffer,
				stride = this.valueSize,

				originalValueOffset = stride * this._origIndex;

			binding.getValue( buffer, originalValueOffset );

			// accu[0..1] := orig -- initially detect changes against the original
			for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

			}

			// Add to identity for additive
			this._setIdentity();

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

		}

		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState() {

			const originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );

		}

		_setAdditiveIdentityNumeric() {

			const startIndex = this._addIndex * this.valueSize;
			const endIndex = startIndex + this.valueSize;

			for ( let i = startIndex; i < endIndex; i ++ ) {

				this.buffer[ i ] = 0;

			}

		}

		_setAdditiveIdentityQuaternion() {

			this._setAdditiveIdentityNumeric();
			this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

		}

		_setAdditiveIdentityOther() {

			const startIndex = this._origIndex * this.valueSize;
			const targetIndex = this._addIndex * this.valueSize;

			for ( let i = 0; i < this.valueSize; i ++ ) {

				this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

			}

		}


		// mix functions

		_select( buffer, dstOffset, srcOffset, t, stride ) {

			if ( t >= 0.5 ) {

				for ( let i = 0; i !== stride; ++ i ) {

					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

				}

			}

		}

		_slerp( buffer, dstOffset, srcOffset, t ) {

			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

		}

		_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

			const workOffset = this._workIndex * stride;

			// Store result in intermediate buffer offset
			Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

			// Slerp to the intermediate result
			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

		}

		_lerp( buffer, dstOffset, srcOffset, t, stride ) {

			const s = 1 - t;

			for ( let i = 0; i !== stride; ++ i ) {

				const j = dstOffset + i;

				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

			}

		}

		_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

			for ( let i = 0; i !== stride; ++ i ) {

				const j = dstOffset + i;

				buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

			}

		}

	}

	// Characters [].:/ are reserved for track binding syntax.
	const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
	const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

	// Attempts to allow node names from any language. ES5's `\w` regexp matches
	// only latin characters, and the unicode \p{L} is not yet supported. So
	// instead, we exclude reserved characters and match everything else.
	const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
	const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

	// Parent directories, delimited by '/' or ':'. Currently unused, but must
	// be matched to parse the rest of the track name.
	const _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

	// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
	const _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

	// Object on target node, and accessor. May not contain reserved
	// characters. Accessor may contain any character except closing bracket.
	const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

	// Property and accessor. May not contain reserved characters. Accessor may
	// contain any non-bracket characters.
	const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

	const _trackRe = new RegExp( ''
		+ '^'
		+ _directoryRe
		+ _nodeRe
		+ _objectRe
		+ _propertyRe
		+ '$'
	);

	const _supportedObjectNames = [ 'material', 'materials', 'bones' ];

	class Composite {

		constructor( targetGroup, path, optionalParsedPath ) {

			const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_( path, parsedPath );

		}

		getValue( array, offset ) {

			this.bind(); // bind all binding

			const firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];

			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );

		}

		setValue( array, offset ) {

			const bindings = this._bindings;

			for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].setValue( array, offset );

			}

		}

		bind() {

			const bindings = this._bindings;

			for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].bind();

			}

		}

		unbind() {

			const bindings = this._bindings;

			for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].unbind();

			}

		}

	}

	// Note: This class uses a State pattern on a per-method basis:
	// 'bind' sets 'this.getValue' / 'setValue' and shadows the
	// prototype version of these methods with one that represents
	// the bound state. When the property is not found, the methods
	// become no-ops.
	class PropertyBinding {

		constructor( rootNode, path, parsedPath ) {

			this.path = path;
			this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

			this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

			this.rootNode = rootNode;

			// initial state of these methods that calls 'bind'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}


		static create( root, path, parsedPath ) {

			if ( ! ( root && root.isAnimationObjectGroup ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		}

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */
		static sanitizeNodeName( name ) {

			return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

		}

		static parseTrackName( trackName ) {

			const matches = _trackRe.exec( trackName );

			if ( matches === null ) {

				throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

			}

			const results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[ 2 ],
				objectName: matches[ 3 ],
				objectIndex: matches[ 4 ],
				propertyName: matches[ 5 ], // required
				propertyIndex: matches[ 6 ]
			};

			const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

			if ( lastDot !== undefined && lastDot !== - 1 ) {

				const objectName = results.nodeName.substring( lastDot + 1 );

				// Object names must be checked against an allowlist. Otherwise, there
				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
				// 'bar' could be the objectName, or part of a nodeName (which can
				// include '.' characters).
				if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

					results.nodeName = results.nodeName.substring( 0, lastDot );
					results.objectName = objectName;

				}

			}

			if ( results.propertyName === null || results.propertyName.length === 0 ) {

				throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

			}

			return results;

		}

		static findNode( root, nodeName ) {

			if ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				const bone = root.skeleton.getBoneByName( nodeName );

				if ( bone !== undefined ) {

					return bone;

				}

			}

			// search into node subtree.
			if ( root.children ) {

				const searchNodeSubtree = function ( children ) {

					for ( let i = 0; i < children.length; i ++ ) {

						const childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						const result = searchNodeSubtree( childNode.children );

						if ( result ) return result;

					}

					return null;

				};

				const subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		}

		// these are used to "bind" a nonexistent property
		_getValue_unavailable() {}
		_setValue_unavailable() {}

		// Getters

		_getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.targetObject[ this.propertyName ];

		}

		_getValue_array( buffer, offset ) {

			const source = this.resolvedProperty;

			for ( let i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		}

		_getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		}

		_getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

		// Direct

		_setValue_direct( buffer, offset ) {

			this.targetObject[ this.propertyName ] = buffer[ offset ];

		}

		_setValue_direct_setNeedsUpdate( buffer, offset ) {

			this.targetObject[ this.propertyName ] = buffer[ offset ];
			this.targetObject.needsUpdate = true;

		}

		_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

			this.targetObject[ this.propertyName ] = buffer[ offset ];
			this.targetObject.matrixWorldNeedsUpdate = true;

		}

		// EntireArray

		_setValue_array( buffer, offset ) {

			const dest = this.resolvedProperty;

			for ( let i = 0, n = dest.length; i !== n; ++ i ) {

				dest[ i ] = buffer[ offset ++ ];

			}

		}

		_setValue_array_setNeedsUpdate( buffer, offset ) {

			const dest = this.resolvedProperty;

			for ( let i = 0, n = dest.length; i !== n; ++ i ) {

				dest[ i ] = buffer[ offset ++ ];

			}

			this.targetObject.needsUpdate = true;

		}

		_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

			const dest = this.resolvedProperty;

			for ( let i = 0, n = dest.length; i !== n; ++ i ) {

				dest[ i ] = buffer[ offset ++ ];

			}

			this.targetObject.matrixWorldNeedsUpdate = true;

		}

		// ArrayElement

		_setValue_arrayElement( buffer, offset ) {

			this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

		}

		_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

			this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
			this.targetObject.needsUpdate = true;

		}

		_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

			this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
			this.targetObject.matrixWorldNeedsUpdate = true;

		}

		// HasToFromArray

		_setValue_fromArray( buffer, offset ) {

			this.resolvedProperty.fromArray( buffer, offset );

		}

		_setValue_fromArray_setNeedsUpdate( buffer, offset ) {

			this.resolvedProperty.fromArray( buffer, offset );
			this.targetObject.needsUpdate = true;

		}

		_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

			this.resolvedProperty.fromArray( buffer, offset );
			this.targetObject.matrixWorldNeedsUpdate = true;

		}

		_getValue_unbound( targetArray, offset ) {

			this.bind();
			this.getValue( targetArray, offset );

		}

		_setValue_unbound( sourceArray, offset ) {

			this.bind();
			this.setValue( sourceArray, offset );

		}

		// create getter / setter pair for a property in the scene graph
		bind() {

			let targetObject = this.node;
			const parsedPath = this.parsedPath;

			const objectName = parsedPath.objectName;
			const propertyName = parsedPath.propertyName;
			let propertyIndex = parsedPath.propertyIndex;

			if ( ! targetObject ) {

				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

				this.node = targetObject;

			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;

			// ensure there is a value node
			if ( ! targetObject ) {

				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
				return;

			}

			if ( objectName ) {

				let objectIndex = parsedPath.objectIndex;

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {

					case 'materials':

						if ( ! targetObject.material ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;

						}

						if ( ! targetObject.material.materials ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
							return;

						}

						targetObject = targetObject.material.materials;

						break;

					case 'bones':

						if ( ! targetObject.skeleton ) {

							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
							return;

						}

						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.

						targetObject = targetObject.skeleton.bones;

						// support resolving morphTarget names into indices.
						for ( let i = 0; i < targetObject.length; i ++ ) {

							if ( targetObject[ i ].name === objectIndex ) {

								objectIndex = i;
								break;

							}

						}

						break;

					default:

						if ( targetObject[ objectName ] === undefined ) {

							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
							return;

						}

						targetObject = targetObject[ objectName ];

				}


				if ( objectIndex !== undefined ) {

					if ( targetObject[ objectIndex ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
						return;

					}

					targetObject = targetObject[ objectIndex ];

				}

			}

			// resolve property
			const nodeProperty = targetObject[ propertyName ];

			if ( nodeProperty === undefined ) {

				const nodeName = parsedPath.nodeName;

				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject );
				return;

			}

			// determine versioning scheme
			let versioning = this.Versioning.None;

			this.targetObject = targetObject;

			if ( targetObject.needsUpdate !== undefined ) { // material

				versioning = this.Versioning.NeedsUpdate;

			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

				versioning = this.Versioning.MatrixWorldNeedsUpdate;

			}

			// determine how the property gets bound
			let bindingType = this.BindingType.Direct;

			if ( propertyIndex !== undefined ) {

				// access a sub element of the property array (only primitives are supported right now)

				if ( propertyName === 'morphTargetInfluences' ) {

					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
						return;

					}

					if ( targetObject.geometry.isBufferGeometry ) {

						if ( ! targetObject.geometry.morphAttributes ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
							return;

						}

						if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

							propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

						}


					} else {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
						return;

					}

				}

				bindingType = this.BindingType.ArrayElement;

				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;

			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray;

				this.resolvedProperty = nodeProperty;

			} else if ( Array.isArray( nodeProperty ) ) {

				bindingType = this.BindingType.EntireArray;

				this.resolvedProperty = nodeProperty;

			} else {

				this.propertyName = propertyName;

			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

		}

		unbind() {

			this.node = null;

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}

	}

	PropertyBinding.Composite = Composite;

	PropertyBinding.prototype.BindingType = {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	};

	PropertyBinding.prototype.Versioning = {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	};

	PropertyBinding.prototype.GetterByBindingType = [

		PropertyBinding.prototype._getValue_direct,
		PropertyBinding.prototype._getValue_array,
		PropertyBinding.prototype._getValue_arrayElement,
		PropertyBinding.prototype._getValue_toArray,

	];

	PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

		[
			// Direct
			PropertyBinding.prototype._setValue_direct,
			PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
			PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

		], [

			// EntireArray

			PropertyBinding.prototype._setValue_array,
			PropertyBinding.prototype._setValue_array_setNeedsUpdate,
			PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

		], [

			// ArrayElement
			PropertyBinding.prototype._setValue_arrayElement,
			PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
			PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

		], [

			// HasToFromArray
			PropertyBinding.prototype._setValue_fromArray,
			PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
			PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

		]

	];

	class AnimationAction {

		constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot;
			this.blendMode = blendMode;

			const tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array( nTracks );

			const interpolantSettings = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};

			for ( let i = 0; i !== nTracks; ++ i ) {

				const interpolant = tracks[ i ].createInterpolant( null );
				interpolants[ i ] = interpolant;
				interpolant.settings = interpolantSettings;

			}

			this._interpolantSettings = interpolantSettings;

			this._interpolants = interpolants; // bound by the mixer

			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array( nTracks );

			this._cacheIndex = null; // for the memory manager
			this._byClipCacheIndex = null; // for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;

			this.loop = LoopRepeat;
			this._loopCount = - 1;

			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null;

			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0;

			this.timeScale = 1;
			this._effectiveTimeScale = 1;

			this.weight = 1;
			this._effectiveWeight = 1;

			this.repetitions = Infinity; // no. of repetitions when looping

			this.paused = false; // true -> zero effective time scale
			this.enabled = true; // false -> zero effective weight

			this.clampWhenFinished = false;// keep feeding the last frame?

			this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
			this.zeroSlopeAtEnd = true;// clips for start, loop and end

		}

		// State & Scheduling

		play() {

			this._mixer._activateAction( this );

			return this;

		}

		stop() {

			this._mixer._deactivateAction( this );

			return this.reset();

		}

		reset() {

			this.paused = false;
			this.enabled = true;

			this.time = 0; // restart clip
			this._loopCount = - 1;// forget previous loops
			this._startTime = null;// forget scheduling

			return this.stopFading().stopWarping();

		}

		isRunning() {

			return this.enabled && ! this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction( this );

		}

		// return true when play has been called
		isScheduled() {

			return this._mixer._isActiveAction( this );

		}

		startAt( time ) {

			this._startTime = time;

			return this;

		}

		setLoop( mode, repetitions ) {

			this.loop = mode;
			this.repetitions = repetitions;

			return this;

		}

		// Weight

		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight( weight ) {

			this.weight = weight;

			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;

			return this.stopFading();

		}

		// return the weight considering fading and .enabled
		getEffectiveWeight() {

			return this._effectiveWeight;

		}

		fadeIn( duration ) {

			return this._scheduleFading( duration, 0, 1 );

		}

		fadeOut( duration ) {

			return this._scheduleFading( duration, 1, 0 );

		}

		crossFadeFrom( fadeOutAction, duration, warp ) {

			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );

			if ( warp ) {

				const fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,

					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;

				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );

			}

			return this;

		}

		crossFadeTo( fadeInAction, duration, warp ) {

			return fadeInAction.crossFadeFrom( this, duration, warp );

		}

		stopFading() {

			const weightInterpolant = this._weightInterpolant;

			if ( weightInterpolant !== null ) {

				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );

			}

			return this;

		}

		// Time Scale Control

		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale( timeScale ) {

			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;

			return this.stopWarping();

		}

		// return the time scale considering warping and .paused
		getEffectiveTimeScale() {

			return this._effectiveTimeScale;

		}

		setDuration( duration ) {

			this.timeScale = this._clip.duration / duration;

			return this.stopWarping();

		}

		syncWith( action ) {

			this.time = action.time;
			this.timeScale = action.timeScale;

			return this.stopWarping();

		}

		halt( duration ) {

			return this.warp( this._effectiveTimeScale, 0, duration );

		}

		warp( startTimeScale, endTimeScale, duration ) {

			const mixer = this._mixer,
				now = mixer.time,
				timeScale = this.timeScale;

			let interpolant = this._timeScaleInterpolant;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;

			}

			const times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			times[ 1 ] = now + duration;

			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;

			return this;

		}

		stopWarping() {

			const timeScaleInterpolant = this._timeScaleInterpolant;

			if ( timeScaleInterpolant !== null ) {

				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

			}

			return this;

		}

		// Object Accessors

		getMixer() {

			return this._mixer;

		}

		getClip() {

			return this._clip;

		}

		getRoot() {

			return this._localRoot || this._mixer._root;

		}

		// Interna

		_update( time, deltaTime, timeDirection, accuIndex ) {

			// called by the mixer

			if ( ! this.enabled ) {

				// call ._updateWeight() to update ._effectiveWeight

				this._updateWeight( time );
				return;

			}

			const startTime = this._startTime;

			if ( startTime !== null ) {

				// check for scheduled start of action

				const timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning < 0 || timeDirection === 0 ) {

					return; // yet to come / don't decide when delta = 0

				}

				// start

				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;

			}

			// apply time scale and advance time

			deltaTime *= this._updateTimeScale( time );
			const clipTime = this._updateTime( deltaTime );

			// note: _updateTime may disable the action resulting in
			// an effective weight of 0

			const weight = this._updateWeight( time );

			if ( weight > 0 ) {

				const interpolants = this._interpolants;
				const propertyMixers = this._propertyBindings;

				switch ( this.blendMode ) {

					case AdditiveAnimationBlendMode:

						for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

							interpolants[ j ].evaluate( clipTime );
							propertyMixers[ j ].accumulateAdditive( weight );

						}

						break;

					case NormalAnimationBlendMode:
					default:

						for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

							interpolants[ j ].evaluate( clipTime );
							propertyMixers[ j ].accumulate( accuIndex, weight );

						}

				}

			}

		}

		_updateWeight( time ) {

			let weight = 0;

			if ( this.enabled ) {

				weight = this.weight;
				const interpolant = this._weightInterpolant;

				if ( interpolant !== null ) {

					const interpolantValue = interpolant.evaluate( time )[ 0 ];

					weight *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopFading();

						if ( interpolantValue === 0 ) {

							// faded out, disable
							this.enabled = false;

						}

					}

				}

			}

			this._effectiveWeight = weight;
			return weight;

		}

		_updateTimeScale( time ) {

			let timeScale = 0;

			if ( ! this.paused ) {

				timeScale = this.timeScale;

				const interpolant = this._timeScaleInterpolant;

				if ( interpolant !== null ) {

					const interpolantValue = interpolant.evaluate( time )[ 0 ];

					timeScale *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopWarping();

						if ( timeScale === 0 ) {

							// motion has halted, pause
							this.paused = true;

						} else {

							// warp done - apply final time scale
							this.timeScale = timeScale;

						}

					}

				}

			}

			this._effectiveTimeScale = timeScale;
			return timeScale;

		}

		_updateTime( deltaTime ) {

			const duration = this._clip.duration;
			const loop = this.loop;

			let time = this.time + deltaTime;
			let loopCount = this._loopCount;

			const pingPong = ( loop === LoopPingPong );

			if ( deltaTime === 0 ) {

				if ( loopCount === - 1 ) return time;

				return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

			}

			if ( loop === LoopOnce ) {

				if ( loopCount === - 1 ) {

					// just started

					this._loopCount = 0;
					this._setEndings( true, true, false );

				}

				handle_stop: {

					if ( time >= duration ) {

						time = duration;

					} else if ( time < 0 ) {

						time = 0;

					} else {

						this.time = time;

						break handle_stop;

					}

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime < 0 ? - 1 : 1
					} );

				}

			} else { // repetitive Repeat or PingPong

				if ( loopCount === - 1 ) {

					// just started

					if ( deltaTime >= 0 ) {

						loopCount = 0;

						this._setEndings( true, this.repetitions === 0, pingPong );

					} else {

						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1

						this._setEndings( this.repetitions === 0, true, pingPong );

					}

				}

				if ( time >= duration || time < 0 ) {

					// wrap around

					const loopDelta = Math.floor( time / duration ); // signed
					time -= duration * loopDelta;

					loopCount += Math.abs( loopDelta );

					const pending = this.repetitions - loopCount;

					if ( pending <= 0 ) {

						// have to stop (switch state, clamp time, fire event)

						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;

						time = deltaTime > 0 ? duration : 0;

						this.time = time;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : - 1
						} );

					} else {

						// keep running

						if ( pending === 1 ) {

							// entering the last round

							const atStart = deltaTime < 0;
							this._setEndings( atStart, ! atStart, pingPong );

						} else {

							this._setEndings( false, false, pingPong );

						}

						this._loopCount = loopCount;

						this.time = time;

						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );

					}

				} else {

					this.time = time;

				}

				if ( pingPong && ( loopCount & 1 ) === 1 ) {

					// invert time for the "pong round"

					return duration - time;

				}

			}

			return time;

		}

		_setEndings( atStart, atEnd, pingPong ) {

			const settings = this._interpolantSettings;

			if ( pingPong ) {

				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;

			} else {

				// assuming for LoopOnce atStart == atEnd == true

				if ( atStart ) {

					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingStart = WrapAroundEnding;

				}

				if ( atEnd ) {

					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingEnd 	 = WrapAroundEnding;

				}

			}

		}

		_scheduleFading( duration, weightNow, weightThen ) {

			const mixer = this._mixer, now = mixer.time;
			let interpolant = this._weightInterpolant;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;

			}

			const times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;
			values[ 1 ] = weightThen;

			return this;

		}

	}

	class AnimationMixer extends EventDispatcher$1 {

		constructor( root ) {

			super();

			this._root = root;
			this._initMemoryManager();
			this._accuIndex = 0;
			this.time = 0;
			this.timeScale = 1.0;

		}

		_bindAction( action, prototypeAction ) {

			const root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName;

			let bindingsByName = bindingsByRoot[ rootUuid ];

			if ( bindingsByName === undefined ) {

				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;

			}

			for ( let i = 0; i !== nTracks; ++ i ) {

				const track = tracks[ i ],
					trackName = track.name;

				let binding = bindingsByName[ trackName ];

				if ( binding !== undefined ) {

					++ binding.referenceCount;
					bindings[ i ] = binding;

				} else {

					binding = bindings[ i ];

					if ( binding !== undefined ) {

						// existing binding, make sure the cache knows

						if ( binding._cacheIndex === null ) {

							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );

						}

						continue;

					}

					const path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

					binding = new PropertyMixer(
						PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );

					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );

					bindings[ i ] = binding;

				}

				interpolants[ i ].resultBuffer = binding.buffer;

			}

		}

		_activateAction( action ) {

			if ( ! this._isActiveAction( action ) ) {

				if ( action._cacheIndex === null ) {

					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind

					const rootUuid = ( action._localRoot || this._root ).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[ clipUuid ];

					this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );

					this._addInactiveAction( action, clipUuid, rootUuid );

				}

				const bindings = action._propertyBindings;

				// increment reference counts / sort out state
				for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

					const binding = bindings[ i ];

					if ( binding.useCount ++ === 0 ) {

						this._lendBinding( binding );
						binding.saveOriginalState();

					}

				}

				this._lendAction( action );

			}

		}

		_deactivateAction( action ) {

			if ( this._isActiveAction( action ) ) {

				const bindings = action._propertyBindings;

				// decrement reference counts / sort out state
				for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

					const binding = bindings[ i ];

					if ( -- binding.useCount === 0 ) {

						binding.restoreOriginalState();
						this._takeBackBinding( binding );

					}

				}

				this._takeBackAction( action );

			}

		}

		// Memory manager

		_initMemoryManager() {

			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;

			this._actionsByClip = {};
			// inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }


			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;

			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;

			const scope = this;

			this.stats = {

				actions: {
					get total() {

						return scope._actions.length;

					},
					get inUse() {

						return scope._nActiveActions;

					}
				},
				bindings: {
					get total() {

						return scope._bindings.length;

					},
					get inUse() {

						return scope._nActiveBindings;

					}
				},
				controlInterpolants: {
					get total() {

						return scope._controlInterpolants.length;

					},
					get inUse() {

						return scope._nActiveControlInterpolants;

					}
				}

			};

		}

		// Memory management for AnimationAction objects

		_isActiveAction( action ) {

			const index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;

		}

		_addInactiveAction( action, clipUuid, rootUuid ) {

			const actions = this._actions,
				actionsByClip = this._actionsByClip;

			let actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip === undefined ) {

				actionsForClip = {

					knownActions: [ action ],
					actionByRoot: {}

				};

				action._byClipCacheIndex = 0;

				actionsByClip[ clipUuid ] = actionsForClip;

			} else {

				const knownActions = actionsForClip.knownActions;

				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );

			}

			action._cacheIndex = actions.length;
			actions.push( action );

			actionsForClip.actionByRoot[ rootUuid ] = action;

		}

		_removeInactiveAction( action ) {

			const actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;

			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();

			action._cacheIndex = null;


			const clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ],
				knownActionsForClip = actionsForClip.knownActions,

				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],

				byClipCacheIndex = action._byClipCacheIndex;

			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();

			action._byClipCacheIndex = null;


			const actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( action._localRoot || this._root ).uuid;

			delete actionByRoot[ rootUuid ];

			if ( knownActionsForClip.length === 0 ) {

				delete actionsByClip[ clipUuid ];

			}

			this._removeInactiveBindingsForAction( action );

		}

		_removeInactiveBindingsForAction( action ) {

			const bindings = action._propertyBindings;

			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.referenceCount === 0 ) {

					this._removeInactiveBinding( binding );

				}

			}

		}

		_lendAction( action ) {

			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s

			const actions = this._actions,
				prevIndex = action._cacheIndex,

				lastActiveIndex = this._nActiveActions ++,

				firstInactiveAction = actions[ lastActiveIndex ];

			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;

			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;

		}

		_takeBackAction( action ) {

			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a

			const actions = this._actions,
				prevIndex = action._cacheIndex,

				firstInactiveIndex = -- this._nActiveActions,

				lastActiveAction = actions[ firstInactiveIndex ];

			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;

			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;

		}

		// Memory management for PropertyMixer objects

		_addInactiveBinding( binding, rootUuid, trackName ) {

			const bindingsByRoot = this._bindingsByRootAndName,
				bindings = this._bindings;

			let bindingByName = bindingsByRoot[ rootUuid ];

			if ( bindingByName === undefined ) {

				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;

			}

			bindingByName[ trackName ] = binding;

			binding._cacheIndex = bindings.length;
			bindings.push( binding );

		}

		_removeInactiveBinding( binding ) {

			const bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;

			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();

			delete bindingByName[ trackName ];

			if ( Object.keys( bindingByName ).length === 0 ) {

				delete bindingsByRoot[ rootUuid ];

			}

		}

		_lendBinding( binding ) {

			const bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				lastActiveIndex = this._nActiveBindings ++,

				firstInactiveBinding = bindings[ lastActiveIndex ];

			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;

			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;

		}

		_takeBackBinding( binding ) {

			const bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				firstInactiveIndex = -- this._nActiveBindings,

				lastActiveBinding = bindings[ firstInactiveIndex ];

			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;

			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;

		}


		// Memory management of Interpolants for weight and time scale

		_lendControlInterpolant() {

			const interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++;

			let interpolant = interpolants[ lastActiveIndex ];

			if ( interpolant === undefined ) {

				interpolant = new LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
					1, this._controlInterpolantsResultBuffer );

				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;

			}

			return interpolant;

		}

		_takeBackControlInterpolant( interpolant ) {

			const interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,

				firstInactiveIndex = -- this._nActiveControlInterpolants,

				lastActiveInterpolant = interpolants[ firstInactiveIndex ];

			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;

			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;

		}

		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction( clip, optionalRoot, blendMode ) {

			const root = optionalRoot || this._root,
				rootUuid = root.uuid;

			let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

			const clipUuid = clipObject !== null ? clipObject.uuid : clip;

			const actionsForClip = this._actionsByClip[ clipUuid ];
			let prototypeAction = null;

			if ( blendMode === undefined ) {

				if ( clipObject !== null ) {

					blendMode = clipObject.blendMode;

				} else {

					blendMode = NormalAnimationBlendMode;

				}

			}

			if ( actionsForClip !== undefined ) {

				const existingAction = actionsForClip.actionByRoot[ rootUuid ];

				if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

					return existingAction;

				}

				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];

				// also, take the clip from the prototype action
				if ( clipObject === null )
					clipObject = prototypeAction._clip;

			}

			// clip must be known when specified via string
			if ( clipObject === null ) return null;

			// allocate all resources required to run it
			const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

			this._bindAction( newAction, prototypeAction );

			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipUuid, rootUuid );

			return newAction;

		}

		// get an existing action
		existingAction( clip, optionalRoot ) {

			const root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				return actionsForClip.actionByRoot[ rootUuid ] || null;

			}

			return null;

		}

		// deactivates all previously scheduled actions
		stopAllAction() {

			const actions = this._actions,
				nActions = this._nActiveActions;

			for ( let i = nActions - 1; i >= 0; -- i ) {

				actions[ i ].stop();

			}

			return this;

		}

		// advance the time and update apply the animation
		update( deltaTime ) {

			deltaTime *= this.timeScale;

			const actions = this._actions,
				nActions = this._nActiveActions,

				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),

				accuIndex = this._accuIndex ^= 1;

			// run active actions

			for ( let i = 0; i !== nActions; ++ i ) {

				const action = actions[ i ];

				action._update( time, deltaTime, timeDirection, accuIndex );

			}

			// update scene graph

			const bindings = this._bindings,
				nBindings = this._nActiveBindings;

			for ( let i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].apply( accuIndex );

			}

			return this;

		}

		// Allows you to seek to a specific time in an animation.
		setTime( timeInSeconds ) {

			this.time = 0; // Zero out time attribute for AnimationMixer object;
			for ( let i = 0; i < this._actions.length; i ++ ) {

				this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

			}

			return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

		}

		// return this mixer's root target object
		getRoot() {

			return this._root;

		}

		// free all resources specific to a particular clip
		uncacheClip( clip ) {

			const actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away

				const actionsToRemove = actionsForClip.knownActions;

				for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

					const action = actionsToRemove[ i ];

					this._deactivateAction( action );

					const cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];

					action._cacheIndex = null;
					action._byClipCacheIndex = null;

					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction( action );

				}

				delete actionsByClip[ clipUuid ];

			}

		}

		// free all resources specific to a particular root target object
		uncacheRoot( root ) {

			const rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;

			for ( const clipUuid in actionsByClip ) {

				const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
					action = actionByRoot[ rootUuid ];

				if ( action !== undefined ) {

					this._deactivateAction( action );
					this._removeInactiveAction( action );

				}

			}

			const bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];

			if ( bindingByName !== undefined ) {

				for ( const trackName in bindingByName ) {

					const binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );

				}

			}

		}

		// remove a targeted clip from the cache
		uncacheAction( clip, optionalRoot ) {

			const action = this.existingAction( clip, optionalRoot );

			if ( action !== null ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

	}

	AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array( 1 );

	class InstancedInterleavedBuffer extends InterleavedBuffer {

		constructor( array, stride, meshPerAttribute = 1 ) {

			super( array, stride );

			this.meshPerAttribute = meshPerAttribute;

		}

		copy( source ) {

			super.copy( source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

		clone( data ) {

			const ib = super.clone( data );

			ib.meshPerAttribute = this.meshPerAttribute;

			return ib;

		}

		toJSON( data ) {

			const json = super.toJSON( data );

			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;

			return json;

		}

	}

	InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

	class Raycaster {

		constructor( origin, direction, near = 0, far = Infinity ) {

			this.ray = new Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near;
			this.far = far;
			this.camera = null;
			this.layers = new Layers();

			this.params = {
				Mesh: {},
				Line: { threshold: 1 },
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};

		}

		set( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		}

		setFromCamera( coords, camera ) {

			if ( camera.isPerspectiveCamera ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
				this.camera = camera;

			} else if ( camera.isOrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
				this.camera = camera;

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

			}

		}

		intersectObject( object, recursive = true, intersects = [] ) {

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		}

		intersectObjects( objects, recursive = true, intersects = [] ) {

			for ( let i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	}

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.layers.test( raycaster.layers ) ) {

			object.raycast( raycaster, intersects );

		}

		if ( recursive === true ) {

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */

	class Spherical {

		constructor( radius = 1, phi = 0, theta = 0 ) {

			this.radius = radius;
			this.phi = phi; // polar angle
			this.theta = theta; // azimuthal angle

			return this;

		}

		set( radius, phi, theta ) {

			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;

		}

		copy( other ) {

			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;

			return this;

		}

		// restrict phi to be between EPS and PI-EPS
		makeSafe() {

			const EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

			return this;

		}

		setFromVector3( v ) {

			return this.setFromCartesianCoords( v.x, v.y, v.z );

		}

		setFromCartesianCoords( x, y, z ) {

			this.radius = Math.sqrt( x * x + y * y + z * z );

			if ( this.radius === 0 ) {

				this.theta = 0;
				this.phi = 0;

			} else {

				this.theta = Math.atan2( x, z );
				this.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );

			}

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _vector$2 = /*@__PURE__*/ new Vector3();
	const _boneMatrix = /*@__PURE__*/ new Matrix4();
	const _matrixWorldInv = /*@__PURE__*/ new Matrix4();


	class SkeletonHelper extends LineSegments {

		constructor( object ) {

			const bones = getBoneList( object );

			const geometry = new BufferGeometry();

			const vertices = [];
			const colors = [];

			const color1 = new Color( 0, 0, 1 );
			const color2 = new Color( 0, 1, 0 );

			for ( let i = 0; i < bones.length; i ++ ) {

				const bone = bones[ i ];

				if ( bone.parent && bone.parent.isBone ) {

					vertices.push( 0, 0, 0 );
					vertices.push( 0, 0, 0 );
					colors.push( color1.r, color1.g, color1.b );
					colors.push( color2.r, color2.g, color2.b );

				}

			}

			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			const material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

			super( geometry, material );

			this.type = 'SkeletonHelper';
			this.isSkeletonHelper = true;

			this.root = object;
			this.bones = bones;

			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;

		}

		updateMatrixWorld( force ) {

			const bones = this.bones;

			const geometry = this.geometry;
			const position = geometry.getAttribute( 'position' );

			_matrixWorldInv.copy( this.root.matrixWorld ).invert();

			for ( let i = 0, j = 0; i < bones.length; i ++ ) {

				const bone = bones[ i ];

				if ( bone.parent && bone.parent.isBone ) {

					_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
					_vector$2.setFromMatrixPosition( _boneMatrix );
					position.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );

					_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
					_vector$2.setFromMatrixPosition( _boneMatrix );
					position.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );

					j += 2;

				}

			}

			geometry.getAttribute( 'position' ).needsUpdate = true;

			super.updateMatrixWorld( force );

		}

	}


	function getBoneList( object ) {

		const boneList = [];

		if ( object.isBone === true ) {

			boneList.push( object );

		}

		for ( let i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

		}

		return boneList;

	}

	class GridHelper extends LineSegments {

		constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

			color1 = new Color( color1 );
			color2 = new Color( color2 );

			const center = divisions / 2;
			const step = size / divisions;
			const halfSize = size / 2;

			const vertices = [], colors = [];

			for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

				vertices.push( - halfSize, 0, k, halfSize, 0, k );
				vertices.push( k, 0, - halfSize, k, 0, halfSize );

				const color = i === center ? color1 : color2;

				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;

			}

			const geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

			super( geometry, material );

			this.type = 'GridHelper';

		}

	}

	const _baseTable = new Uint32Array( 512 );
	const _shiftTable = new Uint32Array( 512 );

	for ( let i = 0; i < 256; ++ i ) {

		const e = i - 127;

		// very small number (0, -0)

		if ( e < - 27 ) {

			_baseTable[ i ] = 0x0000;
			_baseTable[ i | 0x100 ] = 0x8000;
			_shiftTable[ i ] = 24;
			_shiftTable[ i | 0x100 ] = 24;

			// small number (denorm)

		} else if ( e < - 14 ) {

			_baseTable[ i ] = 0x0400 >> ( - e - 14 );
			_baseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;
			_shiftTable[ i ] = - e - 1;
			_shiftTable[ i | 0x100 ] = - e - 1;

			// normal number

		} else if ( e <= 15 ) {

			_baseTable[ i ] = ( e + 15 ) << 10;
			_baseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;
			_shiftTable[ i ] = 13;
			_shiftTable[ i | 0x100 ] = 13;

			// large number (Infinity, -Infinity)

		} else if ( e < 128 ) {

			_baseTable[ i ] = 0x7c00;
			_baseTable[ i | 0x100 ] = 0xfc00;
			_shiftTable[ i ] = 24;
			_shiftTable[ i | 0x100 ] = 24;

			// stay (NaN, Infinity, -Infinity)

		} else {

			_baseTable[ i ] = 0x7c00;
			_baseTable[ i | 0x100 ] = 0xfc00;
			_shiftTable[ i ] = 13;
			_shiftTable[ i | 0x100 ] = 13;

		}

	}

	// float16 to float32 helpers

	const _mantissaTable = new Uint32Array( 2048 );
	const _exponentTable = new Uint32Array( 64 );
	const _offsetTable = new Uint32Array( 64 );

	for ( let i = 1; i < 1024; ++ i ) {

		let m = i << 13; // zero pad mantissa bits
		let e = 0; // zero exponent

		// normalized
		while ( ( m & 0x00800000 ) === 0 ) {

			m <<= 1;
			e -= 0x00800000; // decrement exponent

		}

		m &= ~ 0x00800000; // clear leading 1 bit
		e += 0x38800000; // adjust bias

		_mantissaTable[ i ] = m | e;

	}

	for ( let i = 1024; i < 2048; ++ i ) {

		_mantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );

	}

	for ( let i = 1; i < 31; ++ i ) {

		_exponentTable[ i ] = i << 23;

	}

	_exponentTable[ 31 ] = 0x47800000;
	_exponentTable[ 32 ] = 0x80000000;
	for ( let i = 33; i < 63; ++ i ) {

		_exponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );

	}

	_exponentTable[ 63 ] = 0xc7800000;

	for ( let i = 1; i < 64; ++ i ) {

		if ( i !== 32 ) {

			_offsetTable[ i ] = 1024;

		}

	}

	//

	Curve.create = function ( construct, getPoint ) {

		console.log( 'THREE.Curve.create() has been deprecated' );

		construct.prototype = Object.create( Curve.prototype );
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;

		return construct;

	};

	//

	Path.prototype.fromPoints = function ( points ) {

		console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
		return this.setFromPoints( points );

	};

	GridHelper.prototype.setColors = function () {

		console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

	};

	SkeletonHelper.prototype.update = function () {

		console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

	};

	//

	Loader.prototype.extractUrlBase = function ( url ) {

		console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
		return LoaderUtils.extractUrlBase( url );

	};

	Loader.Handlers = {

		add: function ( /* regex, loader */ ) {

			console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

		},

		get: function ( /* file */ ) {

			console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

		}

	};

	//

	Box3.prototype.center = function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	};

	Box3.prototype.empty = function () {

		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	};

	Box3.prototype.isIntersectionBox = function ( box ) {

		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	};

	Box3.prototype.isIntersectionSphere = function ( sphere ) {

		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	};

	Box3.prototype.size = function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	};

	//

	Euler.prototype.toVector3 = function () {

		console.error( 'THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead' );

	};


	//

	Sphere.prototype.empty = function () {

		console.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	};

	//

	Frustum.prototype.setFromMatrix = function ( m ) {

		console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
		return this.setFromProjectionMatrix( m );

	};

	//

	Matrix3.prototype.flattenToArrayOffset = function ( array, offset ) {

		console.warn( 'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
		return this.toArray( array, offset );

	};

	Matrix3.prototype.multiplyVector3 = function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	};

	Matrix3.prototype.multiplyVector3Array = function ( /* a */ ) {

		console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

	};

	Matrix3.prototype.applyToBufferAttribute = function ( attribute ) {

		console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
		return attribute.applyMatrix3( this );

	};

	Matrix3.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

		console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

	};

	Matrix3.prototype.getInverse = function ( matrix ) {

		console.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
		return this.copy( matrix ).invert();

	};

	//

	Matrix4.prototype.extractPosition = function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	};

	Matrix4.prototype.flattenToArrayOffset = function ( array, offset ) {

		console.warn( 'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
		return this.toArray( array, offset );

	};

	Matrix4.prototype.getPosition = function () {

		console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
		return new Vector3().setFromMatrixColumn( this, 3 );

	};

	Matrix4.prototype.setRotationFromQuaternion = function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
		return this.makeRotationFromQuaternion( q );

	};

	Matrix4.prototype.multiplyToArray = function () {

		console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

	};

	Matrix4.prototype.multiplyVector3 = function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	};

	Matrix4.prototype.multiplyVector4 = function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	};

	Matrix4.prototype.multiplyVector3Array = function ( /* a */ ) {

		console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

	};

	Matrix4.prototype.rotateAxis = function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
		v.transformDirection( this );

	};

	Matrix4.prototype.crossVector = function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	};

	Matrix4.prototype.translate = function () {

		console.error( 'THREE.Matrix4: .translate() has been removed.' );

	};

	Matrix4.prototype.rotateX = function () {

		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

	};

	Matrix4.prototype.rotateY = function () {

		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

	};

	Matrix4.prototype.rotateZ = function () {

		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

	};

	Matrix4.prototype.rotateByAxis = function () {

		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	};

	Matrix4.prototype.applyToBufferAttribute = function ( attribute ) {

		console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
		return attribute.applyMatrix4( this );

	};

	Matrix4.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

		console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

	};

	Matrix4.prototype.makeFrustum = function ( left, right, bottom, top, near, far ) {

		console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
		return this.makePerspective( left, right, top, bottom, near, far );

	};

	Matrix4.prototype.getInverse = function ( matrix ) {

		console.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
		return this.copy( matrix ).invert();

	};

	//

	Plane.prototype.isIntersectionLine = function ( line ) {

		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
		return this.intersectsLine( line );

	};

	//

	Quaternion.prototype.multiplyVector3 = function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	};

	Quaternion.prototype.inverse = function ( ) {

		console.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' );
		return this.invert();

	};

	//

	Ray.prototype.isIntersectionBox = function ( box ) {

		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	};

	Ray.prototype.isIntersectionPlane = function ( plane ) {

		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
		return this.intersectsPlane( plane );

	};

	Ray.prototype.isIntersectionSphere = function ( sphere ) {

		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	};

	//

	Triangle.prototype.area = function () {

		console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
		return this.getArea();

	};

	Triangle.prototype.barycoordFromPoint = function ( point, target ) {

		console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
		return this.getBarycoord( point, target );

	};

	Triangle.prototype.midpoint = function ( target ) {

		console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
		return this.getMidpoint( target );

	};

	Triangle.prototypenormal = function ( target ) {

		console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
		return this.getNormal( target );

	};

	Triangle.prototype.plane = function ( target ) {

		console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
		return this.getPlane( target );

	};

	Triangle.barycoordFromPoint = function ( point, a, b, c, target ) {

		console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
		return Triangle.getBarycoord( point, a, b, c, target );

	};

	Triangle.normal = function ( a, b, c, target ) {

		console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
		return Triangle.getNormal( a, b, c, target );

	};

	//

	Shape.prototype.extractAllPoints = function ( divisions ) {

		console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
		return this.extractPoints( divisions );

	};

	Shape.prototype.extrude = function ( options ) {

		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
		return new ExtrudeGeometry( this, options );

	};

	Shape.prototype.makeGeometry = function ( options ) {

		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
		return new ShapeGeometry( this, options );

	};

	//

	Vector2.prototype.fromAttribute = function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	};

	Vector2.prototype.distanceToManhattan = function ( v ) {

		console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
		return this.manhattanDistanceTo( v );

	};

	Vector2.prototype.lengthManhattan = function () {

		console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	};

	//

	Vector3.prototype.setEulerFromRotationMatrix = function () {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	};

	Vector3.prototype.setEulerFromQuaternion = function () {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	};

	Vector3.prototype.getPositionFromMatrix = function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
		return this.setFromMatrixPosition( m );

	};

	Vector3.prototype.getScaleFromMatrix = function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
		return this.setFromMatrixScale( m );

	};

	Vector3.prototype.getColumnFromMatrix = function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
		return this.setFromMatrixColumn( matrix, index );

	};

	Vector3.prototype.applyProjection = function ( m ) {

		console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
		return this.applyMatrix4( m );

	};

	Vector3.prototype.fromAttribute = function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	};

	Vector3.prototype.distanceToManhattan = function ( v ) {

		console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
		return this.manhattanDistanceTo( v );

	};

	Vector3.prototype.lengthManhattan = function () {

		console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	};

	//

	Vector4.prototype.fromAttribute = function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	};

	Vector4.prototype.lengthManhattan = function () {

		console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	};

	//

	Object3D.prototype.getChildByName = function ( name ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name );

	};

	Object3D.prototype.renderDepth = function () {

		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

	};

	Object3D.prototype.translate = function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	};

	Object3D.prototype.getWorldRotation = function () {

		console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

	};

	Object3D.prototype.applyMatrix = function ( matrix ) {

		console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
		return this.applyMatrix4( matrix );

	};

	Object.defineProperties( Object3D.prototype, {

		eulerOrder: {
			get: function () {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;

			},
			set: function ( value ) {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;

			}
		},
		useQuaternion: {
			get: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			},
			set: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			}
		}

	} );

	Mesh.prototype.setDrawMode = function () {

		console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

	};

	Object.defineProperties( Mesh.prototype, {

		drawMode: {
			get: function () {

				console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
				return TrianglesDrawMode;

			},
			set: function () {

				console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

			}
		}

	} );

	SkinnedMesh.prototype.initBones = function () {

		console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

	};

	//

	PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

		console.warn( 'THREE.PerspectiveCamera.setLens is deprecated. ' +
				'Use .setFocalLength and .filmGauge for a photographic setup.' );

		if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
		this.setFocalLength( focalLength );

	};

	//

	Object.defineProperties( Light.prototype, {
		onlyShadow: {
			set: function () {

				console.warn( 'THREE.Light: .onlyShadow has been removed.' );

			}
		},
		shadowCameraFov: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;

			}
		},
		shadowCameraLeft: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;

			}
		},
		shadowCameraRight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;

			}
		},
		shadowCameraTop: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;

			}
		},
		shadowCameraBottom: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;

			}
		},
		shadowCameraNear: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;

			}
		},
		shadowCameraFar: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;

			}
		},
		shadowCameraVisible: {
			set: function () {

				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

			}
		},
		shadowBias: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;

			}
		},
		shadowDarkness: {
			set: function () {

				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

			}
		},
		shadowMapWidth: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;

			}
		},
		shadowMapHeight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;

			}
		}
	} );

	//

	Object.defineProperties( BufferAttribute.prototype, {

		length: {
			get: function () {

				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
				return this.array.length;

			}
		},
		dynamic: {
			get: function () {

				console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
				return this.usage === DynamicDrawUsage;

			},
			set: function ( /* value */ ) {

				console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
				this.setUsage( DynamicDrawUsage );

			}
		}

	} );

	BufferAttribute.prototype.setDynamic = function ( value ) {

		console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
		this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
		return this;

	};

	BufferAttribute.prototype.copyIndicesArray = function ( /* indices */ ) {

		console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

	},

	BufferAttribute.prototype.setArray = function ( /* array */ ) {

		console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

	};

	//

	BufferGeometry.prototype.addIndex = function ( index ) {

		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
		this.setIndex( index );

	};

	BufferGeometry.prototype.addAttribute = function ( name, attribute ) {

		console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

		if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

		}

		if ( name === 'index' ) {

			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return this;

		}

		return this.setAttribute( name, attribute );

	};

	BufferGeometry.prototype.addDrawCall = function ( start, count, indexOffset ) {

		if ( indexOffset !== undefined ) {

			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

		}

		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
		this.addGroup( start, count );

	};

	BufferGeometry.prototype.clearDrawCalls = function () {

		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
		this.clearGroups();

	};

	BufferGeometry.prototype.computeOffsets = function () {

		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

	};

	BufferGeometry.prototype.removeAttribute = function ( name ) {

		console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

		return this.deleteAttribute( name );

	};

	BufferGeometry.prototype.applyMatrix = function ( matrix ) {

		console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
		return this.applyMatrix4( matrix );

	};

	Object.defineProperties( BufferGeometry.prototype, {

		drawcalls: {
			get: function () {

				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;

			}
		},
		offsets: {
			get: function () {

				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;

			}
		}

	} );

	InterleavedBuffer.prototype.setDynamic = function ( value ) {

		console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
		this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
		return this;

	};

	InterleavedBuffer.prototype.setArray = function ( /* array */ ) {

		console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

	};

	//

	ExtrudeGeometry.prototype.getArrays = function () {

		console.error( 'THREE.ExtrudeGeometry: .getArrays() has been removed.' );

	};

	ExtrudeGeometry.prototype.addShapeList = function () {

		console.error( 'THREE.ExtrudeGeometry: .addShapeList() has been removed.' );

	};

	ExtrudeGeometry.prototype.addShape = function () {

		console.error( 'THREE.ExtrudeGeometry: .addShape() has been removed.' );

	};

	//

	Scene.prototype.dispose = function () {

		console.error( 'THREE.Scene: .dispose() has been removed.' );

	};

	//

	Object.defineProperties( Material.prototype, {

		wrapAround: {
			get: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			}
		},

		overdraw: {
			get: function () {

				console.warn( 'THREE.Material: .overdraw has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .overdraw has been removed.' );

			}
		},

		wrapRGB: {
			get: function () {

				console.warn( 'THREE.Material: .wrapRGB has been removed.' );
				return new Color();

			}
		},

		shading: {
			get: function () {

				console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

			},
			set: function ( value ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( value === FlatShading );

			}
		},

		stencilMask: {
			get: function () {

				console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
				return this.stencilFuncMask;

			},
			set: function ( value ) {

				console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
				this.stencilFuncMask = value;

			}
		},

		vertexTangents: {
			get: function () {

				console.warn( 'THREE.' + this.type + ': .vertexTangents has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.' + this.type + ': .vertexTangents has been removed.' );

			}
		},

	} );

	Object.defineProperties( ShaderMaterial.prototype, {

		derivatives: {
			get: function () {

				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;

			},
			set: function ( value ) {

				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;

			}
		}

	} );

	//

	WebGLRenderer.prototype.clearTarget = function ( renderTarget, color, depth, stencil ) {

		console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	WebGLRenderer.prototype.animate = function ( callback ) {

		console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
		this.setAnimationLoop( callback );

	};

	WebGLRenderer.prototype.getCurrentRenderTarget = function () {

		console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
		return this.getRenderTarget();

	};

	WebGLRenderer.prototype.getMaxAnisotropy = function () {

		console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
		return this.capabilities.getMaxAnisotropy();

	};

	WebGLRenderer.prototype.getPrecision = function () {

		console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
		return this.capabilities.precision;

	};

	WebGLRenderer.prototype.resetGLState = function () {

		console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
		return this.state.reset();

	};

	WebGLRenderer.prototype.supportsFloatTextures = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
		return this.extensions.get( 'OES_texture_float' );

	};

	WebGLRenderer.prototype.supportsHalfFloatTextures = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
		return this.extensions.get( 'OES_texture_half_float' );

	};

	WebGLRenderer.prototype.supportsStandardDerivatives = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
		return this.extensions.get( 'OES_standard_derivatives' );

	};

	WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

	};

	WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	};

	WebGLRenderer.prototype.supportsBlendMinMax = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
		return this.extensions.get( 'EXT_blend_minmax' );

	};

	WebGLRenderer.prototype.supportsVertexTextures = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
		return this.capabilities.vertexTextures;

	};

	WebGLRenderer.prototype.supportsInstancedArrays = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
		return this.extensions.get( 'ANGLE_instanced_arrays' );

	};

	WebGLRenderer.prototype.enableScissorTest = function ( boolean ) {

		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
		this.setScissorTest( boolean );

	};

	WebGLRenderer.prototype.initMaterial = function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	};

	WebGLRenderer.prototype.addPrePlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	};

	WebGLRenderer.prototype.addPostPlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	};

	WebGLRenderer.prototype.updateShadowMap = function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	};

	WebGLRenderer.prototype.setFaceCulling = function () {

		console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

	};

	WebGLRenderer.prototype.allocTextureUnit = function () {

		console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

	};

	WebGLRenderer.prototype.setTexture = function () {

		console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

	};

	WebGLRenderer.prototype.setTexture2D = function () {

		console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

	};

	WebGLRenderer.prototype.setTextureCube = function () {

		console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

	};

	WebGLRenderer.prototype.getActiveMipMapLevel = function () {

		console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
		return this.getActiveMipmapLevel();

	};

	Object.defineProperties( WebGLRenderer.prototype, {

		shadowMapEnabled: {
			get: function () {

				return this.shadowMap.enabled;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;

			}
		},
		shadowMapType: {
			get: function () {

				return this.shadowMap.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;

			}
		},
		shadowMapCullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

			}
		},
		context: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
				return this.getContext();

			}
		},
		vr: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
				return this.xr;

			}
		},
		gammaInput: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
				return false;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

			}
		},
		gammaOutput: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
				return false;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
				this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;

			}
		},
		toneMappingWhitePoint: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );
				return 1.0;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );

			}
		},
		gammaFactor: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .gammaFactor has been removed.' );
				return 2;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .gammaFactor has been removed.' );

			}
		}
	} );

	Object.defineProperties( WebGLShadowMap.prototype, {

		cullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* cullFace */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderReverseSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderSingleSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

			}
		}

	} );

	//

	Object.defineProperties( WebGLRenderTarget.prototype, {

		wrapS: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;

			}
		},
		wrapT: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;

			}
		},
		magFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;

			}
		},
		minFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;

			}
		},
		anisotropy: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;

			}
		},
		offset: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;

			}
		},
		repeat: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;

			}
		},
		format: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;

			}
		},
		type: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;

			}
		},
		generateMipmaps: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;

			}
		}

	} );

	//

	Audio.prototype.load = function ( file ) {

		console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
		const scope = this;
		const audioLoader = new AudioLoader();
		audioLoader.load( file, function ( buffer ) {

			scope.setBuffer( buffer );

		} );
		return this;

	};

	//

	CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

		console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
		return this.update( renderer, scene );

	};

	CubeCamera.prototype.clear = function ( renderer, color, depth, stencil ) {

		console.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' );
		return this.renderTarget.clear( renderer, color, depth, stencil );

	};

	ImageUtils.crossOrigin = undefined;

	ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

		const loader = new TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		const texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	};

	ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

		const loader = new CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		const texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	};

	ImageUtils.loadCompressedTexture = function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

	};

	ImageUtils.loadCompressedTextureCube = function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

	};

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
			revision: REVISION,
		} } ) );

	}

	if ( typeof window !== 'undefined' ) {

		if ( window.__THREE__ ) {

			console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

		} else {

			window.__THREE__ = REVISION;

		}

	}

	const _taskCache = new WeakMap();

	class DRACOLoader extends Loader {

		constructor( manager ) {

			super( manager );

			this.decoderPath = '';
			this.decoderConfig = {};
			this.decoderBinary = null;
			this.decoderPending = null;

			this.workerLimit = 4;
			this.workerPool = [];
			this.workerNextTaskID = 1;
			this.workerSourceURL = '';

			this.defaultAttributeIDs = {
				position: 'POSITION',
				normal: 'NORMAL',
				color: 'COLOR',
				uv: 'TEX_COORD'
			};
			this.defaultAttributeTypes = {
				position: 'Float32Array',
				normal: 'Float32Array',
				color: 'Float32Array',
				uv: 'Float32Array'
			};

		}

		setDecoderPath( path ) {

			this.decoderPath = path;

			return this;

		}

		setDecoderConfig( config ) {

			this.decoderConfig = config;

			return this;

		}

		setWorkerLimit( workerLimit ) {

			this.workerLimit = workerLimit;

			return this;

		}

		load( url, onLoad, onProgress, onError ) {

			const loader = new FileLoader( this.manager );

			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( this.withCredentials );

			loader.load( url, ( buffer ) => {

				const taskConfig = {
					attributeIDs: this.defaultAttributeIDs,
					attributeTypes: this.defaultAttributeTypes,
					useUniqueIDs: false
				};

				this.decodeGeometry( buffer, taskConfig )
					.then( onLoad )
					.catch( onError );

			}, onProgress, onError );

		}

		/** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
		decodeDracoFile( buffer, callback, attributeIDs, attributeTypes ) {

			const taskConfig = {
				attributeIDs: attributeIDs || this.defaultAttributeIDs,
				attributeTypes: attributeTypes || this.defaultAttributeTypes,
				useUniqueIDs: !! attributeIDs
			};

			this.decodeGeometry( buffer, taskConfig ).then( callback );

		}

		decodeGeometry( buffer, taskConfig ) {

			// TODO: For backward-compatibility, support 'attributeTypes' objects containing
			// references (rather than names) to typed array constructors. These must be
			// serialized before sending them to the worker.
			for ( const attribute in taskConfig.attributeTypes ) {

				const type = taskConfig.attributeTypes[ attribute ];

				if ( type.BYTES_PER_ELEMENT !== undefined ) {

					taskConfig.attributeTypes[ attribute ] = type.name;

				}

			}

			//

			const taskKey = JSON.stringify( taskConfig );

			// Check for an existing task using this buffer. A transferred buffer cannot be transferred
			// again from this thread.
			if ( _taskCache.has( buffer ) ) {

				const cachedTask = _taskCache.get( buffer );

				if ( cachedTask.key === taskKey ) {

					return cachedTask.promise;

				} else if ( buffer.byteLength === 0 ) {

					// Technically, it would be possible to wait for the previous task to complete,
					// transfer the buffer back, and decode again with the second configuration. That
					// is complex, and I don't know of any reason to decode a Draco buffer twice in
					// different ways, so this is left unimplemented.
					throw new Error(

						'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +
						'settings. Buffer has already been transferred.'

					);

				}

			}

			//

			let worker;
			const taskID = this.workerNextTaskID ++;
			const taskCost = buffer.byteLength;

			// Obtain a worker and assign a task, and construct a geometry instance
			// when the task completes.
			const geometryPending = this._getWorker( taskID, taskCost )
				.then( ( _worker ) => {

					worker = _worker;

					return new Promise( ( resolve, reject ) => {

						worker._callbacks[ taskID ] = { resolve, reject };

						worker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );

						// this.debug();

					} );

				} )
				.then( ( message ) => this._createGeometry( message.geometry ) );

			// Remove task from the task list.
			// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)
			geometryPending
				.catch( () => true )
				.then( () => {

					if ( worker && taskID ) {

						this._releaseTask( worker, taskID );

						// this.debug();

					}

				} );

			// Cache the task result.
			_taskCache.set( buffer, {

				key: taskKey,
				promise: geometryPending

			} );

			return geometryPending;

		}

		_createGeometry( geometryData ) {

			const geometry = new BufferGeometry();

			if ( geometryData.index ) {

				geometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );

			}

			for ( let i = 0; i < geometryData.attributes.length; i ++ ) {

				const attribute = geometryData.attributes[ i ];
				const name = attribute.name;
				const array = attribute.array;
				const itemSize = attribute.itemSize;

				geometry.setAttribute( name, new BufferAttribute( array, itemSize ) );

			}

			return geometry;

		}

		_loadLibrary( url, responseType ) {

			const loader = new FileLoader( this.manager );
			loader.setPath( this.decoderPath );
			loader.setResponseType( responseType );
			loader.setWithCredentials( this.withCredentials );

			return new Promise( ( resolve, reject ) => {

				loader.load( url, resolve, undefined, reject );

			} );

		}

		preload() {

			this._initDecoder();

			return this;

		}

		_initDecoder() {

			if ( this.decoderPending ) return this.decoderPending;

			const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';
			const librariesPending = [];

			if ( useJS ) {

				librariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );

			} else {

				librariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );
				librariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );

			}

			this.decoderPending = Promise.all( librariesPending )
				.then( ( libraries ) => {

					const jsContent = libraries[ 0 ];

					if ( ! useJS ) {

						this.decoderConfig.wasmBinary = libraries[ 1 ];

					}

					const fn = DRACOWorker.toString();

					const body = [
						'/* draco decoder */',
						jsContent,
						'',
						'/* worker */',
						fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )
					].join( '\n' );

					this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );

				} );

			return this.decoderPending;

		}

		_getWorker( taskID, taskCost ) {

			return this._initDecoder().then( () => {

				if ( this.workerPool.length < this.workerLimit ) {

					const worker = new Worker( this.workerSourceURL );

					worker._callbacks = {};
					worker._taskCosts = {};
					worker._taskLoad = 0;

					worker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );

					worker.onmessage = function ( e ) {

						const message = e.data;

						switch ( message.type ) {

							case 'decode':
								worker._callbacks[ message.id ].resolve( message );
								break;

							case 'error':
								worker._callbacks[ message.id ].reject( message );
								break;

							default:
								console.error( 'THREE.DRACOLoader: Unexpected message, "' + message.type + '"' );

						}

					};

					this.workerPool.push( worker );

				} else {

					this.workerPool.sort( function ( a, b ) {

						return a._taskLoad > b._taskLoad ? - 1 : 1;

					} );

				}

				const worker = this.workerPool[ this.workerPool.length - 1 ];
				worker._taskCosts[ taskID ] = taskCost;
				worker._taskLoad += taskCost;
				return worker;

			} );

		}

		_releaseTask( worker, taskID ) {

			worker._taskLoad -= worker._taskCosts[ taskID ];
			delete worker._callbacks[ taskID ];
			delete worker._taskCosts[ taskID ];

		}

		debug() {

			console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );

		}

		dispose() {

			for ( let i = 0; i < this.workerPool.length; ++ i ) {

				this.workerPool[ i ].terminate();

			}

			this.workerPool.length = 0;

			return this;

		}

	}

	/* WEB WORKER */

	function DRACOWorker() {

		let decoderConfig;
		let decoderPending;

		onmessage = function ( e ) {

			const message = e.data;

			switch ( message.type ) {

				case 'init':
					decoderConfig = message.decoderConfig;
					decoderPending = new Promise( function ( resolve/*, reject*/ ) {

						decoderConfig.onModuleLoaded = function ( draco ) {

							// Module is Promise-like. Wrap before resolving to avoid loop.
							resolve( { draco: draco } );

						};

						DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef

					} );
					break;

				case 'decode':
					const buffer = message.buffer;
					const taskConfig = message.taskConfig;
					decoderPending.then( ( module ) => {

						const draco = module.draco;
						const decoder = new draco.Decoder();
						const decoderBuffer = new draco.DecoderBuffer();
						decoderBuffer.Init( new Int8Array( buffer ), buffer.byteLength );

						try {

							const geometry = decodeGeometry( draco, decoder, decoderBuffer, taskConfig );

							const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );

							if ( geometry.index ) buffers.push( geometry.index.array.buffer );

							self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );

						} catch ( error ) {

							console.error( error );

							self.postMessage( { type: 'error', id: message.id, error: error.message } );

						} finally {

							draco.destroy( decoderBuffer );
							draco.destroy( decoder );

						}

					} );
					break;

			}

		};

		function decodeGeometry( draco, decoder, decoderBuffer, taskConfig ) {

			const attributeIDs = taskConfig.attributeIDs;
			const attributeTypes = taskConfig.attributeTypes;

			let dracoGeometry;
			let decodingStatus;

			const geometryType = decoder.GetEncodedGeometryType( decoderBuffer );

			if ( geometryType === draco.TRIANGULAR_MESH ) {

				dracoGeometry = new draco.Mesh();
				decodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );

			} else if ( geometryType === draco.POINT_CLOUD ) {

				dracoGeometry = new draco.PointCloud();
				decodingStatus = decoder.DecodeBufferToPointCloud( decoderBuffer, dracoGeometry );

			} else {

				throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );

			}

			if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {

				throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );

			}

			const geometry = { index: null, attributes: [] };

			// Gather all vertex attributes.
			for ( const attributeName in attributeIDs ) {

				const attributeType = self[ attributeTypes[ attributeName ] ];

				let attribute;
				let attributeID;

				// A Draco file may be created with default vertex attributes, whose attribute IDs
				// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
				// a Draco file may contain a custom set of attributes, identified by known unique
				// IDs. glTF files always do the latter, and `.drc` files typically do the former.
				if ( taskConfig.useUniqueIDs ) {

					attributeID = attributeIDs[ attributeName ];
					attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );

				} else {

					attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );

					if ( attributeID === - 1 ) continue;

					attribute = decoder.GetAttribute( dracoGeometry, attributeID );

				}

				geometry.attributes.push( decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) );

			}

			// Add index.
			if ( geometryType === draco.TRIANGULAR_MESH ) {

				geometry.index = decodeIndex( draco, decoder, dracoGeometry );

			}

			draco.destroy( dracoGeometry );

			return geometry;

		}

		function decodeIndex( draco, decoder, dracoGeometry ) {

			const numFaces = dracoGeometry.num_faces();
			const numIndices = numFaces * 3;
			const byteLength = numIndices * 4;

			const ptr = draco._malloc( byteLength );
			decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );
			const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();
			draco._free( ptr );

			return { array: index, itemSize: 1 };

		}

		function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {

			const numComponents = attribute.num_components();
			const numPoints = dracoGeometry.num_points();
			const numValues = numPoints * numComponents;
			const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
			const dataType = getDracoDataType( draco, attributeType );

			const ptr = draco._malloc( byteLength );
			decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );
			const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();
			draco._free( ptr );

			return {
				name: attributeName,
				array: array,
				itemSize: numComponents
			};

		}

		function getDracoDataType( draco, attributeType ) {

			switch ( attributeType ) {

				case Float32Array: return draco.DT_FLOAT32;
				case Int8Array: return draco.DT_INT8;
				case Int16Array: return draco.DT_INT16;
				case Int32Array: return draco.DT_INT32;
				case Uint8Array: return draco.DT_UINT8;
				case Uint16Array: return draco.DT_UINT16;
				case Uint32Array: return draco.DT_UINT32;

			}

		}

	}

	class GLTFLoader extends Loader {

		constructor( manager ) {

			super( manager );

			this.dracoLoader = null;
			this.ktx2Loader = null;
			this.meshoptDecoder = null;

			this.pluginCallbacks = [];

			this.register( function ( parser ) {

				return new GLTFMaterialsClearcoatExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFTextureBasisUExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFTextureWebPExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFMaterialsSheenExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFMaterialsTransmissionExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFMaterialsVolumeExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFMaterialsIorExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFMaterialsSpecularExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFLightsExtension( parser );

			} );

			this.register( function ( parser ) {

				return new GLTFMeshoptCompression( parser );

			} );

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;

			let resourcePath;

			if ( this.resourcePath !== '' ) {

				resourcePath = this.resourcePath;

			} else if ( this.path !== '' ) {

				resourcePath = this.path;

			} else {

				resourcePath = LoaderUtils.extractUrlBase( url );

			}

			// Tells the LoadingManager to track an extra item, which resolves after
			// the model is fully loaded. This means the count of items loaded will
			// be incorrect, but ensures manager.onLoad() does not fire early.
			this.manager.itemStart( url );

			const _onError = function ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			};

			const loader = new FileLoader( this.manager );

			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( this.withCredentials );

			loader.load( url, function ( data ) {

				try {

					scope.parse( data, resourcePath, function ( gltf ) {

						onLoad( gltf );

						scope.manager.itemEnd( url );

					}, _onError );

				} catch ( e ) {

					_onError( e );

				}

			}, onProgress, _onError );

		}

		setDRACOLoader( dracoLoader ) {

			this.dracoLoader = dracoLoader;
			return this;

		}

		setDDSLoader() {

			throw new Error(

				'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

			);

		}

		setKTX2Loader( ktx2Loader ) {

			this.ktx2Loader = ktx2Loader;
			return this;

		}

		setMeshoptDecoder( meshoptDecoder ) {

			this.meshoptDecoder = meshoptDecoder;
			return this;

		}

		register( callback ) {

			if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

				this.pluginCallbacks.push( callback );

			}

			return this;

		}

		unregister( callback ) {

			if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

				this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

			}

			return this;

		}

		parse( data, path, onLoad, onError ) {

			let content;
			const extensions = {};
			const plugins = {};

			if ( typeof data === 'string' ) {

				content = data;

			} else {

				const magic = LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

				if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

					try {

						extensions[ EXTENSIONS$1.KHR_BINARY_GLTF ] = new GLTFBinaryExtension$1( data );

					} catch ( error ) {

						if ( onError ) onError( error );
						return;

					}

					content = extensions[ EXTENSIONS$1.KHR_BINARY_GLTF ].content;

				} else {

					content = LoaderUtils.decodeText( new Uint8Array( data ) );

				}

			}

			const json = JSON.parse( content );

			if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

				if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
				return;

			}

			const parser = new GLTFParser$1( json, {

				path: path || this.resourcePath || '',
				crossOrigin: this.crossOrigin,
				requestHeader: this.requestHeader,
				manager: this.manager,
				ktx2Loader: this.ktx2Loader,
				meshoptDecoder: this.meshoptDecoder

			} );

			parser.fileLoader.setRequestHeader( this.requestHeader );

			for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

				const plugin = this.pluginCallbacks[ i ]( parser );
				plugins[ plugin.name ] = plugin;

				// Workaround to avoid determining as unknown extension
				// in addUnknownExtensionsToUserData().
				// Remove this workaround if we move all the existing
				// extension handlers to plugin system
				extensions[ plugin.name ] = true;

			}

			if ( json.extensionsUsed ) {

				for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

					const extensionName = json.extensionsUsed[ i ];
					const extensionsRequired = json.extensionsRequired || [];

					switch ( extensionName ) {

						case EXTENSIONS$1.KHR_MATERIALS_UNLIT:
							extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
							break;

						case EXTENSIONS$1.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
							extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
							break;

						case EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION:
							extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
							break;

						case EXTENSIONS$1.KHR_TEXTURE_TRANSFORM:
							extensions[ extensionName ] = new GLTFTextureTransformExtension();
							break;

						case EXTENSIONS$1.KHR_MESH_QUANTIZATION:
							extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
							break;

						default:

							if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

								console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

							}

					}

				}

			}

			parser.setExtensions( extensions );
			parser.setPlugins( plugins );
			parser.parse( onLoad, onError );

		}

		parseAsync( data, path ) {

			const scope = this;

			return new Promise( function ( resolve, reject ) {

				scope.parse( data, path, resolve, reject );

			} );

		}

	}

	/* GLTFREGISTRY */

	function GLTFRegistry$1() {

		let objects = {};

		return	{

			get: function ( key ) {

				return objects[ key ];

			},

			add: function ( key, object ) {

				objects[ key ] = object;

			},

			remove: function ( key ) {

				delete objects[ key ];

			},

			removeAll: function () {

				objects = {};

			}

		};

	}

	/*********************************/
	/********** EXTENSIONS ***********/
	/*********************************/

	const EXTENSIONS$1 = {
		KHR_BINARY_GLTF: 'KHR_binary_glTF',
		KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
		KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
		KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
		KHR_MATERIALS_IOR: 'KHR_materials_ior',
		KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
		KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
		KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
		KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
		KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
		KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
		KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
		KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
		KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
		EXT_TEXTURE_WEBP: 'EXT_texture_webp',
		EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
	};

	/**
	 * Punctual Lights Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
	 */
	class GLTFLightsExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS$1.KHR_LIGHTS_PUNCTUAL;

			// Object3D instance caches
			this.cache = { refs: {}, uses: {} };

		}

		_markDefs() {

			const parser = this.parser;
			const nodeDefs = this.parser.json.nodes || [];

			for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

				const nodeDef = nodeDefs[ nodeIndex ];

				if ( nodeDef.extensions
						&& nodeDef.extensions[ this.name ]
						&& nodeDef.extensions[ this.name ].light !== undefined ) {

					parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

				}

			}

		}

		_loadLight( lightIndex ) {

			const parser = this.parser;
			const cacheKey = 'light:' + lightIndex;
			let dependency = parser.cache.get( cacheKey );

			if ( dependency ) return dependency;

			const json = parser.json;
			const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
			const lightDefs = extensions.lights || [];
			const lightDef = lightDefs[ lightIndex ];
			let lightNode;

			const color = new Color( 0xffffff );

			if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

			const range = lightDef.range !== undefined ? lightDef.range : 0;

			switch ( lightDef.type ) {

				case 'directional':
					lightNode = new DirectionalLight( color );
					lightNode.target.position.set( 0, 0, - 1 );
					lightNode.add( lightNode.target );
					break;

				case 'point':
					lightNode = new PointLight( color );
					lightNode.distance = range;
					break;

				case 'spot':
					lightNode = new SpotLight( color );
					lightNode.distance = range;
					// Handle spotlight properties.
					lightDef.spot = lightDef.spot || {};
					lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
					lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
					lightNode.angle = lightDef.spot.outerConeAngle;
					lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
					lightNode.target.position.set( 0, 0, - 1 );
					lightNode.add( lightNode.target );
					break;

				default:
					throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

			}

			// Some lights (e.g. spot) default to a position other than the origin. Reset the position
			// here, because node-level parsing will only override position if explicitly specified.
			lightNode.position.set( 0, 0, 0 );

			lightNode.decay = 2;

			if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

			lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

			dependency = Promise.resolve( lightNode );

			parser.cache.add( cacheKey, dependency );

			return dependency;

		}

		createNodeAttachment( nodeIndex ) {

			const self = this;
			const parser = this.parser;
			const json = parser.json;
			const nodeDef = json.nodes[ nodeIndex ];
			const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
			const lightIndex = lightDef.light;

			if ( lightIndex === undefined ) return null;

			return this._loadLight( lightIndex ).then( function ( light ) {

				return parser._getNodeRef( self.cache, lightIndex, light );

			} );

		}

	}

	/**
	 * Unlit Materials Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
	 */
	class GLTFMaterialsUnlitExtension {

		constructor() {

			this.name = EXTENSIONS$1.KHR_MATERIALS_UNLIT;

		}

		getMaterialType() {

			return MeshBasicMaterial;

		}

		extendParams( materialParams, materialDef, parser ) {

			const pending = [];

			materialParams.color = new Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			const metallicRoughness = materialDef.pbrMetallicRoughness;

			if ( metallicRoughness ) {

				if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

					const array = metallicRoughness.baseColorFactor;

					materialParams.color.fromArray( array );
					materialParams.opacity = array[ 3 ];

				}

				if ( metallicRoughness.baseColorTexture !== undefined ) {

					pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding ) );

				}

			}

			return Promise.all( pending );

		}

	}

	/**
	 * Clearcoat Materials Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
	 */
	class GLTFMaterialsClearcoatExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS$1.KHR_MATERIALS_CLEARCOAT;

		}

		getMaterialType( materialIndex ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

			return MeshPhysicalMaterial;

		}

		extendMaterialParams( materialIndex, materialParams ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

				return Promise.resolve();

			}

			const pending = [];

			const extension = materialDef.extensions[ this.name ];

			if ( extension.clearcoatFactor !== undefined ) {

				materialParams.clearcoat = extension.clearcoatFactor;

			}

			if ( extension.clearcoatTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

			}

			if ( extension.clearcoatRoughnessFactor !== undefined ) {

				materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

			}

			if ( extension.clearcoatRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

			}

			if ( extension.clearcoatNormalTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

				if ( extension.clearcoatNormalTexture.scale !== undefined ) {

					const scale = extension.clearcoatNormalTexture.scale;

					materialParams.clearcoatNormalScale = new Vector2( scale, scale );

				}

			}

			return Promise.all( pending );

		}

	}

	/**
	 * Sheen Materials Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
	 */
	class GLTFMaterialsSheenExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS$1.KHR_MATERIALS_SHEEN;

		}

		getMaterialType( materialIndex ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

			return MeshPhysicalMaterial;

		}

		extendMaterialParams( materialIndex, materialParams ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

				return Promise.resolve();

			}

			const pending = [];

			materialParams.sheenColor = new Color( 0, 0, 0 );
			materialParams.sheenRoughness = 0;
			materialParams.sheen = 1;

			const extension = materialDef.extensions[ this.name ];

			if ( extension.sheenColorFactor !== undefined ) {

				materialParams.sheenColor.fromArray( extension.sheenColorFactor );

			}

			if ( extension.sheenRoughnessFactor !== undefined ) {

				materialParams.sheenRoughness = extension.sheenRoughnessFactor;

			}

			if ( extension.sheenColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, sRGBEncoding ) );

			}

			if ( extension.sheenRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

			}

			return Promise.all( pending );

		}

	}

	/**
	 * Transmission Materials Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
	 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
	 */
	class GLTFMaterialsTransmissionExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS$1.KHR_MATERIALS_TRANSMISSION;

		}

		getMaterialType( materialIndex ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

			return MeshPhysicalMaterial;

		}

		extendMaterialParams( materialIndex, materialParams ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

				return Promise.resolve();

			}

			const pending = [];

			const extension = materialDef.extensions[ this.name ];

			if ( extension.transmissionFactor !== undefined ) {

				materialParams.transmission = extension.transmissionFactor;

			}

			if ( extension.transmissionTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

			}

			return Promise.all( pending );

		}

	}

	/**
	 * Materials Volume Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
	 */
	class GLTFMaterialsVolumeExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS$1.KHR_MATERIALS_VOLUME;

		}

		getMaterialType( materialIndex ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

			return MeshPhysicalMaterial;

		}

		extendMaterialParams( materialIndex, materialParams ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

				return Promise.resolve();

			}

			const pending = [];

			const extension = materialDef.extensions[ this.name ];

			materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

			if ( extension.thicknessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

			}

			materialParams.attenuationDistance = extension.attenuationDistance || 0;

			const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
			materialParams.attenuationColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

			return Promise.all( pending );

		}

	}

	/**
	 * Materials ior Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
	 */
	class GLTFMaterialsIorExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS$1.KHR_MATERIALS_IOR;

		}

		getMaterialType( materialIndex ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

			return MeshPhysicalMaterial;

		}

		extendMaterialParams( materialIndex, materialParams ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

				return Promise.resolve();

			}

			const extension = materialDef.extensions[ this.name ];

			materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

			return Promise.resolve();

		}

	}

	/**
	 * Materials specular Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
	 */
	class GLTFMaterialsSpecularExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS$1.KHR_MATERIALS_SPECULAR;

		}

		getMaterialType( materialIndex ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

			return MeshPhysicalMaterial;

		}

		extendMaterialParams( materialIndex, materialParams ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

				return Promise.resolve();

			}

			const pending = [];

			const extension = materialDef.extensions[ this.name ];

			materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

			if ( extension.specularTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

			}

			const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
			materialParams.specularColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

			if ( extension.specularColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, sRGBEncoding ) );

			}

			return Promise.all( pending );

		}

	}

	/**
	 * BasisU Texture Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
	 */
	class GLTFTextureBasisUExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS$1.KHR_TEXTURE_BASISU;

		}

		loadTexture( textureIndex ) {

			const parser = this.parser;
			const json = parser.json;

			const textureDef = json.textures[ textureIndex ];

			if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

				return null;

			}

			const extension = textureDef.extensions[ this.name ];
			const loader = parser.options.ktx2Loader;

			if ( ! loader ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

				} else {

					// Assumes that the extension is optional and that a fallback texture is present
					return null;

				}

			}

			return parser.loadTextureImage( textureIndex, extension.source, loader );

		}

	}

	/**
	 * WebP Texture Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
	 */
	class GLTFTextureWebPExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS$1.EXT_TEXTURE_WEBP;
			this.isSupported = null;

		}

		loadTexture( textureIndex ) {

			const name = this.name;
			const parser = this.parser;
			const json = parser.json;

			const textureDef = json.textures[ textureIndex ];

			if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

				return null;

			}

			const extension = textureDef.extensions[ name ];
			const source = json.images[ extension.source ];

			let loader = parser.textureLoader;
			if ( source.uri ) {

				const handler = parser.options.manager.getHandler( source.uri );
				if ( handler !== null ) loader = handler;

			}

			return this.detectSupport().then( function ( isSupported ) {

				if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

				}

				// Fall back to PNG or JPEG.
				return parser.loadTexture( textureIndex );

			} );

		}

		detectSupport() {

			if ( ! this.isSupported ) {

				this.isSupported = new Promise( function ( resolve ) {

					const image = new Image();

					// Lossy test image. Support for lossy images doesn't guarantee support for all
					// WebP images, unfortunately.
					image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

					image.onload = image.onerror = function () {

						resolve( image.height === 1 );

					};

				} );

			}

			return this.isSupported;

		}

	}

	/**
	 * meshopt BufferView Compression Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
	 */
	class GLTFMeshoptCompression {

		constructor( parser ) {

			this.name = EXTENSIONS$1.EXT_MESHOPT_COMPRESSION;
			this.parser = parser;

		}

		loadBufferView( index ) {

			const json = this.parser.json;
			const bufferView = json.bufferViews[ index ];

			if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

				const extensionDef = bufferView.extensions[ this.name ];

				const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
				const decoder = this.parser.options.meshoptDecoder;

				if ( ! decoder || ! decoder.supported ) {

					if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

						throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

					} else {

						// Assumes that the extension is optional and that fallback buffer data is present
						return null;

					}

				}

				return Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {

					const byteOffset = extensionDef.byteOffset || 0;
					const byteLength = extensionDef.byteLength || 0;

					const count = extensionDef.count;
					const stride = extensionDef.byteStride;

					const result = new ArrayBuffer( count * stride );
					const source = new Uint8Array( res[ 0 ], byteOffset, byteLength );

					decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
					return result;

				} );

			} else {

				return null;

			}

		}

	}

	/* BINARY EXTENSION */
	const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
	const BINARY_EXTENSION_HEADER_LENGTH$1 = 12;
	const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

	class GLTFBinaryExtension$1 {

		constructor( data ) {

			this.name = EXTENSIONS$1.KHR_BINARY_GLTF;
			this.content = null;
			this.body = null;

			const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH$1 );

			this.header = {
				magic: LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
				version: headerView.getUint32( 4, true ),
				length: headerView.getUint32( 8, true )
			};

			if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

				throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

			} else if ( this.header.version < 2.0 ) {

				throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

			}

			const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH$1;
			const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH$1 );
			let chunkIndex = 0;

			while ( chunkIndex < chunkContentsLength ) {

				const chunkLength = chunkView.getUint32( chunkIndex, true );
				chunkIndex += 4;

				const chunkType = chunkView.getUint32( chunkIndex, true );
				chunkIndex += 4;

				if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

					const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH$1 + chunkIndex, chunkLength );
					this.content = LoaderUtils.decodeText( contentArray );

				} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

					const byteOffset = BINARY_EXTENSION_HEADER_LENGTH$1 + chunkIndex;
					this.body = data.slice( byteOffset, byteOffset + chunkLength );

				}

				// Clients must ignore chunks with unknown types.

				chunkIndex += chunkLength;

			}

			if ( this.content === null ) {

				throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

			}

		}

	}

	/**
	 * DRACO Mesh Compression Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
	 */
	class GLTFDracoMeshCompressionExtension {

		constructor( json, dracoLoader ) {

			if ( ! dracoLoader ) {

				throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

			}

			this.name = EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION;
			this.json = json;
			this.dracoLoader = dracoLoader;
			this.dracoLoader.preload();

		}

		decodePrimitive( primitive, parser ) {

			const json = this.json;
			const dracoLoader = this.dracoLoader;
			const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
			const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
			const threeAttributeMap = {};
			const attributeNormalizedMap = {};
			const attributeTypeMap = {};

			for ( const attributeName in gltfAttributeMap ) {

				const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

				threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

			}

			for ( const attributeName in primitive.attributes ) {

				const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

				if ( gltfAttributeMap[ attributeName ] !== undefined ) {

					const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
					const componentType = WEBGL_COMPONENT_TYPES$1[ accessorDef.componentType ];

					attributeTypeMap[ threeAttributeName ] = componentType;
					attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

				}

			}

			return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

				return new Promise( function ( resolve ) {

					dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

						for ( const attributeName in geometry.attributes ) {

							const attribute = geometry.attributes[ attributeName ];
							const normalized = attributeNormalizedMap[ attributeName ];

							if ( normalized !== undefined ) attribute.normalized = normalized;

						}

						resolve( geometry );

					}, threeAttributeMap, attributeTypeMap );

				} );

			} );

		}

	}

	/**
	 * Texture Transform Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
	 */
	class GLTFTextureTransformExtension {

		constructor() {

			this.name = EXTENSIONS$1.KHR_TEXTURE_TRANSFORM;

		}

		extendTexture( texture, transform ) {

			if ( transform.texCoord !== undefined ) {

				console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

			}

			if ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {

				// See https://github.com/mrdoob/three.js/issues/21819.
				return texture;

			}

			texture = texture.clone();

			if ( transform.offset !== undefined ) {

				texture.offset.fromArray( transform.offset );

			}

			if ( transform.rotation !== undefined ) {

				texture.rotation = transform.rotation;

			}

			if ( transform.scale !== undefined ) {

				texture.repeat.fromArray( transform.scale );

			}

			texture.needsUpdate = true;

			return texture;

		}

	}

	/**
	 * Specular-Glossiness Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness
	 */

	/**
	 * A sub class of StandardMaterial with some of the functionality
	 * changed via the `onBeforeCompile` callback
	 * @pailhead
	 */
	class GLTFMeshStandardSGMaterial extends MeshStandardMaterial {

		constructor( params ) {

			super();

			this.isGLTFSpecularGlossinessMaterial = true;

			//various chunks that need replacing
			const specularMapParsFragmentChunk = [
				'#ifdef USE_SPECULARMAP',
				'	uniform sampler2D specularMap;',
				'#endif'
			].join( '\n' );

			const glossinessMapParsFragmentChunk = [
				'#ifdef USE_GLOSSINESSMAP',
				'	uniform sampler2D glossinessMap;',
				'#endif'
			].join( '\n' );

			const specularMapFragmentChunk = [
				'vec3 specularFactor = specular;',
				'#ifdef USE_SPECULARMAP',
				'	vec4 texelSpecular = texture2D( specularMap, vUv );',
				'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
				'	specularFactor *= texelSpecular.rgb;',
				'#endif'
			].join( '\n' );

			const glossinessMapFragmentChunk = [
				'float glossinessFactor = glossiness;',
				'#ifdef USE_GLOSSINESSMAP',
				'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
				'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
				'	glossinessFactor *= texelGlossiness.a;',
				'#endif'
			].join( '\n' );

			const lightPhysicalFragmentChunk = [
				'PhysicalMaterial material;',
				'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
				'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
				'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
				'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
				'material.roughness += geometryRoughness;',
				'material.roughness = min( material.roughness, 1.0 );',
				'material.specularColor = specularFactor;',
			].join( '\n' );

			const uniforms = {
				specular: { value: new Color().setHex( 0xffffff ) },
				glossiness: { value: 1 },
				specularMap: { value: null },
				glossinessMap: { value: null }
			};

			this._extraUniforms = uniforms;

			this.onBeforeCompile = function ( shader ) {

				for ( const uniformName in uniforms ) {

					shader.uniforms[ uniformName ] = uniforms[ uniformName ];

				}

				shader.fragmentShader = shader.fragmentShader
					.replace( 'uniform float roughness;', 'uniform vec3 specular;' )
					.replace( 'uniform float metalness;', 'uniform float glossiness;' )
					.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
					.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
					.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
					.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
					.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

			};

			Object.defineProperties( this, {

				specular: {
					get: function () {

						return uniforms.specular.value;

					},
					set: function ( v ) {

						uniforms.specular.value = v;

					}
				},

				specularMap: {
					get: function () {

						return uniforms.specularMap.value;

					},
					set: function ( v ) {

						uniforms.specularMap.value = v;

						if ( v ) {

							this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps

						} else {

							delete this.defines.USE_SPECULARMAP;

						}

					}
				},

				glossiness: {
					get: function () {

						return uniforms.glossiness.value;

					},
					set: function ( v ) {

						uniforms.glossiness.value = v;

					}
				},

				glossinessMap: {
					get: function () {

						return uniforms.glossinessMap.value;

					},
					set: function ( v ) {

						uniforms.glossinessMap.value = v;

						if ( v ) {

							this.defines.USE_GLOSSINESSMAP = '';
							this.defines.USE_UV = '';

						} else {

							delete this.defines.USE_GLOSSINESSMAP;
							delete this.defines.USE_UV;

						}

					}
				}

			} );

			delete this.metalness;
			delete this.roughness;
			delete this.metalnessMap;
			delete this.roughnessMap;

			this.setValues( params );

		}

		copy( source ) {

			super.copy( source );

			this.specularMap = source.specularMap;
			this.specular.copy( source.specular );
			this.glossinessMap = source.glossinessMap;
			this.glossiness = source.glossiness;
			delete this.metalness;
			delete this.roughness;
			delete this.metalnessMap;
			delete this.roughnessMap;
			return this;

		}

	}


	class GLTFMaterialsPbrSpecularGlossinessExtension {

		constructor() {

			this.name = EXTENSIONS$1.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;

			this.specularGlossinessParams = [
				'color',
				'map',
				'lightMap',
				'lightMapIntensity',
				'aoMap',
				'aoMapIntensity',
				'emissive',
				'emissiveIntensity',
				'emissiveMap',
				'bumpMap',
				'bumpScale',
				'normalMap',
				'normalMapType',
				'displacementMap',
				'displacementScale',
				'displacementBias',
				'specularMap',
				'specular',
				'glossinessMap',
				'glossiness',
				'alphaMap',
				'envMap',
				'envMapIntensity'
			];

		}

		getMaterialType() {

			return GLTFMeshStandardSGMaterial;

		}

		extendParams( materialParams, materialDef, parser ) {

			const pbrSpecularGlossiness = materialDef.extensions[ this.name ];

			materialParams.color = new Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			const pending = [];

			if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

				const array = pbrSpecularGlossiness.diffuseFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture, sRGBEncoding ) );

			}

			materialParams.emissive = new Color( 0.0, 0.0, 0.0 );
			materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
			materialParams.specular = new Color( 1.0, 1.0, 1.0 );

			if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

				materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

			}

			if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

				const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
				pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
				pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef, sRGBEncoding ) );

			}

			return Promise.all( pending );

		}

		createMaterial( materialParams ) {

			const material = new GLTFMeshStandardSGMaterial( materialParams );
			material.fog = true;

			material.color = materialParams.color;

			material.map = materialParams.map === undefined ? null : materialParams.map;

			material.lightMap = null;
			material.lightMapIntensity = 1.0;

			material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
			material.aoMapIntensity = 1.0;

			material.emissive = materialParams.emissive;
			material.emissiveIntensity = 1.0;
			material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

			material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
			material.bumpScale = 1;

			material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
			material.normalMapType = TangentSpaceNormalMap;

			if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;

			material.displacementMap = null;
			material.displacementScale = 1;
			material.displacementBias = 0;

			material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
			material.specular = materialParams.specular;

			material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
			material.glossiness = materialParams.glossiness;

			material.alphaMap = null;

			material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
			material.envMapIntensity = 1.0;

			return material;

		}

	}

	/**
	 * Mesh Quantization Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
	 */
	class GLTFMeshQuantizationExtension {

		constructor() {

			this.name = EXTENSIONS$1.KHR_MESH_QUANTIZATION;

		}

	}

	/*********************************/
	/********** INTERPOLATION ********/
	/*********************************/

	// Spline Interpolation
	// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
	class GLTFCubicSplineInterpolant extends Interpolant {

		constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		copySampleValue_( index ) {

			// Copies a sample value to the result buffer. See description of glTF
			// CUBICSPLINE values layout in interpolate_() function below.

			const result = this.resultBuffer,
				values = this.sampleValues,
				valueSize = this.valueSize,
				offset = index * valueSize * 3 + valueSize;

			for ( let i = 0; i !== valueSize; i ++ ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		}

	}

	GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

	GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

	GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer;
		const values = this.sampleValues;
		const stride = this.valueSize;

		const stride2 = stride * 2;
		const stride3 = stride * 3;

		const td = t1 - t0;

		const p = ( t - t0 ) / td;
		const pp = p * p;
		const ppp = pp * p;

		const offset1 = i1 * stride3;
		const offset0 = offset1 - stride3;

		const s2 = - 2 * ppp + 3 * pp;
		const s3 = ppp - pp;
		const s0 = 1 - s2;
		const s1 = s3 - pp + p;

		// Layout of keyframe output values for CUBICSPLINE animations:
		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
		for ( let i = 0; i !== stride; i ++ ) {

			const p0 = values[ offset0 + i + stride ]; // splineVertex_k
			const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
			const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
			const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

		}

		return result;

	};

	const _q = new Quaternion();

	class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

		interpolate_( i1, t0, t, t1 ) {

			const result = super.interpolate_( i1, t0, t, t1 );

			_q.fromArray( result ).normalize().toArray( result );

			return result;

		}

	}


	/*********************************/
	/********** INTERNALS ************/
	/*********************************/

	/* CONSTANTS */

	const WEBGL_CONSTANTS$1 = {
		FLOAT: 5126,
		//FLOAT_MAT2: 35674,
		FLOAT_MAT3: 35675,
		FLOAT_MAT4: 35676,
		FLOAT_VEC2: 35664,
		FLOAT_VEC3: 35665,
		FLOAT_VEC4: 35666,
		LINEAR: 9729,
		REPEAT: 10497,
		SAMPLER_2D: 35678,
		POINTS: 0,
		LINES: 1,
		LINE_LOOP: 2,
		LINE_STRIP: 3,
		TRIANGLES: 4,
		TRIANGLE_STRIP: 5,
		TRIANGLE_FAN: 6,
		UNSIGNED_BYTE: 5121,
		UNSIGNED_SHORT: 5123
	};

	const WEBGL_COMPONENT_TYPES$1 = {
		5120: Int8Array,
		5121: Uint8Array,
		5122: Int16Array,
		5123: Uint16Array,
		5125: Uint32Array,
		5126: Float32Array
	};

	const WEBGL_FILTERS$1 = {
		9728: NearestFilter,
		9729: LinearFilter,
		9984: NearestMipmapNearestFilter,
		9985: LinearMipmapNearestFilter,
		9986: NearestMipmapLinearFilter,
		9987: LinearMipmapLinearFilter
	};

	const WEBGL_WRAPPINGS$1 = {
		33071: ClampToEdgeWrapping,
		33648: MirroredRepeatWrapping,
		10497: RepeatWrapping
	};

	const WEBGL_TYPE_SIZES$1 = {
		'SCALAR': 1,
		'VEC2': 2,
		'VEC3': 3,
		'VEC4': 4,
		'MAT2': 4,
		'MAT3': 9,
		'MAT4': 16
	};

	const ATTRIBUTES = {
		POSITION: 'position',
		NORMAL: 'normal',
		TANGENT: 'tangent',
		TEXCOORD_0: 'uv',
		TEXCOORD_1: 'uv2',
		COLOR_0: 'color',
		WEIGHTS_0: 'skinWeight',
		JOINTS_0: 'skinIndex',
	};

	const PATH_PROPERTIES$1 = {
		scale: 'scale',
		translation: 'position',
		rotation: 'quaternion',
		weights: 'morphTargetInfluences'
	};

	const INTERPOLATION$1 = {
		CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
			                        // keyframe track will be initialized with a default interpolation type, then modified.
		LINEAR: InterpolateLinear,
		STEP: InterpolateDiscrete
	};

	const ALPHA_MODES = {
		OPAQUE: 'OPAQUE',
		MASK: 'MASK',
		BLEND: 'BLEND'
	};

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
	 */
	function createDefaultMaterial$1( cache ) {

		if ( cache[ 'DefaultMaterial' ] === undefined ) {

			cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {
				color: 0xFFFFFF,
				emissive: 0x000000,
				metalness: 1,
				roughness: 1,
				transparent: false,
				depthTest: true,
				side: FrontSide
			} );

		}

		return cache[ 'DefaultMaterial' ];

	}

	function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

		// Add unknown glTF extensions to an object's userData.

		for ( const name in objectDef.extensions ) {

			if ( knownExtensions[ name ] === undefined ) {

				object.userData.gltfExtensions = object.userData.gltfExtensions || {};
				object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

			}

		}

	}

	/**
	 * @param {Object3D|Material|BufferGeometry} object
	 * @param {GLTF.definition} gltfDef
	 */
	function assignExtrasToUserData( object, gltfDef ) {

		if ( gltfDef.extras !== undefined ) {

			if ( typeof gltfDef.extras === 'object' ) {

				Object.assign( object.userData, gltfDef.extras );

			} else {

				console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

			}

		}

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
	 *
	 * @param {BufferGeometry} geometry
	 * @param {Array<GLTF.Target>} targets
	 * @param {GLTFParser} parser
	 * @return {Promise<BufferGeometry>}
	 */
	function addMorphTargets( geometry, targets, parser ) {

		let hasMorphPosition = false;
		let hasMorphNormal = false;
		let hasMorphColor = false;

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( target.POSITION !== undefined ) hasMorphPosition = true;
			if ( target.NORMAL !== undefined ) hasMorphNormal = true;
			if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

			if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

		}

		if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

		const pendingPositionAccessors = [];
		const pendingNormalAccessors = [];
		const pendingColorAccessors = [];

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( hasMorphPosition ) {

				const pendingAccessor = target.POSITION !== undefined
					? parser.getDependency( 'accessor', target.POSITION )
					: geometry.attributes.position;

				pendingPositionAccessors.push( pendingAccessor );

			}

			if ( hasMorphNormal ) {

				const pendingAccessor = target.NORMAL !== undefined
					? parser.getDependency( 'accessor', target.NORMAL )
					: geometry.attributes.normal;

				pendingNormalAccessors.push( pendingAccessor );

			}

			if ( hasMorphColor ) {

				const pendingAccessor = target.COLOR_0 !== undefined
					? parser.getDependency( 'accessor', target.COLOR_0 )
					: geometry.attributes.color;

				pendingColorAccessors.push( pendingAccessor );

			}

		}

		return Promise.all( [
			Promise.all( pendingPositionAccessors ),
			Promise.all( pendingNormalAccessors ),
			Promise.all( pendingColorAccessors )
		] ).then( function ( accessors ) {

			const morphPositions = accessors[ 0 ];
			const morphNormals = accessors[ 1 ];
			const morphColors = accessors[ 2 ];

			if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
			if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
			if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
			geometry.morphTargetsRelative = true;

			return geometry;

		} );

	}

	/**
	 * @param {Mesh} mesh
	 * @param {GLTF.Mesh} meshDef
	 */
	function updateMorphTargets( mesh, meshDef ) {

		mesh.updateMorphTargets();

		if ( meshDef.weights !== undefined ) {

			for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

				mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

			}

		}

		// .extras has user-defined data, so check that .extras.targetNames is an array.
		if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

			const targetNames = meshDef.extras.targetNames;

			if ( mesh.morphTargetInfluences.length === targetNames.length ) {

				mesh.morphTargetDictionary = {};

				for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

					mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

				}

			} else {

				console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

			}

		}

	}

	function createPrimitiveKey( primitiveDef ) {

		const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION ];
		let geometryKey;

		if ( dracoExtension ) {

			geometryKey = 'draco:' + dracoExtension.bufferView
					+ ':' + dracoExtension.indices
					+ ':' + createAttributesKey( dracoExtension.attributes );

		} else {

			geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

		}

		return geometryKey;

	}

	function createAttributesKey( attributes ) {

		let attributesKey = '';

		const keys = Object.keys( attributes ).sort();

		for ( let i = 0, il = keys.length; i < il; i ++ ) {

			attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

		}

		return attributesKey;

	}

	function getNormalizedComponentScale( constructor ) {

		// Reference:
		// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

		switch ( constructor ) {

			case Int8Array:
				return 1 / 127;

			case Uint8Array:
				return 1 / 255;

			case Int16Array:
				return 1 / 32767;

			case Uint16Array:
				return 1 / 65535;

			default:
				throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

		}

	}

	function getImageURIMimeType( uri ) {

		if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
		if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';

		return 'image/png';

	}

	/* GLTF PARSER */

	class GLTFParser$1 {

		constructor( json = {}, options = {} ) {

			this.json = json;
			this.extensions = {};
			this.plugins = {};
			this.options = options;

			// loader object cache
			this.cache = new GLTFRegistry$1();

			// associations between Three.js objects and glTF elements
			this.associations = new Map();

			// BufferGeometry caching
			this.primitiveCache = {};

			// Object3D instance caches
			this.meshCache = { refs: {}, uses: {} };
			this.cameraCache = { refs: {}, uses: {} };
			this.lightCache = { refs: {}, uses: {} };

			this.sourceCache = {};
			this.textureCache = {};

			// Track node names, to ensure no duplicates
			this.nodeNamesUsed = {};

			// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
			// expensive work of uploading a texture to the GPU off the main thread.
			if ( typeof createImageBitmap !== 'undefined' && /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === false ) {

				this.textureLoader = new ImageBitmapLoader( this.options.manager );

			} else {

				this.textureLoader = new TextureLoader( this.options.manager );

			}

			this.textureLoader.setCrossOrigin( this.options.crossOrigin );
			this.textureLoader.setRequestHeader( this.options.requestHeader );

			this.fileLoader = new FileLoader( this.options.manager );
			this.fileLoader.setResponseType( 'arraybuffer' );

			if ( this.options.crossOrigin === 'use-credentials' ) {

				this.fileLoader.setWithCredentials( true );

			}

		}

		setExtensions( extensions ) {

			this.extensions = extensions;

		}

		setPlugins( plugins ) {

			this.plugins = plugins;

		}

		parse( onLoad, onError ) {

			const parser = this;
			const json = this.json;
			const extensions = this.extensions;

			// Clear the loader cache
			this.cache.removeAll();

			// Mark the special nodes/meshes in json for efficient parse
			this._invokeAll( function ( ext ) {

				return ext._markDefs && ext._markDefs();

			} );

			Promise.all( this._invokeAll( function ( ext ) {

				return ext.beforeRoot && ext.beforeRoot();

			} ) ).then( function () {

				return Promise.all( [

					parser.getDependencies( 'scene' ),
					parser.getDependencies( 'animation' ),
					parser.getDependencies( 'camera' ),

				] );

			} ).then( function ( dependencies ) {

				const result = {
					scene: dependencies[ 0 ][ json.scene || 0 ],
					scenes: dependencies[ 0 ],
					animations: dependencies[ 1 ],
					cameras: dependencies[ 2 ],
					asset: json.asset,
					parser: parser,
					userData: {}
				};

				addUnknownExtensionsToUserData( extensions, result, json );

				assignExtrasToUserData( result, json );

				Promise.all( parser._invokeAll( function ( ext ) {

					return ext.afterRoot && ext.afterRoot( result );

				} ) ).then( function () {

					onLoad( result );

				} );

			} ).catch( onError );

		}

		/**
		 * Marks the special nodes/meshes in json for efficient parse.
		 */
		_markDefs() {

			const nodeDefs = this.json.nodes || [];
			const skinDefs = this.json.skins || [];
			const meshDefs = this.json.meshes || [];

			// Nothing in the node definition indicates whether it is a Bone or an
			// Object3D. Use the skins' joint references to mark bones.
			for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

				const joints = skinDefs[ skinIndex ].joints;

				for ( let i = 0, il = joints.length; i < il; i ++ ) {

					nodeDefs[ joints[ i ] ].isBone = true;

				}

			}

			// Iterate over all nodes, marking references to shared resources,
			// as well as skeleton joints.
			for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

				const nodeDef = nodeDefs[ nodeIndex ];

				if ( nodeDef.mesh !== undefined ) {

					this._addNodeRef( this.meshCache, nodeDef.mesh );

					// Nothing in the mesh definition indicates whether it is
					// a SkinnedMesh or Mesh. Use the node's mesh reference
					// to mark SkinnedMesh if node has skin.
					if ( nodeDef.skin !== undefined ) {

						meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

					}

				}

				if ( nodeDef.camera !== undefined ) {

					this._addNodeRef( this.cameraCache, nodeDef.camera );

				}

			}

		}

		/**
		 * Counts references to shared node / Object3D resources. These resources
		 * can be reused, or "instantiated", at multiple nodes in the scene
		 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
		 * be marked. Non-scenegraph resources (like Materials, Geometries, and
		 * Textures) can be reused directly and are not marked here.
		 *
		 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
		 */
		_addNodeRef( cache, index ) {

			if ( index === undefined ) return;

			if ( cache.refs[ index ] === undefined ) {

				cache.refs[ index ] = cache.uses[ index ] = 0;

			}

			cache.refs[ index ] ++;

		}

		/** Returns a reference to a shared resource, cloning it if necessary. */
		_getNodeRef( cache, index, object ) {

			if ( cache.refs[ index ] <= 1 ) return object;

			const ref = object.clone();

			// Propagates mappings to the cloned object, prevents mappings on the
			// original object from being lost.
			const updateMappings = ( original, clone ) => {

				const mappings = this.associations.get( original );
				if ( mappings != null ) {

					this.associations.set( clone, mappings );

				}

				for ( const [ i, child ] of original.children.entries() ) {

					updateMappings( child, clone.children[ i ] );

				}

			};

			updateMappings( object, ref );

			ref.name += '_instance_' + ( cache.uses[ index ] ++ );

			return ref;

		}

		_invokeOne( func ) {

			const extensions = Object.values( this.plugins );
			extensions.push( this );

			for ( let i = 0; i < extensions.length; i ++ ) {

				const result = func( extensions[ i ] );

				if ( result ) return result;

			}

			return null;

		}

		_invokeAll( func ) {

			const extensions = Object.values( this.plugins );
			extensions.unshift( this );

			const pending = [];

			for ( let i = 0; i < extensions.length; i ++ ) {

				const result = func( extensions[ i ] );

				if ( result ) pending.push( result );

			}

			return pending;

		}

		/**
		 * Requests the specified dependency asynchronously, with caching.
		 * @param {string} type
		 * @param {number} index
		 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
		 */
		getDependency( type, index ) {

			const cacheKey = type + ':' + index;
			let dependency = this.cache.get( cacheKey );

			if ( ! dependency ) {

				switch ( type ) {

					case 'scene':
						dependency = this.loadScene( index );
						break;

					case 'node':
						dependency = this.loadNode( index );
						break;

					case 'mesh':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadMesh && ext.loadMesh( index );

						} );
						break;

					case 'accessor':
						dependency = this.loadAccessor( index );
						break;

					case 'bufferView':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadBufferView && ext.loadBufferView( index );

						} );
						break;

					case 'buffer':
						dependency = this.loadBuffer( index );
						break;

					case 'material':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadMaterial && ext.loadMaterial( index );

						} );
						break;

					case 'texture':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadTexture && ext.loadTexture( index );

						} );
						break;

					case 'skin':
						dependency = this.loadSkin( index );
						break;

					case 'animation':
						dependency = this.loadAnimation( index );
						break;

					case 'camera':
						dependency = this.loadCamera( index );
						break;

					default:
						throw new Error( 'Unknown type: ' + type );

				}

				this.cache.add( cacheKey, dependency );

			}

			return dependency;

		}

		/**
		 * Requests all dependencies of the specified type asynchronously, with caching.
		 * @param {string} type
		 * @return {Promise<Array<Object>>}
		 */
		getDependencies( type ) {

			let dependencies = this.cache.get( type );

			if ( ! dependencies ) {

				const parser = this;
				const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

				dependencies = Promise.all( defs.map( function ( def, index ) {

					return parser.getDependency( type, index );

				} ) );

				this.cache.add( type, dependencies );

			}

			return dependencies;

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
		 * @param {number} bufferIndex
		 * @return {Promise<ArrayBuffer>}
		 */
		loadBuffer( bufferIndex ) {

			const bufferDef = this.json.buffers[ bufferIndex ];
			const loader = this.fileLoader;

			if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

				throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

			}

			// If present, GLB container is required to be the first buffer.
			if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

				return Promise.resolve( this.extensions[ EXTENSIONS$1.KHR_BINARY_GLTF ].body );

			}

			const options = this.options;

			return new Promise( function ( resolve, reject ) {

				loader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

					reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

				} );

			} );

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
		 * @param {number} bufferViewIndex
		 * @return {Promise<ArrayBuffer>}
		 */
		loadBufferView( bufferViewIndex ) {

			const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

			return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

				const byteLength = bufferViewDef.byteLength || 0;
				const byteOffset = bufferViewDef.byteOffset || 0;
				return buffer.slice( byteOffset, byteOffset + byteLength );

			} );

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
		 * @param {number} accessorIndex
		 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
		 */
		loadAccessor( accessorIndex ) {

			const parser = this;
			const json = this.json;

			const accessorDef = this.json.accessors[ accessorIndex ];

			if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

				// Ignore empty accessors, which may be used to declare runtime
				// information about attributes coming from another source (e.g. Draco
				// compression extension).
				return Promise.resolve( null );

			}

			const pendingBufferViews = [];

			if ( accessorDef.bufferView !== undefined ) {

				pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

			} else {

				pendingBufferViews.push( null );

			}

			if ( accessorDef.sparse !== undefined ) {

				pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
				pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

			}

			return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

				const bufferView = bufferViews[ 0 ];

				const itemSize = WEBGL_TYPE_SIZES$1[ accessorDef.type ];
				const TypedArray = WEBGL_COMPONENT_TYPES$1[ accessorDef.componentType ];

				// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
				const elementBytes = TypedArray.BYTES_PER_ELEMENT;
				const itemBytes = elementBytes * itemSize;
				const byteOffset = accessorDef.byteOffset || 0;
				const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
				const normalized = accessorDef.normalized === true;
				let array, bufferAttribute;

				// The buffer is not interleaved if the stride is the item size in bytes.
				if ( byteStride && byteStride !== itemBytes ) {

					// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
					// This makes sure that IBA.count reflects accessor.count properly
					const ibSlice = Math.floor( byteOffset / byteStride );
					const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
					let ib = parser.cache.get( ibCacheKey );

					if ( ! ib ) {

						array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

						// Integer parameters to IB/IBA are in array elements, not bytes.
						ib = new InterleavedBuffer( array, byteStride / elementBytes );

						parser.cache.add( ibCacheKey, ib );

					}

					bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

				} else {

					if ( bufferView === null ) {

						array = new TypedArray( accessorDef.count * itemSize );

					} else {

						array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

					}

					bufferAttribute = new BufferAttribute( array, itemSize, normalized );

				}

				// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
				if ( accessorDef.sparse !== undefined ) {

					const itemSizeIndices = WEBGL_TYPE_SIZES$1.SCALAR;
					const TypedArrayIndices = WEBGL_COMPONENT_TYPES$1[ accessorDef.sparse.indices.componentType ];

					const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
					const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

					const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
					const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

					if ( bufferView !== null ) {

						// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
						bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

					}

					for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

						const index = sparseIndices[ i ];

						bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
						if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
						if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
						if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
						if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

					}

				}

				return bufferAttribute;

			} );

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
		 * @param {number} textureIndex
		 * @return {Promise<THREE.Texture>}
		 */
		loadTexture( textureIndex ) {

			const json = this.json;
			const options = this.options;
			const textureDef = json.textures[ textureIndex ];
			const sourceIndex = textureDef.source;
			const sourceDef = json.images[ sourceIndex ];

			let loader = this.textureLoader;

			if ( sourceDef.uri ) {

				const handler = options.manager.getHandler( sourceDef.uri );
				if ( handler !== null ) loader = handler;

			}

			return this.loadTextureImage( textureIndex, sourceIndex, loader );

		}

		loadTextureImage( textureIndex, sourceIndex, loader ) {

			const parser = this;
			const json = this.json;

			const textureDef = json.textures[ textureIndex ];
			const sourceDef = json.images[ sourceIndex ];

			const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

			if ( this.textureCache[ cacheKey ] ) {

				// See https://github.com/mrdoob/three.js/issues/21559.
				return this.textureCache[ cacheKey ];

			}

			const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

				texture.flipY = false;

				if ( textureDef.name ) texture.name = textureDef.name;

				const samplers = json.samplers || {};
				const sampler = samplers[ textureDef.sampler ] || {};

				texture.magFilter = WEBGL_FILTERS$1[ sampler.magFilter ] || LinearFilter;
				texture.minFilter = WEBGL_FILTERS$1[ sampler.minFilter ] || LinearMipmapLinearFilter;
				texture.wrapS = WEBGL_WRAPPINGS$1[ sampler.wrapS ] || RepeatWrapping;
				texture.wrapT = WEBGL_WRAPPINGS$1[ sampler.wrapT ] || RepeatWrapping;

				parser.associations.set( texture, { textures: textureIndex } );

				return texture;

			} ).catch( function () {

				return null;

			} );

			this.textureCache[ cacheKey ] = promise;

			return promise;

		}

		loadImageSource( sourceIndex, loader ) {

			const parser = this;
			const json = this.json;
			const options = this.options;

			if ( this.sourceCache[ sourceIndex ] !== undefined ) {

				return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );

			}

			const sourceDef = json.images[ sourceIndex ];

			const URL = self.URL || self.webkitURL;

			let sourceURI = sourceDef.uri || '';
			let isObjectURL = false;

			if ( sourceDef.bufferView !== undefined ) {

				// Load binary image data from bufferView, if provided.

				sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

					isObjectURL = true;
					const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
					sourceURI = URL.createObjectURL( blob );
					return sourceURI;

				} );

			} else if ( sourceDef.uri === undefined ) {

				throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

			}

			const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

				return new Promise( function ( resolve, reject ) {

					let onLoad = resolve;

					if ( loader.isImageBitmapLoader === true ) {

						onLoad = function ( imageBitmap ) {

							const texture = new Texture( imageBitmap );
							texture.needsUpdate = true;

							resolve( texture );

						};

					}

					loader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

				} );

			} ).then( function ( texture ) {

				// Clean up resources and configure Texture.

				if ( isObjectURL === true ) {

					URL.revokeObjectURL( sourceURI );

				}

				texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

				return texture;

			} ).catch( function ( error ) {

				console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
				throw error;

			} );

			this.sourceCache[ sourceIndex ] = promise;
			return promise;

		}

		/**
		 * Asynchronously assigns a texture to the given material parameters.
		 * @param {Object} materialParams
		 * @param {string} mapName
		 * @param {Object} mapDef
		 * @return {Promise<Texture>}
		 */
		assignTexture( materialParams, mapName, mapDef, encoding ) {

			const parser = this;

			return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

				// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
				// However, we will copy UV set 0 to UV set 1 on demand for aoMap
				if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

					console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

				}

				if ( parser.extensions[ EXTENSIONS$1.KHR_TEXTURE_TRANSFORM ] ) {

					const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS$1.KHR_TEXTURE_TRANSFORM ] : undefined;

					if ( transform ) {

						const gltfReference = parser.associations.get( texture );
						texture = parser.extensions[ EXTENSIONS$1.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
						parser.associations.set( texture, gltfReference );

					}

				}

				if ( encoding !== undefined ) {

					texture.encoding = encoding;

				}

				materialParams[ mapName ] = texture;

				return texture;

			} );

		}

		/**
		 * Assigns final material to a Mesh, Line, or Points instance. The instance
		 * already has a material (generated from the glTF material options alone)
		 * but reuse of the same glTF material may require multiple threejs materials
		 * to accommodate different primitive types, defines, etc. New materials will
		 * be created if necessary, and reused from a cache.
		 * @param  {Object3D} mesh Mesh, Line, or Points instance.
		 */
		assignFinalMaterial( mesh ) {

			const geometry = mesh.geometry;
			let material = mesh.material;

			const useDerivativeTangents = geometry.attributes.tangent === undefined;
			const useVertexColors = geometry.attributes.color !== undefined;
			const useFlatShading = geometry.attributes.normal === undefined;

			if ( mesh.isPoints ) {

				const cacheKey = 'PointsMaterial:' + material.uuid;

				let pointsMaterial = this.cache.get( cacheKey );

				if ( ! pointsMaterial ) {

					pointsMaterial = new PointsMaterial();
					Material.prototype.copy.call( pointsMaterial, material );
					pointsMaterial.color.copy( material.color );
					pointsMaterial.map = material.map;
					pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

					this.cache.add( cacheKey, pointsMaterial );

				}

				material = pointsMaterial;

			} else if ( mesh.isLine ) {

				const cacheKey = 'LineBasicMaterial:' + material.uuid;

				let lineMaterial = this.cache.get( cacheKey );

				if ( ! lineMaterial ) {

					lineMaterial = new LineBasicMaterial();
					Material.prototype.copy.call( lineMaterial, material );
					lineMaterial.color.copy( material.color );

					this.cache.add( cacheKey, lineMaterial );

				}

				material = lineMaterial;

			}

			// Clone the material if it will be modified
			if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

				let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

				if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
				if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
				if ( useVertexColors ) cacheKey += 'vertex-colors:';
				if ( useFlatShading ) cacheKey += 'flat-shading:';

				let cachedMaterial = this.cache.get( cacheKey );

				if ( ! cachedMaterial ) {

					cachedMaterial = material.clone();

					if ( useVertexColors ) cachedMaterial.vertexColors = true;
					if ( useFlatShading ) cachedMaterial.flatShading = true;

					if ( useDerivativeTangents ) {

						// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
						if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
						if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

					}

					this.cache.add( cacheKey, cachedMaterial );

					this.associations.set( cachedMaterial, this.associations.get( material ) );

				}

				material = cachedMaterial;

			}

			// workarounds for mesh and geometry

			if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

				geometry.setAttribute( 'uv2', geometry.attributes.uv );

			}

			mesh.material = material;

		}

		getMaterialType( /* materialIndex */ ) {

			return MeshStandardMaterial;

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
		 * @param {number} materialIndex
		 * @return {Promise<Material>}
		 */
		loadMaterial( materialIndex ) {

			const parser = this;
			const json = this.json;
			const extensions = this.extensions;
			const materialDef = json.materials[ materialIndex ];

			let materialType;
			const materialParams = {};
			const materialExtensions = materialDef.extensions || {};

			const pending = [];

			if ( materialExtensions[ EXTENSIONS$1.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

				const sgExtension = extensions[ EXTENSIONS$1.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
				materialType = sgExtension.getMaterialType();
				pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

			} else if ( materialExtensions[ EXTENSIONS$1.KHR_MATERIALS_UNLIT ] ) {

				const kmuExtension = extensions[ EXTENSIONS$1.KHR_MATERIALS_UNLIT ];
				materialType = kmuExtension.getMaterialType();
				pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

			} else {

				// Specification:
				// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

				const metallicRoughness = materialDef.pbrMetallicRoughness || {};

				materialParams.color = new Color( 1.0, 1.0, 1.0 );
				materialParams.opacity = 1.0;

				if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

					const array = metallicRoughness.baseColorFactor;

					materialParams.color.fromArray( array );
					materialParams.opacity = array[ 3 ];

				}

				if ( metallicRoughness.baseColorTexture !== undefined ) {

					pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding ) );

				}

				materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
				materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

				if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

					pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
					pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

				}

				materialType = this._invokeOne( function ( ext ) {

					return ext.getMaterialType && ext.getMaterialType( materialIndex );

				} );

				pending.push( Promise.all( this._invokeAll( function ( ext ) {

					return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

				} ) ) );

			}

			if ( materialDef.doubleSided === true ) {

				materialParams.side = DoubleSide;

			}

			const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

			if ( alphaMode === ALPHA_MODES.BLEND ) {

				materialParams.transparent = true;

				// See: https://github.com/mrdoob/three.js/issues/17706
				materialParams.depthWrite = false;

			} else {

				materialParams.transparent = false;

				if ( alphaMode === ALPHA_MODES.MASK ) {

					materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

				}

			}

			if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {

				pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

				materialParams.normalScale = new Vector2( 1, 1 );

				if ( materialDef.normalTexture.scale !== undefined ) {

					const scale = materialDef.normalTexture.scale;

					materialParams.normalScale.set( scale, scale );

				}

			}

			if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {

				pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

				if ( materialDef.occlusionTexture.strength !== undefined ) {

					materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

				}

			}

			if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {

				materialParams.emissive = new Color().fromArray( materialDef.emissiveFactor );

			}

			if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {

				pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, sRGBEncoding ) );

			}

			return Promise.all( pending ).then( function () {

				let material;

				if ( materialType === GLTFMeshStandardSGMaterial ) {

					material = extensions[ EXTENSIONS$1.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

				} else {

					material = new materialType( materialParams );

				}

				if ( materialDef.name ) material.name = materialDef.name;

				assignExtrasToUserData( material, materialDef );

				parser.associations.set( material, { materials: materialIndex } );

				if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

				return material;

			} );

		}

		/** When Object3D instances are targeted by animation, they need unique names. */
		createUniqueName( originalName ) {

			const sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );

			let name = sanitizedName;

			for ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

				name = sanitizedName + '_' + i;

			}

			this.nodeNamesUsed[ name ] = true;

			return name;

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
		 *
		 * Creates BufferGeometries from primitives.
		 *
		 * @param {Array<GLTF.Primitive>} primitives
		 * @return {Promise<Array<BufferGeometry>>}
		 */
		loadGeometries( primitives ) {

			const parser = this;
			const extensions = this.extensions;
			const cache = this.primitiveCache;

			function createDracoPrimitive( primitive ) {

				return extensions[ EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION ]
					.decodePrimitive( primitive, parser )
					.then( function ( geometry ) {

						return addPrimitiveAttributes( geometry, primitive, parser );

					} );

			}

			const pending = [];

			for ( let i = 0, il = primitives.length; i < il; i ++ ) {

				const primitive = primitives[ i ];
				const cacheKey = createPrimitiveKey( primitive );

				// See if we've already created this geometry
				const cached = cache[ cacheKey ];

				if ( cached ) {

					// Use the cached geometry if it exists
					pending.push( cached.promise );

				} else {

					let geometryPromise;

					if ( primitive.extensions && primitive.extensions[ EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION ] ) {

						// Use DRACO geometry if available
						geometryPromise = createDracoPrimitive( primitive );

					} else {

						// Otherwise create a new geometry
						geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );

					}

					// Cache this geometry
					cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

					pending.push( geometryPromise );

				}

			}

			return Promise.all( pending );

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
		 * @param {number} meshIndex
		 * @return {Promise<Group|Mesh|SkinnedMesh>}
		 */
		loadMesh( meshIndex ) {

			const parser = this;
			const json = this.json;
			const extensions = this.extensions;

			const meshDef = json.meshes[ meshIndex ];
			const primitives = meshDef.primitives;

			const pending = [];

			for ( let i = 0, il = primitives.length; i < il; i ++ ) {

				const material = primitives[ i ].material === undefined
					? createDefaultMaterial$1( this.cache )
					: this.getDependency( 'material', primitives[ i ].material );

				pending.push( material );

			}

			pending.push( parser.loadGeometries( primitives ) );

			return Promise.all( pending ).then( function ( results ) {

				const materials = results.slice( 0, results.length - 1 );
				const geometries = results[ results.length - 1 ];

				const meshes = [];

				for ( let i = 0, il = geometries.length; i < il; i ++ ) {

					const geometry = geometries[ i ];
					const primitive = primitives[ i ];

					// 1. create Mesh

					let mesh;

					const material = materials[ i ];

					if ( primitive.mode === WEBGL_CONSTANTS$1.TRIANGLES ||
							primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP ||
							primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN ||
							primitive.mode === undefined ) {

						// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
						mesh = meshDef.isSkinnedMesh === true
							? new SkinnedMesh( geometry, material )
							: new Mesh( geometry, material );

						if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

							// we normalize floating point skin weight array to fix malformed assets (see #15319)
							// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
							mesh.normalizeSkinWeights();

						}

						if ( primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP ) {

							mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );

						} else if ( primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN ) {

							mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );

						}

					} else if ( primitive.mode === WEBGL_CONSTANTS$1.LINES ) {

						mesh = new LineSegments( geometry, material );

					} else if ( primitive.mode === WEBGL_CONSTANTS$1.LINE_STRIP ) {

						mesh = new Line( geometry, material );

					} else if ( primitive.mode === WEBGL_CONSTANTS$1.LINE_LOOP ) {

						mesh = new LineLoop( geometry, material );

					} else if ( primitive.mode === WEBGL_CONSTANTS$1.POINTS ) {

						mesh = new Points( geometry, material );

					} else {

						throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

					}

					if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

						updateMorphTargets( mesh, meshDef );

					}

					mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

					assignExtrasToUserData( mesh, meshDef );

					if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

					parser.assignFinalMaterial( mesh );

					meshes.push( mesh );

				}

				for ( let i = 0, il = meshes.length; i < il; i ++ ) {

					parser.associations.set( meshes[ i ], {
						meshes: meshIndex,
						primitives: i
					} );

				}

				if ( meshes.length === 1 ) {

					return meshes[ 0 ];

				}

				const group = new Group();

				parser.associations.set( group, { meshes: meshIndex } );

				for ( let i = 0, il = meshes.length; i < il; i ++ ) {

					group.add( meshes[ i ] );

				}

				return group;

			} );

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
		 * @param {number} cameraIndex
		 * @return {Promise<THREE.Camera>}
		 */
		loadCamera( cameraIndex ) {

			let camera;
			const cameraDef = this.json.cameras[ cameraIndex ];
			const params = cameraDef[ cameraDef.type ];

			if ( ! params ) {

				console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
				return;

			}

			if ( cameraDef.type === 'perspective' ) {

				camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

			} else if ( cameraDef.type === 'orthographic' ) {

				camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

			}

			if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

			assignExtrasToUserData( camera, cameraDef );

			return Promise.resolve( camera );

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
		 * @param {number} skinIndex
		 * @return {Promise<Object>}
		 */
		loadSkin( skinIndex ) {

			const skinDef = this.json.skins[ skinIndex ];

			const skinEntry = { joints: skinDef.joints };

			if ( skinDef.inverseBindMatrices === undefined ) {

				return Promise.resolve( skinEntry );

			}

			return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

				skinEntry.inverseBindMatrices = accessor;

				return skinEntry;

			} );

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
		 * @param {number} animationIndex
		 * @return {Promise<AnimationClip>}
		 */
		loadAnimation( animationIndex ) {

			const json = this.json;

			const animationDef = json.animations[ animationIndex ];

			const pendingNodes = [];
			const pendingInputAccessors = [];
			const pendingOutputAccessors = [];
			const pendingSamplers = [];
			const pendingTargets = [];

			for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

				const channel = animationDef.channels[ i ];
				const sampler = animationDef.samplers[ channel.sampler ];
				const target = channel.target;
				const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
				const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
				const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

				pendingNodes.push( this.getDependency( 'node', name ) );
				pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
				pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
				pendingSamplers.push( sampler );
				pendingTargets.push( target );

			}

			return Promise.all( [

				Promise.all( pendingNodes ),
				Promise.all( pendingInputAccessors ),
				Promise.all( pendingOutputAccessors ),
				Promise.all( pendingSamplers ),
				Promise.all( pendingTargets )

			] ).then( function ( dependencies ) {

				const nodes = dependencies[ 0 ];
				const inputAccessors = dependencies[ 1 ];
				const outputAccessors = dependencies[ 2 ];
				const samplers = dependencies[ 3 ];
				const targets = dependencies[ 4 ];

				const tracks = [];

				for ( let i = 0, il = nodes.length; i < il; i ++ ) {

					const node = nodes[ i ];
					const inputAccessor = inputAccessors[ i ];
					const outputAccessor = outputAccessors[ i ];
					const sampler = samplers[ i ];
					const target = targets[ i ];

					if ( node === undefined ) continue;

					node.updateMatrix();
					node.matrixAutoUpdate = true;

					let TypedKeyframeTrack;

					switch ( PATH_PROPERTIES$1[ target.path ] ) {

						case PATH_PROPERTIES$1.weights:

							TypedKeyframeTrack = NumberKeyframeTrack;
							break;

						case PATH_PROPERTIES$1.rotation:

							TypedKeyframeTrack = QuaternionKeyframeTrack;
							break;

						case PATH_PROPERTIES$1.position:
						case PATH_PROPERTIES$1.scale:
						default:

							TypedKeyframeTrack = VectorKeyframeTrack;
							break;

					}

					const targetName = node.name ? node.name : node.uuid;

					const interpolation = sampler.interpolation !== undefined ? INTERPOLATION$1[ sampler.interpolation ] : InterpolateLinear;

					const targetNames = [];

					if ( PATH_PROPERTIES$1[ target.path ] === PATH_PROPERTIES$1.weights ) {

						node.traverse( function ( object ) {

							if ( object.morphTargetInfluences ) {

								targetNames.push( object.name ? object.name : object.uuid );

							}

						} );

					} else {

						targetNames.push( targetName );

					}

					let outputArray = outputAccessor.array;

					if ( outputAccessor.normalized ) {

						const scale = getNormalizedComponentScale( outputArray.constructor );
						const scaled = new Float32Array( outputArray.length );

						for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

							scaled[ j ] = outputArray[ j ] * scale;

						}

						outputArray = scaled;

					}

					for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

						const track = new TypedKeyframeTrack(
							targetNames[ j ] + '.' + PATH_PROPERTIES$1[ target.path ],
							inputAccessor.array,
							outputArray,
							interpolation
						);

						// Override interpolation with custom factory method.
						if ( sampler.interpolation === 'CUBICSPLINE' ) {

							track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

								// A CUBICSPLINE keyframe in glTF has three output values for each input value,
								// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
								// must be divided by three to get the interpolant's sampleSize argument.

								const interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

								return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

							};

							// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
							track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

						}

						tracks.push( track );

					}

				}

				const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

				return new AnimationClip( name, undefined, tracks );

			} );

		}

		createNodeMesh( nodeIndex ) {

			const json = this.json;
			const parser = this;
			const nodeDef = json.nodes[ nodeIndex ];

			if ( nodeDef.mesh === undefined ) return null;

			return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

				const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

				// if weights are provided on the node, override weights on the mesh.
				if ( nodeDef.weights !== undefined ) {

					node.traverse( function ( o ) {

						if ( ! o.isMesh ) return;

						for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

							o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

						}

					} );

				}

				return node;

			} );

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
		 * @param {number} nodeIndex
		 * @return {Promise<Object3D>}
		 */
		loadNode( nodeIndex ) {

			const json = this.json;
			const extensions = this.extensions;
			const parser = this;

			const nodeDef = json.nodes[ nodeIndex ];

			// reserve node's name before its dependencies, so the root has the intended name.
			const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

			return ( function () {

				const pending = [];

				const meshPromise = parser._invokeOne( function ( ext ) {

					return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

				} );

				if ( meshPromise ) {

					pending.push( meshPromise );

				}

				if ( nodeDef.camera !== undefined ) {

					pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

						return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

					} ) );

				}

				parser._invokeAll( function ( ext ) {

					return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

				} ).forEach( function ( promise ) {

					pending.push( promise );

				} );

				return Promise.all( pending );

			}() ).then( function ( objects ) {

				let node;

				// .isBone isn't in glTF spec. See ._markDefs
				if ( nodeDef.isBone === true ) {

					node = new Bone();

				} else if ( objects.length > 1 ) {

					node = new Group();

				} else if ( objects.length === 1 ) {

					node = objects[ 0 ];

				} else {

					node = new Object3D();

				}

				if ( node !== objects[ 0 ] ) {

					for ( let i = 0, il = objects.length; i < il; i ++ ) {

						node.add( objects[ i ] );

					}

				}

				if ( nodeDef.name ) {

					node.userData.name = nodeDef.name;
					node.name = nodeName;

				}

				assignExtrasToUserData( node, nodeDef );

				if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

				if ( nodeDef.matrix !== undefined ) {

					const matrix = new Matrix4();
					matrix.fromArray( nodeDef.matrix );
					node.applyMatrix4( matrix );

				} else {

					if ( nodeDef.translation !== undefined ) {

						node.position.fromArray( nodeDef.translation );

					}

					if ( nodeDef.rotation !== undefined ) {

						node.quaternion.fromArray( nodeDef.rotation );

					}

					if ( nodeDef.scale !== undefined ) {

						node.scale.fromArray( nodeDef.scale );

					}

				}

				if ( ! parser.associations.has( node ) ) {

					parser.associations.set( node, {} );

				}

				parser.associations.get( node ).nodes = nodeIndex;

				return node;

			} );

		}

		/**
		 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
		 * @param {number} sceneIndex
		 * @return {Promise<Group>}
		 */
		loadScene( sceneIndex ) {

			const json = this.json;
			const extensions = this.extensions;
			const sceneDef = this.json.scenes[ sceneIndex ];
			const parser = this;

			// Loader returns Group, not Scene.
			// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
			const scene = new Group();
			if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

			assignExtrasToUserData( scene, sceneDef );

			if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

			const nodeIds = sceneDef.nodes || [];

			const pending = [];

			for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

				pending.push( buildNodeHierarchy( nodeIds[ i ], scene, json, parser ) );

			}

			return Promise.all( pending ).then( function () {

				// Removes dangling associations, associations that reference a node that
				// didn't make it into the scene.
				const reduceAssociations = ( node ) => {

					const reducedAssociations = new Map();

					for ( const [ key, value ] of parser.associations ) {

						if ( key instanceof Material || key instanceof Texture ) {

							reducedAssociations.set( key, value );

						}

					}

					node.traverse( ( node ) => {

						const mappings = parser.associations.get( node );

						if ( mappings != null ) {

							reducedAssociations.set( node, mappings );

						}

					} );

					return reducedAssociations;

				};

				parser.associations = reduceAssociations( scene );

				return scene;

			} );

		}

	}

	function buildNodeHierarchy( nodeId, parentObject, json, parser ) {

		const nodeDef = json.nodes[ nodeId ];

		return parser.getDependency( 'node', nodeId ).then( function ( node ) {

			if ( nodeDef.skin === undefined ) return node;

			// build skeleton here as well

			let skinEntry;

			return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

				skinEntry = skin;

				const pendingJoints = [];

				for ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

					pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

				}

				return Promise.all( pendingJoints );

			} ).then( function ( jointNodes ) {

				node.traverse( function ( mesh ) {

					if ( ! mesh.isMesh ) return;

					const bones = [];
					const boneInverses = [];

					for ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {

						const jointNode = jointNodes[ j ];

						if ( jointNode ) {

							bones.push( jointNode );

							const mat = new Matrix4();

							if ( skinEntry.inverseBindMatrices !== undefined ) {

								mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

							}

							boneInverses.push( mat );

						} else {

							console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

						}

					}

					mesh.bind( new Skeleton( bones, boneInverses ), mesh.matrixWorld );

				} );

				return node;

			} );

		} ).then( function ( node ) {

			// build node hierachy

			parentObject.add( node );

			const pending = [];

			if ( nodeDef.children ) {

				const children = nodeDef.children;

				for ( let i = 0, il = children.length; i < il; i ++ ) {

					const child = children[ i ];
					pending.push( buildNodeHierarchy( child, node, json, parser ) );

				}

			}

			return Promise.all( pending );

		} );

	}

	/**
	 * @param {BufferGeometry} geometry
	 * @param {GLTF.Primitive} primitiveDef
	 * @param {GLTFParser} parser
	 */
	function computeBounds( geometry, primitiveDef, parser ) {

		const attributes = primitiveDef.attributes;

		const box = new Box3();

		if ( attributes.POSITION !== undefined ) {

			const accessor = parser.json.accessors[ attributes.POSITION ];

			const min = accessor.min;
			const max = accessor.max;

			// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

			if ( min !== undefined && max !== undefined ) {

				box.set(
					new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
					new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
				);

				if ( accessor.normalized ) {

					const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES$1[ accessor.componentType ] );
					box.min.multiplyScalar( boxScale );
					box.max.multiplyScalar( boxScale );

				}

			} else {

				console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				return;

			}

		} else {

			return;

		}

		const targets = primitiveDef.targets;

		if ( targets !== undefined ) {

			const maxDisplacement = new Vector3();
			const vector = new Vector3();

			for ( let i = 0, il = targets.length; i < il; i ++ ) {

				const target = targets[ i ];

				if ( target.POSITION !== undefined ) {

					const accessor = parser.json.accessors[ target.POSITION ];
					const min = accessor.min;
					const max = accessor.max;

					// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

					if ( min !== undefined && max !== undefined ) {

						// we need to get max of absolute components because target weight is [-1,1]
						vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
						vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
						vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


						if ( accessor.normalized ) {

							const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES$1[ accessor.componentType ] );
							vector.multiplyScalar( boxScale );

						}

						// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
						// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
						// are used to implement key-frame animations and as such only two are active at a time - this results in very large
						// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
						maxDisplacement.max( vector );

					} else {

						console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

					}

				}

			}

			// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
			box.expandByVector( maxDisplacement );

		}

		geometry.boundingBox = box;

		const sphere = new Sphere();

		box.getCenter( sphere.center );
		sphere.radius = box.min.distanceTo( box.max ) / 2;

		geometry.boundingSphere = sphere;

	}

	/**
	 * @param {BufferGeometry} geometry
	 * @param {GLTF.Primitive} primitiveDef
	 * @param {GLTFParser} parser
	 * @return {Promise<BufferGeometry>}
	 */
	function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

		const attributes = primitiveDef.attributes;

		const pending = [];

		function assignAttributeAccessor( accessorIndex, attributeName ) {

			return parser.getDependency( 'accessor', accessorIndex )
				.then( function ( accessor ) {

					geometry.setAttribute( attributeName, accessor );

				} );

		}

		for ( const gltfAttributeName in attributes ) {

			const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

			// Skip attributes already provided by e.g. Draco extension.
			if ( threeAttributeName in geometry.attributes ) continue;

			pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

		}

		if ( primitiveDef.indices !== undefined && ! geometry.index ) {

			const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

				geometry.setIndex( accessor );

			} );

			pending.push( accessor );

		}

		assignExtrasToUserData( geometry, primitiveDef );

		computeBounds( geometry, primitiveDef, parser );

		return Promise.all( pending ).then( function () {

			return primitiveDef.targets !== undefined
				? addMorphTargets( geometry, primitiveDef.targets, parser )
				: geometry;

		} );

	}

	/**
	 * @param {BufferGeometry} geometry
	 * @param {Number} drawMode
	 * @return {BufferGeometry}
	 */
	function toTrianglesDrawMode( geometry, drawMode ) {

		let index = geometry.getIndex();

		// generate index if not present

		if ( index === null ) {

			const indices = [];

			const position = geometry.getAttribute( 'position' );

			if ( position !== undefined ) {

				for ( let i = 0; i < position.count; i ++ ) {

					indices.push( i );

				}

				geometry.setIndex( indices );
				index = geometry.getIndex();

			} else {

				console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
				return geometry;

			}

		}

		//

		const numberOfTriangles = index.count - 2;
		const newIndices = [];

		if ( drawMode === TriangleFanDrawMode ) {

			// gl.TRIANGLE_FAN

			for ( let i = 1; i <= numberOfTriangles; i ++ ) {

				newIndices.push( index.getX( 0 ) );
				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );

			}

		} else {

			// gl.TRIANGLE_STRIP

			for ( let i = 0; i < numberOfTriangles; i ++ ) {

				if ( i % 2 === 0 ) {

					newIndices.push( index.getX( i ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i + 2 ) );


				} else {

					newIndices.push( index.getX( i + 2 ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i ) );

				}

			}

		}

		if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

			console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

		}

		// build final geometry

		const newGeometry = geometry.clone();
		newGeometry.setIndex( newIndices );

		return newGeometry;

	}

	class VRButton {

		static createButton( renderer, options ) {

			if ( options ) {

				console.error( 'THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.' );

			}

			const button = document.createElement( 'button' );

			function showEnterVR( /*device*/ ) {

				let currentSession = null;

				async function onSessionStarted( session ) {

					session.addEventListener( 'end', onSessionEnded );

					await renderer.xr.setSession( session );
					button.textContent = 'EXIT VR';

					currentSession = session;

				}

				function onSessionEnded( /*event*/ ) {

					currentSession.removeEventListener( 'end', onSessionEnded );

					button.textContent = 'ENTER VR';

					currentSession = null;

				}

				//

				button.style.display = '';

				button.style.cursor = 'pointer';
				button.style.left = 'calc(50% - 50px)';
				button.style.width = '100px';

				button.textContent = 'ENTER VR';

				button.onmouseenter = function () {

					button.style.opacity = '1.0';

				};

				button.onmouseleave = function () {

					button.style.opacity = '0.5';

				};

				button.onclick = function () {

					if ( currentSession === null ) {

						// WebXR's requestReferenceSpace only works if the corresponding feature
						// was requested at session creation time. For simplicity, just ask for
						// the interesting ones as optional features, but be aware that the
						// requestReferenceSpace call will fail if it turns out to be unavailable.
						// ('local' is always available for immersive sessions and doesn't need to
						// be requested separately.)

						const sessionInit = { optionalFeatures: [ 'local-floor', 'bounded-floor', 'hand-tracking', 'layers' ] };
						navigator.xr.requestSession( 'immersive-vr', sessionInit ).then( onSessionStarted );

					} else {

						currentSession.end();

					}

				};

			}

			function disableButton() {

				button.style.display = '';

				button.style.cursor = 'auto';
				button.style.left = 'calc(50% - 75px)';
				button.style.width = '150px';

				button.onmouseenter = null;
				button.onmouseleave = null;

				button.onclick = null;

			}

			function showWebXRNotFound() {

				disableButton();

				button.textContent = 'VR NOT SUPPORTED';

			}

			function showVRNotAllowed( exception ) {

				disableButton();

				console.warn( 'Exception when trying to call xr.isSessionSupported', exception );

				button.textContent = 'VR NOT ALLOWED';

			}

			function stylizeElement( element ) {

				element.style.position = 'absolute';
				element.style.bottom = '20px';
				element.style.padding = '12px 6px';
				element.style.border = '1px solid #fff';
				element.style.borderRadius = '4px';
				element.style.background = 'rgba(0,0,0,0.1)';
				element.style.color = '#fff';
				element.style.font = 'normal 13px sans-serif';
				element.style.textAlign = 'center';
				element.style.opacity = '0.5';
				element.style.outline = 'none';
				element.style.zIndex = '999';

			}

			if ( 'xr' in navigator ) {

				button.id = 'VRButton';
				button.style.display = 'none';

				stylizeElement( button );

				navigator.xr.isSessionSupported( 'immersive-vr' ).then( function ( supported ) {

					supported ? showEnterVR() : showWebXRNotFound();

					if ( supported && VRButton.xrSessionIsGranted ) {

						button.click();

					}

				} ).catch( showVRNotAllowed );

				return button;

			} else {

				const message = document.createElement( 'a' );

				if ( window.isSecureContext === false ) {

					message.href = document.location.href.replace( /^http:/, 'https:' );
					message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message

				} else {

					message.href = 'https://immersiveweb.dev/';
					message.innerHTML = 'WEBXR NOT AVAILABLE';

				}

				message.style.left = 'calc(50% - 90px)';
				message.style.width = '180px';
				message.style.textDecoration = 'none';

				stylizeElement( message );

				return message;

			}

		}

		static xrSessionIsGranted = false;

		static registerSessionGrantedListener() {

			if ( 'xr' in navigator ) {

				navigator.xr.addEventListener( 'sessiongranted', () => {

					VRButton.xrSessionIsGranted = true;

				} );

			}

		}

	}

	VRButton.registerSessionGrantedListener();

	/*!
	 * three-icosa
	 * https://github.com/icosa-gallery/three-icosa
	 * Copyright (c) 2021-2022 Icosa Gallery
	 * Released under the Apache 2.0 Licence.
	 */

	// Copyright 2021-2022 Icosa Gallery

	class TiltShaderLoader$1 extends Loader {
	    constructor( manager ) {
	        super( manager );
	        
	        this.loadedMaterials = {};
	    }
	    
	    async load(brushName, onLoad, onProgress, onError ) {
	        const scope = this;

	        const isAlreadyLoaded = this.loadedMaterials[brushName];
	        
	        if (isAlreadyLoaded !== undefined) {
	            onLoad( scope.parse( isAlreadyLoaded ) );
	            return;
	        }
	        
			const loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'text' );
			loader.setWithCredentials( this.withCredentials );

	        const textureLoader = new TextureLoader(this.manager);
	        textureLoader.setPath(this.path);
	        textureLoader.setWithCredentials( this.withCredentials );

	        const materialParams = tiltBrushMaterialParams$1[brushName];

	        materialParams.vertexShader = await loader.loadAsync(materialParams.vertexShader);
	        materialParams.fragmentShader = await loader.loadAsync(materialParams.fragmentShader);

	        if (materialParams.uniforms.u_MainTex) {
	            const mainTex = await textureLoader.loadAsync(materialParams.uniforms.u_MainTex.value);
	            mainTex.name = `${brushName}_MainTex`;
	            mainTex.wrapS = RepeatWrapping;
	            mainTex.wrapT = RepeatWrapping;
	            mainTex.flipY = false;
	            materialParams.uniforms.u_MainTex.value = mainTex;
	        }

	        if (materialParams.uniforms.u_BumpMap) {
	            const bumpMap = await textureLoader.loadAsync(materialParams.uniforms.u_BumpMap.value);
	            bumpMap.name = `${brushName}_BumpMap`;
	            bumpMap.wrapS = RepeatWrapping;
	            bumpMap.wrapT = RepeatWrapping;
	            bumpMap.flipY = false;
	            materialParams.uniforms.u_BumpMap.value = bumpMap;
	        }

	        if (materialParams.uniforms.u_AlphaMask) {
	            const alphaMask = await textureLoader.loadAsync(materialParams.uniforms.u_AlphaMask.value);
	            alphaMask.name = `${brushName}_AlphaMask`;
	            alphaMask.wrapS = RepeatWrapping;
	            alphaMask.wrapT = RepeatWrapping;
	            alphaMask.flipY = false;
	            materialParams.uniforms.u_AlphaMask.value = alphaMask;
	        }

	        // inject three.js lighting uniforms
	        for(var lightType in UniformsLib.lights)
	        {
	            materialParams.uniforms[lightType] = UniformsLib.lights[lightType];
	        }

	        let rawMaterial = new RawShaderMaterial(materialParams);
	        this.loadedMaterials[brushName] = rawMaterial;
	        onLoad( scope.parse( rawMaterial ) );
	    }

	    parse( rawMaterial ) {
	        return rawMaterial;
	    }

	    lookupMaterial(nameOrGuid) {
	        const name = this.lookupMaterialName(nameOrGuid);
	        return tiltBrushMaterialParams$1[name];
	    }

	    lookupMaterialName(nameOrGuid) {
	        switch(nameOrGuid) {
	            case "BlocksBasic:":
	            case "0e87b49c-6546-3a34-3a44-8a556d7d6c3e":
	                return "BlocksBasic";

	            case "BlocksGem":
	            case "232998f8-d357-47a2-993a-53415df9be10":
	                return "BlocksGem";

	            case "BlocksGlass":
	            case "3d813d82-5839-4450-8ddc-8e889ecd96c7":
	                return "BlocksGlass";

	            case "Bubbles":
	            case "89d104cd-d012-426b-b5b3-bbaee63ac43c":
	                return "Bubbles";

	            case "CelVinyl":
	            case "700f3aa8-9a7c-2384-8b8a-ea028905dd8c":
	                return "CelVinyl";

	            case "ChromaticWave":
	            case "0f0ff7b2-a677-45eb-a7d6-0cd7206f4816":
	                return "ChromaticWave";

	            case "CoarseBristles":
	            case "1161af82-50cf-47db-9706-0c3576d43c43":
	            case "79168f10-6961-464a-8be1-57ed364c5600":
	                return "CoarseBristles";
	                
	            case "Comet":
	            case "1caa6d7d-f015-3f54-3a4b-8b5354d39f81":
	                return "Comet";
	            
	            case "DiamondHull":
	            case "c8313697-2563-47fc-832e-290f4c04b901":
	                return "DiamondHull";
	            
	            case "Disco":
	            case "4391aaaa-df73-4396-9e33-31e4e4930b27":
	                return "Disco";
	            
	            case "DotMarker":
	            case "d1d991f2-e7a0-4cf1-b328-f57e915e6260":
	                return "DotMarker";
	            
	            case "Dots":
	            case "6a1cf9f9-032c-45ec-9b1d-a6680bee30f7":
	                return "Dots";

	            case "DoubleTaperedFlat":
	            case "0d3889f3-3ede-470c-8af4-f44813306126":
	                return "DoubleTaperedFlat";
	            
	            case "DoubleTaperedMarker":
	            case "0d3889f3-3ede-470c-8af4-de4813306126":
	                return "DoubleTaperedMarker";
	            
	            case "DuctTape":
	            case "d0262945-853c-4481-9cbd-88586bed93cb":
	            case "3ca16e2f-bdcd-4da2-8631-dcef342f40f1":
	                return "DuctTape";
	            
	            case "Electricity":
	            case "f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51":
	                return "Electricity";

	            case "Embers":
	            case "02ffb866-7fb2-4d15-b761-1012cefb1360":
	                return "Embers";
	            
	            case "EnvironmentDiffuse":
	            case "0ad58bbd-42bc-484e-ad9a-b61036ff4ce7": 
	                return "EnvironmentDiffuse";
	            
	            case "EnvironmentDiffuseLightMap":
	            case "d01d9d6c-9a61-4aba-8146-5891fafb013b":
	                return "EnvironmentDiffuseLightMap";

	            case "Fire":
	            case "cb92b597-94ca-4255-b017-0e3f42f12f9e":
	                return "Fire";

	            case "2d35bcf0-e4d8-452c-97b1-3311be063130":
	            case "280c0a7a-aad8-416c-a7d2-df63d129ca70":
	            case "55303bc4-c749-4a72-98d9-d23e68e76e18":
	            case "Flat":
	                return "Flat";
	            
	            case "cf019139-d41c-4eb0-a1d0-5cf54b0a42f3":
	            case "geometry_Highlighter":
	                return "Highlighter";
	            
	            case "Hypercolor":
	            case "dce872c2-7b49-4684-b59b-c45387949c5c":
	            case "e8ef32b1-baa8-460a-9c2c-9cf8506794f5":
	                return "Hypercolor";
	            
	            case "HyperGrid":
	            case "6a1cf9f9-032c-45ec-9b6e-a6680bee32e9":
	                return "HyperGrid";

	            case "Icing":
	            case "2f212815-f4d3-c1a4-681a-feeaf9c6dc37":
	                return "Icing";
	            
	            case "Ink":
	            case "f5c336cf-5108-4b40-ade9-c687504385ab":
	            case "c0012095-3ffd-4040-8ee1-fc180d346eaa":
	                return "Ink";

	            case "Leaves":
	            case "4a76a27a-44d8-4bfe-9a8c-713749a499b0":
	            case "ea19de07-d0c0-4484-9198-18489a3c1487":
	                return "Leaves";

	            case "Light":
	            case "2241cd32-8ba2-48a5-9ee7-2caef7e9ed62":
	                return "Light";

	            case "LightWire":
	            case "4391aaaa-df81-4396-9e33-31e4e4930b27":
	                return "LightWire";
	            
	            case "Lofted":
	            case "d381e0f5-3def-4a0d-8853-31e9200bcbda":
	                return "Lofted";

	            case "Marker":
	            case "429ed64a-4e97-4466-84d3-145a861ef684":
	                return "Marker";
	            
	            case "MatteHull":
	            case "79348357-432d-4746-8e29-0e25c112e3aa":
	                return "MatteHull";

	            case "NeonPulse":
	            case "b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6":
	                return "NeonPulse";

	            case "OilPaint":
	            case "f72ec0e7-a844-4e38-82e3-140c44772699":
	            case "c515dad7-4393-4681-81ad-162ef052241b":
	                return "OilPaint";

	            case "Paper":
	            case "f1114e2e-eb8d-4fde-915a-6e653b54e9f5":
	            case "759f1ebd-20cd-4720-8d41-234e0da63716":
	                return "Paper";
	            
	            case "PbrTemplate":
	            case "f86a096c-2f4f-4f9d-ae19-81b99f2944e0":
	                return "PbrTemplate";
	            
	            case "PbrTransparentTemplate":
	            case "19826f62-42ac-4a9e-8b77-4231fbd0cfbf":
	                return "PbrTransparentTemplate";
	            
	            case "Petal":
	            case "e0abbc80-0f80-e854-4970-8924a0863dcc":
	                return "Petal";

	            case "Plasma":
	            case "c33714d1-b2f9-412e-bd50-1884c9d46336":
	                return "Plasma";
	            
	            case "Rainbow":
	            case "ad1ad437-76e2-450d-a23a-e17f8310b960":
	                return "Rainbow";

	            case "ShinyHull":
	            case "faaa4d44-fcfb-4177-96be-753ac0421ba3":
	                return "ShinyHull";

	            case "Smoke":
	            case "70d79cca-b159-4f35-990c-f02193947fe8":
	                return "Smoke";
	            
	            case "Snow":
	            case "d902ed8b-d0d1-476c-a8de-878a79e3a34c":
	                return "Snow";

	            case "SoftHighlighter":
	            case "accb32f5-4509-454f-93f8-1df3fd31df1b":
	                return "SoftHighlighter";
	            
	            case "Spikes":
	            case "cf7f0059-7aeb-53a4-2b67-c83d863a9ffa":
	                return "Spikes";
	            
	            case "Splatter":
	            case "8dc4a70c-d558-4efd-a5ed-d4e860f40dc3":
	            case "7a1c8107-50c5-4b70-9a39-421576d6617e":
	                return "Splatter";
	            
	            case "Stars":
	            case "0eb4db27-3f82-408d-b5a1-19ebd7d5b711":
	                return "Stars";

	            case "Streamers":
	            case "44bb800a-fbc3-4592-8426-94ecb05ddec3":
	                return "Streamers";
	            
	            case "Taffy":
	            case "0077f88c-d93a-42f3-b59b-b31c50cdb414":
	                return "Taffy";

	            case "TaperedFlat":
	            case "b468c1fb-f254-41ed-8ec9-57030bc5660c":
	            case "c8ccb53d-ae13-45ef-8afb-b730d81394eb":
	                return "TaperedFlat";

	            case "TaperedMarker":
	            case "d90c6ad8-af0f-4b54-b422-e0f92abe1b3c":
	            case "1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0":
	                return "TaperedMarker";

	            case "ThickPaint":
	            case "75b32cf0-fdd6-4d89-a64b-e2a00b247b0f":
	            case "fdf0326a-c0d1-4fed-b101-9db0ff6d071f":
	                return "ThickPaint";
	            
	            case "Toon":
	            case "4391385a-df73-4396-9e33-31e4e4930b27":
	                return "Toon";

	            case "UnlitHull":
	            case "a8fea537-da7c-4d4b-817f-24f074725d6d":
	                return "UnlitHull";
	            
	            case "VelvetInk":
	            case "d229d335-c334-495a-a801-660ac8a87360":
	                return "VelvetInk";

	            case "Waveform":
	            case "10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab":
	                return "Waveform";

	            case "WetPaint":
	            case "b67c0e81-ce6d-40a8-aeb0-ef036b081aa3":
	            case "dea67637-cd1a-27e4-c9b1-52f4bbcb84e5":
	                return "WetPaint";

	            case "WigglyGraphite":
	            case "5347acf0-a8e2-47b6-8346-30c70719d763":
	            case "e814fef1-97fd-7194-4a2f-50c2bb918be2":
	                return "WigglyGraphite";

	            case "wire":
	            case "4391385a-cf83-4396-9e33-31e4e4930b27":
	                return "Wire";
	        }    }
	}

	const tiltBrushMaterialParams$1 = {
	    "BlocksBasic" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Shininess: { value: 0.2 },
	            u_SpecColor: { value: new Vector3(0.1960784, 0.1960784, 0.1960784) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "BlocksBasic-0e87b49c-6546-3a34-3a44-8a556d7d6c3e/BlocksBasic-0e87b49c-6546-3a34-3a44-8a556d7d6c3e-v10.0-vertex.glsl",
	        fragmentShader: "BlocksBasic-0e87b49c-6546-3a34-3a44-8a556d7d6c3e/BlocksBasic-0e87b49c-6546-3a34-3a44-8a556d7d6c3e-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "BlocksGem" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: {value: new Vector4(0.3922, 0.3922, 0.3922, 1)},
	            u_SceneLight_0_color: {value: new Vector4(0.7780, 0.8157, 0.9914, 1)},
	            u_SceneLight_1_color: {value: new Vector4(0.4282, 0.4212, 0.3459, 1)},
	            u_Color: { value: new Vector4(1, 1, 1, 1) },
	            u_Shininess: { value: 0.9 },
	            u_RimIntensity: { value: 0.5 },
	            u_RimPower: { value: 2 },
	            u_Frequency: { value: 2 },
	            u_Jitter: { value: 1 },
	            u_fogColor: {value: new Vector3(0.0196, 0.0196, 0.0196)},
	            u_fogDensity: {value: 0 }
	        },
	        vertexShader: "BlocksGem-232998f8-d357-47a2-993a-53415df9be10/BlocksGem-232998f8-d357-47a2-993a-53415df9be10-v10.0-vertex.glsl",
	        fragmentShader: "BlocksGem-232998f8-d357-47a2-993a-53415df9be10/BlocksGem-232998f8-d357-47a2-993a-53415df9be10-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "BlocksGlass" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Color: { value: new Vector4(1, 1, 1, 1) },
	            u_Shininess: { value: 0.8 },
	            u_RimIntensity: { value: 0.7 },
	            u_RimPower: { value: 4 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "BlocksGlass-3d813d82-5839-4450-8ddc-8e889ecd96c7/BlocksGlass-3d813d82-5839-4450-8ddc-8e889ecd96c7-v10.0-vertex.glsl",
	        fragmentShader: "BlocksGlass-3d813d82-5839-4450-8ddc-8e889ecd96c7/BlocksGlass-3d813d82-5839-4450-8ddc-8e889ecd96c7-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Bubbles" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Bubbles-89d104cd-d012-426b-b5b3-bbaee63ac43c/Bubbles-89d104cd-d012-426b-b5b3-bbaee63ac43c-v10.0-MainTex.png" },
	        },
	        vertexShader: "Bubbles-89d104cd-d012-426b-b5b3-bbaee63ac43c/Bubbles-89d104cd-d012-426b-b5b3-bbaee63ac43c-v10.0-vertex.glsl",
	        fragmentShader: "Bubbles-89d104cd-d012-426b-b5b3-bbaee63ac43c/Bubbles-89d104cd-d012-426b-b5b3-bbaee63ac43c-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "CelVinyl" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_Cutoff: { value: 0.554 },
	            u_MainTex: { value: "CelVinyl-700f3aa8-9a7c-2384-8b8a-ea028905dd8c/CelVinyl-700f3aa8-9a7c-2384-8b8a-ea028905dd8c-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "CelVinyl-700f3aa8-9a7c-2384-8b8a-ea028905dd8c/CelVinyl-700f3aa8-9a7c-2384-8b8a-ea028905dd8c-v10.0-vertex.glsl",
	        fragmentShader: "CelVinyl-700f3aa8-9a7c-2384-8b8a-ea028905dd8c/CelVinyl-700f3aa8-9a7c-2384-8b8a-ea028905dd8c-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "ChromaticWave" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_time: { value: new Vector4() },
	            u_EmissionGain: { value: 0.45 },
	        },
	        vertexShader: "ChromaticWave-0f0ff7b2-a677-45eb-a7d6-0cd7206f4816/ChromaticWave-0f0ff7b2-a677-45eb-a7d6-0cd7206f4816-v10.0-vertex.glsl",
	        fragmentShader: "ChromaticWave-0f0ff7b2-a677-45eb-a7d6-0cd7206f4816/ChromaticWave-0f0ff7b2-a677-45eb-a7d6-0cd7206f4816-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201
	    },
	    "CoarseBristles" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_MainTex: { value: "CoarseBristles-1161af82-50cf-47db-9706-0c3576d43c43/CoarseBristles-1161af82-50cf-47db-9706-0c3576d43c43-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.25 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "CoarseBristles-1161af82-50cf-47db-9706-0c3576d43c43/CoarseBristles-1161af82-50cf-47db-9706-0c3576d43c43-v10.0-vertex.glsl",
	        fragmentShader: "CoarseBristles-1161af82-50cf-47db-9706-0c3576d43c43/CoarseBristles-1161af82-50cf-47db-9706-0c3576d43c43-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Comet" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81/Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81-v10.0-MainTex.png" },
	            u_AlphaMask: { value: "Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81/Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81-v10.0-AlphaMask.png" },
	            u_AlphaMask_TexelSize: { value: new Vector4(0.0156, 1, 64, 1)},
	            u_time: { value: new Vector4() },
	            u_Speed: { value: 1 },
	            u_EmissionGain: { value: 0.5 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81/Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81-v10.0-vertex.glsl",
	        fragmentShader: "Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81/Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "DiamondHull" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_MainTex: { value: "DiamondHull-c8313697-2563-47fc-832e-290f4c04b901/DiamondHull-c8313697-2563-47fc-832e-290f4c04b901-v10.0-MainTex.png" },
	            u_time: { value: new Vector4() },
	            cameraPosition: { value: new Vector3() },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "DiamondHull-c8313697-2563-47fc-832e-290f4c04b901/DiamondHull-c8313697-2563-47fc-832e-290f4c04b901-v10.0-vertex.glsl",
	        fragmentShader: "DiamondHull-c8313697-2563-47fc-832e-290f4c04b901/DiamondHull-c8313697-2563-47fc-832e-290f4c04b901-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201,
	    },
	    "Disco" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_time: { value: new Vector4() },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Shininess: { value: 0.65 },
	            u_SpecColor: { value: new Vector3(0.5147059, 0.5147059, 0.5147059) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "Disco-4391aaaa-df73-4396-9e33-31e4e4930b27/Disco-4391aaaa-df73-4396-9e33-31e4e4930b27-v10.0-vertex.glsl",
	        fragmentShader: "Disco-4391aaaa-df73-4396-9e33-31e4e4930b27/Disco-4391aaaa-df73-4396-9e33-31e4e4930b27-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "DotMarker" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "DotMarker-d1d991f2-e7a0-4cf1-b328-f57e915e6260/DotMarker-d1d991f2-e7a0-4cf1-b328-f57e915e6260-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "DotMarker-d1d991f2-e7a0-4cf1-b328-f57e915e6260/DotMarker-d1d991f2-e7a0-4cf1-b328-f57e915e6260-v10.0-vertex.glsl",
	        fragmentShader: "DotMarker-d1d991f2-e7a0-4cf1-b328-f57e915e6260/DotMarker-d1d991f2-e7a0-4cf1-b328-f57e915e6260-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0,
	        
	    },
	    "Dots" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Dots-6a1cf9f9-032c-45ec-9b1d-a6680bee30f7/Dots-6a1cf9f9-032c-45ec-9b1d-a6680bee30f7-v10.0-MainTex.png" },
	            u_TintColor: { value: new Vector4(1, 1, 1, 1) },
	            u_EmissionGain: { value: 300 },
	            u_BaseGain: { value: 0.4 }
	        },
	        vertexShader: "Dots-6a1cf9f9-032c-45ec-9b1d-a6680bee30f7/Dots-6a1cf9f9-032c-45ec-9b1d-a6680bee30f7-v10.0-vertex.glsl",
	        fragmentShader: "Dots-6a1cf9f9-032c-45ec-9b1d-a6680bee30f7/Dots-6a1cf9f9-032c-45ec-9b1d-a6680bee30f7-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "DoubleTaperedFlat" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Shininess: { value: 0.1500 },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "DoubleTaperedFlat-0d3889f3-3ede-470c-8af4-f44813306126/DoubleTaperedFlat-0d3889f3-3ede-470c-8af4-f44813306126-v10.0-vertex.glsl",
	        fragmentShader: "DoubleTaperedFlat-0d3889f3-3ede-470c-8af4-f44813306126/DoubleTaperedFlat-0d3889f3-3ede-470c-8af4-f44813306126-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "DoubleTaperedMarker" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "DoubleTaperedMarker-0d3889f3-3ede-470c-8af4-de4813306126/DoubleTaperedMarker-0d3889f3-3ede-470c-8af4-de4813306126-v10.0-vertex.glsl",
	        fragmentShader: "DoubleTaperedMarker-0d3889f3-3ede-470c-8af4-de4813306126/DoubleTaperedMarker-0d3889f3-3ede-470c-8af4-de4813306126-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "DuctTape" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.5372549, 0.5372549, 0.5372549) },
	            u_Shininess: { value: 0.414 },
	            u_MainTex: { value: "DuctTape-3ca16e2f-bdcd-4da2-8631-dcef342f40f1/DuctTape-3ca16e2f-bdcd-4da2-8631-dcef342f40f1-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.2 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "DuctTape-3ca16e2f-bdcd-4da2-8631-dcef342f40f1/DuctTape-3ca16e2f-bdcd-4da2-8631-dcef342f40f1-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "DuctTape-d0262945-853c-4481-9cbd-88586bed93cb/DuctTape-d0262945-853c-4481-9cbd-88586bed93cb-v10.0-vertex.glsl",
	        fragmentShader: "DuctTape-d0262945-853c-4481-9cbd-88586bed93cb/DuctTape-d0262945-853c-4481-9cbd-88586bed93cb-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Electricity" : {
	        uniforms: {
	            u_time: { value: new Vector4() },
	            u_DisplacementIntensity: { value: 2.0 },
	            u_EmissionGain: { value: 0.2 }
	        },
	        vertexShader: "Electricity-f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51/Electricity-f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51-v10.0-vertex.glsl",
	        fragmentShader: "Electricity-f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51/Electricity-f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Embers" : {
	        uniforms: {
	            u_time: { value: new Vector4() },
	            u_ScrollRate: { value: 0.6 },
	            u_ScrollDistance: { value: new Vector3(-0.2, 0.6, 0) },
	            u_ScrollJitterIntensity: { value: 0.03 },
	            u_ScrollJitterFrequency: { value: 5 },
	            u_TintColor: { value: new Vector4(1, 1, 1, 1) },
	            u_MainTex: { value: "Embers-02ffb866-7fb2-4d15-b761-1012cefb1360/Embers-02ffb866-7fb2-4d15-b761-1012cefb1360-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "Embers-02ffb866-7fb2-4d15-b761-1012cefb1360/Embers-02ffb866-7fb2-4d15-b761-1012cefb1360-v10.0-vertex.glsl",
	        fragmentShader: "Embers-02ffb866-7fb2-4d15-b761-1012cefb1360/Embers-02ffb866-7fb2-4d15-b761-1012cefb1360-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "EnvironmentDiffuse" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.1500 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "EnvironmentDiffuse-0ad58bbd-42bc-484e-ad9a-b61036ff4ce7/EnvironmentDiffuse-0ad58bbd-42bc-484e-ad9a-b61036ff4ce7-v1.0-vertex.glsl",
	        fragmentShader: "EnvironmentDiffuse-0ad58bbd-42bc-484e-ad9a-b61036ff4ce7/EnvironmentDiffuse-0ad58bbd-42bc-484e-ad9a-b61036ff4ce7-v1.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "EnvironmentDiffuseLightMap" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.1500 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "EnvironmentDiffuseLightMap-d01d9d6c-9a61-4aba-8146-5891fafb013b/EnvironmentDiffuseLightMap-d01d9d6c-9a61-4aba-8146-5891fafb013b-v1.0-vertex.glsl",
	        fragmentShader: "EnvironmentDiffuseLightMap-d01d9d6c-9a61-4aba-8146-5891fafb013b/EnvironmentDiffuseLightMap-d01d9d6c-9a61-4aba-8146-5891fafb013b-v1.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Fire" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Fire-cb92b597-94ca-4255-b017-0e3f42f12f9e/Fire-cb92b597-94ca-4255-b017-0e3f42f12f9e-v10.0-MainTex.png" },
	            u_time: { value: new Vector4() },
	            u_EmissionGain: { value: 0.5 }
	        },
	        vertexShader: "Fire-cb92b597-94ca-4255-b017-0e3f42f12f9e/Fire-cb92b597-94ca-4255-b017-0e3f42f12f9e-v10.0-vertex.glsl",
	        fragmentShader: "Fire-cb92b597-94ca-4255-b017-0e3f42f12f9e/Fire-cb92b597-94ca-4255-b017-0e3f42f12f9e-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201
	    },
	    "Flat" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "Flat-2d35bcf0-e4d8-452c-97b1-3311be063130/Flat-2d35bcf0-e4d8-452c-97b1-3311be063130-v10.0-vertex.glsl",
	        fragmentShader: "Flat-2d35bcf0-e4d8-452c-97b1-3311be063130/Flat-2d35bcf0-e4d8-452c-97b1-3311be063130-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201,
	    },
	    "Highlighter" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Highlighter-cf019139-d41c-4eb0-a1d0-5cf54b0a42f3/Highlighter-cf019139-d41c-4eb0-a1d0-5cf54b0a42f3-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.12 }
	        },
	        vertexShader: "Highlighter-cf019139-d41c-4eb0-a1d0-5cf54b0a42f3/Highlighter-cf019139-d41c-4eb0-a1d0-5cf54b0a42f3-v10.0-vertex.glsl",
	        fragmentShader: "Highlighter-cf019139-d41c-4eb0-a1d0-5cf54b0a42f3/Highlighter-cf019139-d41c-4eb0-a1d0-5cf54b0a42f3-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Hypercolor" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Shininess: { value: 0.5 },
	            u_SpecColor: { value: new Vector3(0.2745098, 0.2745098, 0.2745098) },
	            u_MainTex: { value: "Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c/Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c-v10.0-MainTex.png" },
	            u_time: { value: new Vector4() },
	            u_Cutoff: { value: 0.5 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c/Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c/Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c-v10.0-vertex.glsl",
	        fragmentShader: "Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c/Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "HyperGrid" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_TintColor: { value: new Vector4(1, 1, 1, 1) },
	            u_MainTex: { value: "HyperGrid-6a1cf9f9-032c-45ec-9b6e-a6680bee32e9/HyperGrid-6a1cf9f9-032c-45ec-9b6e-a6680bee32e9-v10.0-MainTex.png" }
	        },
	        vertexShader: "HyperGrid-6a1cf9f9-032c-45ec-9b6e-a6680bee32e9/HyperGrid-6a1cf9f9-032c-45ec-9b6e-a6680bee32e9-v10.0-vertex.glsl",
	        fragmentShader: "HyperGrid-6a1cf9f9-032c-45ec-9b6e-a6680bee32e9/HyperGrid-6a1cf9f9-032c-45ec-9b6e-a6680bee32e9-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Icing" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.2352941, 0.2352941, 0.2352941) },
	            u_Shininess: { value: 0.1500 },
	            u_Cutoff: { value: 0.5 },
	            u_MainTex: { value: "Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37/Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37-v10.0-BumpMap.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37/Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37/Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37-v10.0-vertex.glsl",
	        fragmentShader: "Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37/Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Ink" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.2352941, 0.2352941, 0.2352941) },
	            u_Shininess: { value: 0.4 },
	            u_Cutoff: { value: 0.5 },
	            u_MainTex: { value: "Ink-c0012095-3ffd-4040-8ee1-fc180d346eaa/Ink-c0012095-3ffd-4040-8ee1-fc180d346eaa-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "Ink-c0012095-3ffd-4040-8ee1-fc180d346eaa/Ink-c0012095-3ffd-4040-8ee1-fc180d346eaa-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "Ink-f5c336cf-5108-4b40-ade9-c687504385ab/Ink-f5c336cf-5108-4b40-ade9-c687504385ab-v10.0-vertex.glsl",
	        fragmentShader: "Ink-f5c336cf-5108-4b40-ade9-c687504385ab/Ink-f5c336cf-5108-4b40-ade9-c687504385ab-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Leaves" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.395 },
	            u_Cutoff: { value: 0.5 },
	            u_MainTex: { value: "Leaves-ea19de07-d0c0-4484-9198-18489a3c1487/Leaves-ea19de07-d0c0-4484-9198-18489a3c1487-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "Leaves-ea19de07-d0c0-4484-9198-18489a3c1487/Leaves-ea19de07-d0c0-4484-9198-18489a3c1487-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "Leaves-ea19de07-d0c0-4484-9198-18489a3c1487/Leaves-ea19de07-d0c0-4484-9198-18489a3c1487-v10.0-vertex.glsl",
	        fragmentShader: "Leaves-ea19de07-d0c0-4484-9198-18489a3c1487/Leaves-ea19de07-d0c0-4484-9198-18489a3c1487-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Light" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Light-2241cd32-8ba2-48a5-9ee7-2caef7e9ed62/Light-2241cd32-8ba2-48a5-9ee7-2caef7e9ed62-v10.0-MainTex.png" },
	            u_EmissionGain: { value: 0.45 },
	        },
	        vertexShader: "Light-2241cd32-8ba2-48a5-9ee7-2caef7e9ed62/Light-2241cd32-8ba2-48a5-9ee7-2caef7e9ed62-v10.0-vertex.glsl",
	        fragmentShader: "Light-2241cd32-8ba2-48a5-9ee7-2caef7e9ed62/Light-2241cd32-8ba2-48a5-9ee7-2caef7e9ed62-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201,
	    },
	    "LightWire" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Shininess: { value: 0.81 },
	            u_SpecColor: { value: new Vector3(0.3455882, 0.3455882, 0.3455882) },
	            u_time: { value: new Vector4() },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_MainTex: { value: "LightWire-4391aaaa-df81-4396-9e33-31e4e4930b27/LightWire-4391aaaa-df81-4396-9e33-31e4e4930b27-v10.0-MainTex.png"}
	        },
	        vertexShader: "LightWire-4391aaaa-df81-4396-9e33-31e4e4930b27/LightWire-4391aaaa-df81-4396-9e33-31e4e4930b27-v10.0-vertex.glsl",
	        fragmentShader: "LightWire-4391aaaa-df81-4396-9e33-31e4e4930b27/LightWire-4391aaaa-df81-4396-9e33-31e4e4930b27-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Lofted" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "Lofted-d381e0f5-3def-4a0d-8853-31e9200bcbda/Lofted-d381e0f5-3def-4a0d-8853-31e9200bcbda-v10.0-vertex.glsl",
	        fragmentShader: "Lofted-d381e0f5-3def-4a0d-8853-31e9200bcbda/Lofted-d381e0f5-3def-4a0d-8853-31e9200bcbda-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Marker" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Marker-429ed64a-4e97-4466-84d3-145a861ef684/Marker-429ed64a-4e97-4466-84d3-145a861ef684-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.067 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "Marker-429ed64a-4e97-4466-84d3-145a861ef684/Marker-429ed64a-4e97-4466-84d3-145a861ef684-v10.0-vertex.glsl",
	        fragmentShader: "Marker-429ed64a-4e97-4466-84d3-145a861ef684/Marker-429ed64a-4e97-4466-84d3-145a861ef684-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0,
	        
	    },
	    "MatteHull" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "MatteHull-79348357-432d-4746-8e29-0e25c112e3aa/MatteHull-79348357-432d-4746-8e29-0e25c112e3aa-v10.0-vertex.glsl",
	        fragmentShader: "MatteHull-79348357-432d-4746-8e29-0e25c112e3aa/MatteHull-79348357-432d-4746-8e29-0e25c112e3aa-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0,
	    },
	    "NeonPulse" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_time: { value: new Vector4() },
	            u_EmissionGain: { value: 0.5 },
	        },
	        vertexShader: "NeonPulse-b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6/NeonPulse-b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6-v10.0-vertex.glsl",
	        fragmentShader: "NeonPulse-b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6/NeonPulse-b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201,
	    },
	    "OilPaint": {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.2352941, 0.2352941, 0.2352941) },
	            u_Shininess: { value: 0.4 },
	            u_Cutoff: { value: 0.5 },
	            u_MainTex: { value: "OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699/OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699/OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0020, 0.0020, 512, 512) },
	        },
	        vertexShader: "OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699/OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699-v10.0-vertex.glsl",
	        fragmentShader: "OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699/OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Paper" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.145 },
	            u_Cutoff: { value: 0.16 },
	            u_MainTex: { value: "Paper-759f1ebd-20cd-4720-8d41-234e0da63716/Paper-759f1ebd-20cd-4720-8d41-234e0da63716-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "Paper-759f1ebd-20cd-4720-8d41-234e0da63716/Paper-759f1ebd-20cd-4720-8d41-234e0da63716-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "Paper-f1114e2e-eb8d-4fde-915a-6e653b54e9f5/Paper-f1114e2e-eb8d-4fde-915a-6e653b54e9f5-v10.0-vertex.glsl",
	        fragmentShader: "Paper-f1114e2e-eb8d-4fde-915a-6e653b54e9f5/Paper-f1114e2e-eb8d-4fde-915a-6e653b54e9f5-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "PbrTemplate" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.1500 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "PbrTemplate-f86a096c-2f4f-4f9d-ae19-81b99f2944e0/PbrTemplate-f86a096c-2f4f-4f9d-ae19-81b99f2944e0-v1.0-vertex.glsl",
	        fragmentShader: "PbrTemplate-f86a096c-2f4f-4f9d-ae19-81b99f2944e0/PbrTemplate-f86a096c-2f4f-4f9d-ae19-81b99f2944e0-v1.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "PbrTransparentTemplate" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.1500 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "PbrTransparentTemplate-19826f62-42ac-4a9e-8b77-4231fbd0cfbf/PbrTransparentTemplate-19826f62-42ac-4a9e-8b77-4231fbd0cfbf-v1.0-vertex.glsl",
	        fragmentShader: "PbrTransparentTemplate-19826f62-42ac-4a9e-8b77-4231fbd0cfbf/PbrTransparentTemplate-19826f62-42ac-4a9e-8b77-4231fbd0cfbf-v1.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Petal" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.01 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "Petal-e0abbc80-0f80-e854-4970-8924a0863dcc/Petal-e0abbc80-0f80-e854-4970-8924a0863dcc-v10.0-vertex.glsl",
	        fragmentShader: "Petal-e0abbc80-0f80-e854-4970-8924a0863dcc/Petal-e0abbc80-0f80-e854-4970-8924a0863dcc-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    // How did an experimental brush end up here?
	    "Plasma" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Plasma-c33714d1-b2f9-412e-bd50-1884c9d46336/Plasma-c33714d1-b2f9-412e-bd50-1884c9d46336-v10.0-MainTex.png" },
	            u_time: { value: new Vector4() }
	        },
	        vertexShader: "Plasma-c33714d1-b2f9-412e-bd50-1884c9d46336/Plasma-c33714d1-b2f9-412e-bd50-1884c9d46336-v10.0-vertex.glsl",
	        fragmentShader: "Plasma-c33714d1-b2f9-412e-bd50-1884c9d46336/Plasma-c33714d1-b2f9-412e-bd50-1884c9d46336-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Rainbow" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_time: { value: new Vector4() },
	            u_EmissionGain: { value: 0.65 }
	        },
	        vertexShader: "Rainbow-ad1ad437-76e2-450d-a23a-e17f8310b960/Rainbow-ad1ad437-76e2-450d-a23a-e17f8310b960-v10.0-vertex.glsl",
	        fragmentShader: "Rainbow-ad1ad437-76e2-450d-a23a-e17f8310b960/Rainbow-ad1ad437-76e2-450d-a23a-e17f8310b960-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201,
	    },
	    "ShinyHull" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.1985294, 0.1985294, 0.1985294) },
	            u_Shininess: { value: 0.7430 },
	            u_Cutoff: { value: 0.5 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "ShinyHull-faaa4d44-fcfb-4177-96be-753ac0421ba3/ShinyHull-faaa4d44-fcfb-4177-96be-753ac0421ba3-v10.0-vertex.glsl",
	        fragmentShader: "ShinyHull-faaa4d44-fcfb-4177-96be-753ac0421ba3/ShinyHull-faaa4d44-fcfb-4177-96be-753ac0421ba3-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Smoke": {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_TintColor: { value: new Vector4(1, 1, 1, 1) },
	            u_MainTex: { value: "Smoke-70d79cca-b159-4f35-990c-f02193947fe8/Smoke-70d79cca-b159-4f35-990c-f02193947fe8-v10.0-MainTex.png" }
	        },
	        vertexShader: "Smoke-70d79cca-b159-4f35-990c-f02193947fe8/Smoke-70d79cca-b159-4f35-990c-f02193947fe8-v10.0-vertex.glsl",
	        fragmentShader: "Smoke-70d79cca-b159-4f35-990c-f02193947fe8/Smoke-70d79cca-b159-4f35-990c-f02193947fe8-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Snow" : {
	        uniforms: {
	            u_time: { value: new Vector4() },
	            u_ScrollRate: { value: 0.2 },
	            u_ScrollDistance: { value: new Vector3(0, -0.3, 0) },
	            u_ScrollJitterIntensity: { value: 0.01 },
	            u_ScrollJitterFrequency: { value: 12 },
	            u_TintColor: { value: new Vector4(1, 1, 1, 1) },
	            u_MainTex: { value: "Snow-d902ed8b-d0d1-476c-a8de-878a79e3a34c/Snow-d902ed8b-d0d1-476c-a8de-878a79e3a34c-v10.0-MainTex.png" },
	        },
	        vertexShader: "Snow-d902ed8b-d0d1-476c-a8de-878a79e3a34c/Snow-d902ed8b-d0d1-476c-a8de-878a79e3a34c-v10.0-vertex.glsl",
	        fragmentShader: "Snow-d902ed8b-d0d1-476c-a8de-878a79e3a34c/Snow-d902ed8b-d0d1-476c-a8de-878a79e3a34c-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "SoftHighlighter" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "SoftHighlighter-accb32f5-4509-454f-93f8-1df3fd31df1b/SoftHighlighter-accb32f5-4509-454f-93f8-1df3fd31df1b-v10.0-MainTex.png" },
	        },
	        vertexShader: "SoftHighlighter-accb32f5-4509-454f-93f8-1df3fd31df1b/SoftHighlighter-accb32f5-4509-454f-93f8-1df3fd31df1b-v10.0-vertex.glsl",
	        fragmentShader: "SoftHighlighter-accb32f5-4509-454f-93f8-1df3fd31df1b/SoftHighlighter-accb32f5-4509-454f-93f8-1df3fd31df1b-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201,
	    },
	    "Spikes" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "Spikes-cf7f0059-7aeb-53a4-2b67-c83d863a9ffa/Spikes-cf7f0059-7aeb-53a4-2b67-c83d863a9ffa-v10.0-vertex.glsl",
	        fragmentShader: "Spikes-cf7f0059-7aeb-53a4-2b67-c83d863a9ffa/Spikes-cf7f0059-7aeb-53a4-2b67-c83d863a9ffa-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Splatter" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_MainTex: { value: "Splatter-7a1c8107-50c5-4b70-9a39-421576d6617e/Splatter-7a1c8107-50c5-4b70-9a39-421576d6617e-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.2 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "Splatter-7a1c8107-50c5-4b70-9a39-421576d6617e/Splatter-7a1c8107-50c5-4b70-9a39-421576d6617e-v10.0-vertex.glsl",
	        fragmentShader: "Splatter-7a1c8107-50c5-4b70-9a39-421576d6617e/Splatter-7a1c8107-50c5-4b70-9a39-421576d6617e-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Stars" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_time: { value: new Vector4() },
	            u_SparkleRate: { value: 5.3 },
	            u_MainTex: { value: "Stars-0eb4db27-3f82-408d-b5a1-19ebd7d5b711/Stars-0eb4db27-3f82-408d-b5a1-19ebd7d5b711-v10.0-MainTex.png" },
	        },
	        vertexShader: "Stars-0eb4db27-3f82-408d-b5a1-19ebd7d5b711/Stars-0eb4db27-3f82-408d-b5a1-19ebd7d5b711-v10.0-vertex.glsl",
	        fragmentShader: "Stars-0eb4db27-3f82-408d-b5a1-19ebd7d5b711/Stars-0eb4db27-3f82-408d-b5a1-19ebd7d5b711-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Streamers" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Streamers-44bb800a-fbc3-4592-8426-94ecb05ddec3/Streamers-44bb800a-fbc3-4592-8426-94ecb05ddec3-v10.0-MainTex.png" },
	            u_EmissionGain: { value: 0.4 },
	            u_time: { value: new Vector4() },
	        },
	        vertexShader: "Streamers-44bb800a-fbc3-4592-8426-94ecb05ddec3/Streamers-44bb800a-fbc3-4592-8426-94ecb05ddec3-v10.0-vertex.glsl",
	        fragmentShader: "Streamers-44bb800a-fbc3-4592-8426-94ecb05ddec3/Streamers-44bb800a-fbc3-4592-8426-94ecb05ddec3-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Taffy" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Taffy-0077f88c-d93a-42f3-b59b-b31c50cdb414/Taffy-0077f88c-d93a-42f3-b59b-b31c50cdb414-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "Taffy-0077f88c-d93a-42f3-b59b-b31c50cdb414/Taffy-0077f88c-d93a-42f3-b59b-b31c50cdb414-v10.0-vertex.glsl",
	        fragmentShader: "Taffy-0077f88c-d93a-42f3-b59b-b31c50cdb414/Taffy-0077f88c-d93a-42f3-b59b-b31c50cdb414-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "TaperedFlat" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_MainTex: { value: "TaperedFlat-b468c1fb-f254-41ed-8ec9-57030bc5660c/TaperedFlat-b468c1fb-f254-41ed-8ec9-57030bc5660c-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.067 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "TaperedFlat-b468c1fb-f254-41ed-8ec9-57030bc5660c/TaperedFlat-b468c1fb-f254-41ed-8ec9-57030bc5660c-v10.0-vertex.glsl",
	        fragmentShader: "TaperedFlat-b468c1fb-f254-41ed-8ec9-57030bc5660c/TaperedFlat-b468c1fb-f254-41ed-8ec9-57030bc5660c-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "TaperedMarker" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "TaperedMarker-d90c6ad8-af0f-4b54-b422-e0f92abe1b3c/TaperedMarker-d90c6ad8-af0f-4b54-b422-e0f92abe1b3c-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "TaperedMarker-d90c6ad8-af0f-4b54-b422-e0f92abe1b3c/TaperedMarker-d90c6ad8-af0f-4b54-b422-e0f92abe1b3c-v10.0-vertex.glsl",
	        fragmentShader: "TaperedMarker-d90c6ad8-af0f-4b54-b422-e0f92abe1b3c/TaperedMarker-d90c6ad8-af0f-4b54-b422-e0f92abe1b3c-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "TaperedMarker_Flat" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.1500 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_MainTex: { value: "TaperedMarker_Flat-1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0/TaperedMarker_Flat-1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "TaperedMarker_Flat-1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0/TaperedMarker_Flat-1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0-v10.0-vertex.glsl",
	        fragmentShader: "TaperedMarker_Flat-1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0/TaperedMarker_Flat-1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "ThickPaint" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.2352941, 0.2352941, 0.2352941) },
	            u_Shininess: { value: 0.4 },
	            u_Cutoff: { value: 0.5 },
	            u_MainTex: { value: "ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f/ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f/ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f/ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f-v10.0-vertex.glsl",
	        fragmentShader: "ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f/ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Toon" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "Toon-4391385a-df73-4396-9e33-31e4e4930b27/Toon-4391385a-df73-4396-9e33-31e4e4930b27-v10.0-vertex.glsl",
	        fragmentShader: "Toon-4391385a-df73-4396-9e33-31e4e4930b27/Toon-4391385a-df73-4396-9e33-31e4e4930b27-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0,
	    },
	    "UnlitHull" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "UnlitHull-a8fea537-da7c-4d4b-817f-24f074725d6d/UnlitHull-a8fea537-da7c-4d4b-817f-24f074725d6d-v10.0-vertex.glsl",
	        fragmentShader: "UnlitHull-a8fea537-da7c-4d4b-817f-24f074725d6d/UnlitHull-a8fea537-da7c-4d4b-817f-24f074725d6d-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0,
	    },
	    "VelvetInk" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "VelvetInk-d229d335-c334-495a-a801-660ac8a87360/VelvetInk-d229d335-c334-495a-a801-660ac8a87360-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "VelvetInk-d229d335-c334-495a-a801-660ac8a87360/VelvetInk-d229d335-c334-495a-a801-660ac8a87360-v10.0-vertex.glsl",
	        fragmentShader: "VelvetInk-d229d335-c334-495a-a801-660ac8a87360/VelvetInk-d229d335-c334-495a-a801-660ac8a87360-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Waveform" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_EmissionGain: { value: 0.5178571 },
	            u_time: { value: new Vector4() },
	            u_MainTex: { value: "Waveform-10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab/Waveform-10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab-v10.0-MainTex.png" },
	        },
	        vertexShader: "Waveform-10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab/Waveform-10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab-v10.0-vertex.glsl",
	        fragmentShader: "Waveform-10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab/Waveform-10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "WetPaint" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.1397059, 0.1397059, 0.1397059) },
	            u_Shininess: { value: 0.85 },
	            u_Cutoff: { value: 0.3 },
	            u_MainTex: { value: "WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3/WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3/WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3/WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3-v10.0-vertex.glsl",
	        fragmentShader: "WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3/WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "WigglyGraphite" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_time: { value: new Vector4() },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Cutoff: { value: 0.5 },
	            u_MainTex: { value: "WigglyGraphite-5347acf0-a8e2-47b6-8346-30c70719d763/WigglyGraphite-5347acf0-a8e2-47b6-8346-30c70719d763-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "WigglyGraphite-5347acf0-a8e2-47b6-8346-30c70719d763/WigglyGraphite-5347acf0-a8e2-47b6-8346-30c70719d763-v10.0-vertex.glsl",
	        fragmentShader: "WigglyGraphite-5347acf0-a8e2-47b6-8346-30c70719d763/WigglyGraphite-5347acf0-a8e2-47b6-8346-30c70719d763-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Wire" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "Wire-4391385a-cf83-4396-9e33-31e4e4930b27/Wire-4391385a-cf83-4396-9e33-31e4e4930b27-v10.0-vertex.glsl",
	        fragmentShader: "Wire-4391385a-cf83-4396-9e33-31e4e4930b27/Wire-4391385a-cf83-4396-9e33-31e4e4930b27-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0,
	    },
	};

	// Copyright 2021-2022 Icosa Gallery

	class GLTFGoogleTiltBrushMaterialExtension {

	    constructor(parser, brushPath) {
	        this.name = "GOOGLE_tilt_brush_material";
	        this.parser = parser;
	        this.brushPath = brushPath;

	        // Quick repair of path if required
	        if (this.brushPath.slice(this.brushPath.length - 1) !== "/") {
	            this.brushPath += "/";
	        }

	        this.tiltShaderLoader = new TiltShaderLoader$1(parser.options.manager);
	        this.tiltShaderLoader.setPath(brushPath);
	        this.clock = new Clock();
	    }

	    beforeRoot() {
	        const parser = this.parser;
	        const json = parser.json;
	        if (!json.extensionsUsed || !json.extensionsUsed.includes(this.name)) {
	            return null;
	        }

	        json.materials.forEach(material => {
	            const extensionsDef = material.extensions;

	            if (!extensionsDef || !extensionsDef[this.name]) {
	                return;
	            }

	            const guid = material.extensions.GOOGLE_tilt_brush_material.guid;
	            const materialParams = this.tiltShaderLoader.lookupMaterial(guid);

	            //MainTex
	            if(material?.pbrMetallicRoughness?.baseColorTexture) {
	                const mainTex = json.images[material.pbrMetallicRoughness.baseColorTexture.index];
	                mainTex.uri = this.brushPath + materialParams.uniforms.u_MainTex.value;
	            }

	            //BumpMap
	            if(material?.normalTexture) {
	                const bumpMap = json.images[material.normalTexture.index];
	                bumpMap.uri = this.brushPath + materialParams.uniforms.u_BumpMap.value;
	            }
	        });
	    }

	    afterRoot(glTF) {
	        const parser = this.parser;
	        const json = parser.json;

	        if (!json.extensionsUsed || !json.extensionsUsed.includes(this.name)) {
	            return null;
	        }

	        const shaderResolves = [];

	        //const extensionDef = json.exensions[this.name];
	        for(const scene of glTF.scenes) {
	            scene.traverse(async object => {
	                const association = parser.associations.get(object);

	                if (association === undefined || association.meshes === undefined) {
	                    return;
	                }

	                const mesh = json.meshes[association.meshes];
	                mesh.primitives.forEach((prim) => {
	                    if(!prim.material) {
	                        return;
	                    }

	                    const mat = json.materials[prim.material];
	                    if (!mat.extensions || !mat.extensions[this.name]) {
	                        return;
	                    }
	                    
	                    const guid = mat.extensions.GOOGLE_tilt_brush_material.guid;
	                    
	                    shaderResolves.push(this.replaceMaterial(object, guid));
	                });
	            });
	        }

	        return Promise.all(shaderResolves);
	    }

	    async replaceMaterial(mesh, guid) {
	        let shader;

	        switch(guid) {
	            case "0e87b49c-6546-3a34-3a44-8a556d7d6c3e":
	                mesh.geometry.name = "geometry_BlocksBasic";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                //mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("BlocksBasic");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_BlocksBasic";
	                break;
	            case "232998f8-d357-47a2-993a-53415df9be10":
	                mesh.geometry.name = "geometry_BlocksGem";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                //mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("BlocksGem");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_BlocksGem";
	                break;
	            case "3d813d82-5839-4450-8ddc-8e889ecd96c7":
	                mesh.geometry.name = "geometry_BlocksGlass";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                //mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("BlocksGlass");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_BlocksGlass";
	                break;

	            case "89d104cd-d012-426b-b5b3-bbaee63ac43c":
	                mesh.geometry.name = "geometry_Bubbles";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("_tb_unity_normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("_tb_unity_texcoord_1"));
	                shader = await this.tiltShaderLoader.loadAsync("Bubbles");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Bubbles";
	                break;

	            case "700f3aa8-9a7c-2384-8b8a-ea028905dd8c":
	                mesh.geometry.name = "geometry_CelVinyl";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("CelVinyl");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_CelVinyl";
	                break;

	            case "0f0ff7b2-a677-45eb-a7d6-0cd7206f4816":
	                mesh.geometry.name = "geometry_ChromaticWave";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("ChromaticWave");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_ChromaticWave";
	                break;

	            case "1161af82-50cf-47db-9706-0c3576d43c43":
	            case "79168f10-6961-464a-8be1-57ed364c5600":
	                mesh.geometry.name = "geometry_CoarseBristles";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("CoarseBristles");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_CoarseBristles";
	                break;

	            case "1caa6d7d-f015-3f54-3a4b-8b5354d39f81":
	                mesh.geometry.name = "geometry_Comet";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Comet");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Comet";
	                break;

	            case "c8313697-2563-47fc-832e-290f4c04b901":
	                mesh.geometry.name = "geometry_DiamondHull";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("DiamondHull");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_DiamondHull";
	                break;

	            case "4391aaaa-df73-4396-9e33-31e4e4930b27":
	                mesh.geometry.name = "geometry_Disco";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Disco");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Disco";
	                break;

	            case "d1d991f2-e7a0-4cf1-b328-f57e915e6260":
	                mesh.geometry.name = "geometry_DotMarker";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("DotMarker");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_DotMarker";
	                break;

	            case "6a1cf9f9-032c-45ec-9b1d-a6680bee30f7":
	                mesh.geometry.name = "geometry_Dots";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("_tb_unity_normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("_tb_unity_texcoord_1"));
	                shader = await this.tiltShaderLoader.loadAsync("Dots");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Dots";
	                break;

	            case "0d3889f3-3ede-470c-8af4-f44813306126":
	                mesh.geometry.name = "geometry_DoubleTaperedFlat";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("DoubleTaperedFlat");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_DoubleTaperedFlat";
	                break;

	            case "0d3889f3-3ede-470c-8af4-de4813306126":
	                mesh.geometry.name = "geometry_DoubleTaperedMarker";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("DoubleTaperedMarker");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_DoubleTaperedMarker";
	                break;

	            case "d0262945-853c-4481-9cbd-88586bed93cb":
	            case "3ca16e2f-bdcd-4da2-8631-dcef342f40f1":
	                mesh.geometry.name = "geometry_DuctTape";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("DuctTape");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_DuctTape";
	                break;

	            case "f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51":
	                mesh.geometry.name = "geometry_Electricity";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("_tb_unity_texcoord_1"));
	                shader = await this.tiltShaderLoader.loadAsync("Electricity");
	                mesh.material = shader;
	                mesh.material.name = "material_Electricity";
	                break;

	            case "02ffb866-7fb2-4d15-b761-1012cefb1360":
	                mesh.geometry.name = "geometry_Embers";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("_tb_unity_normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("_tb_unity_texcoord_1"));
	                shader = await this.tiltShaderLoader.loadAsync("Embers");
	                mesh.material = shader;
	                mesh.material.name = "material_Embers";
	                break;

	            case "0ad58bbd-42bc-484e-ad9a-b61036ff4ce7":
	                mesh.geometry.name = "geometry_EnvironmentDiffuse";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("EnvironmentDiffuse");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_EnvironmentDiffuse";
	                break;

	            case "d01d9d6c-9a61-4aba-8146-5891fafb013b":
	                mesh.geometry.name = "geometry_EnvironmentDiffuseLightMap";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("EnvironmentDiffuseLightMap");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_EnvironmentDiffuseLightMap";
	                break;

	            case "cb92b597-94ca-4255-b017-0e3f42f12f9e":
	                mesh.geometry.name = "geometry_Fire";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Fire");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Fire";
	                break;

	            case "2d35bcf0-e4d8-452c-97b1-3311be063130":
	            case "280c0a7a-aad8-416c-a7d2-df63d129ca70":
	            case "55303bc4-c749-4a72-98d9-d23e68e76e18":
	                mesh.geometry.name = "geometry_Flat";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Flat");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Flat";
	                break;

	            case "cf019139-d41c-4eb0-a1d0-5cf54b0a42f3":
	                mesh.geometry.name = "geometry_Highlighter";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Highlighter");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Highlighter";
	                break;

	            case "dce872c2-7b49-4684-b59b-c45387949c5c":
	            case "e8ef32b1-baa8-460a-9c2c-9cf8506794f5":
	                mesh.geometry.name = "geometry_Hypercolor";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Hypercolor");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Hypercolor";
	                break;

	            case "6a1cf9f9-032c-45ec-9b6e-a6680bee32e9":
	                mesh.geometry.name = "geometry_HyperGrid";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("_tb_unity_texcoord_1"));
	                shader = await this.tiltShaderLoader.loadAsync("HyperGrid");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_HyperGrid";
	                break;

	            case "2f212815-f4d3-c1a4-681a-feeaf9c6dc37":
	                mesh.geometry.name = "geometry_Icing";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));

	                shader = await this.tiltShaderLoader.loadAsync("Icing");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Icing";
	                break;

	            case "f5c336cf-5108-4b40-ade9-c687504385ab":
	            case "c0012095-3ffd-4040-8ee1-fc180d346eaa":
	                mesh.geometry.name = "geometry_Ink";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Ink");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Ink";
	                break;

	            case "4a76a27a-44d8-4bfe-9a8c-713749a499b0":
	            case "ea19de07-d0c0-4484-9198-18489a3c1487":
	                mesh.geometry.name = "geometry_Leaves";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Leaves");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Leaves";
	                break;

	            case "2241cd32-8ba2-48a5-9ee7-2caef7e9ed62":
	                mesh.geometry.name = "geometry_Light";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Light");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Light";
	                break;

	            case "4391aaaa-df81-4396-9e33-31e4e4930b27":
	                mesh.geometry.name = "geometry_LightWire";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("LightWire");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_LightWire";
	                break;

	            case "d381e0f5-3def-4a0d-8853-31e9200bcbda":
	                mesh.geometry.name = "geometry_Lofted";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Lofted");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Lofted";
	                break;

	            case "429ed64a-4e97-4466-84d3-145a861ef684":
	                mesh.geometry.name = "geometry_Marker";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Marker");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Marker";
	                break;

	            case "79348357-432d-4746-8e29-0e25c112e3aa":
	                mesh.geometry.name = "geometry_MatteHull";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                shader = await this.tiltShaderLoader.loadAsync("MatteHull");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_MatteHull";
	                break;

	            case "b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6":
	                mesh.geometry.name = "geometry_NeonPulse";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("NeonPulse");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_NeonPulse";
	                break;

	            case "f72ec0e7-a844-4e38-82e3-140c44772699":
	            case "c515dad7-4393-4681-81ad-162ef052241b":
	                mesh.geometry.name = "geometry_OilPaint";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("OilPaint");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_OilPaint";
	                break;

	            case "f1114e2e-eb8d-4fde-915a-6e653b54e9f5":
	            case "759f1ebd-20cd-4720-8d41-234e0da63716":
	                mesh.geometry.name = "geometry_Paper";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Paper");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Paper";
	                break;

	            case "f86a096c-2f4f-4f9d-ae19-81b99f2944e0":
	                mesh.geometry.name = "geometry_PbrTemplate";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("PbrTemplate");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_PbrTemplate";
	                break;

	            case "19826f62-42ac-4a9e-8b77-4231fbd0cfbf":
	                mesh.geometry.name = "geometry_PbrTransparentTemplate";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("PbrTransparentTemplate");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_PbrTransparentTemplate";
	                break;

	            case "e0abbc80-0f80-e854-4970-8924a0863dcc":
	                mesh.geometry.name = "geometry_Petal";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Petal");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Petal";
	                break;

	            case "c33714d1-b2f9-412e-bd50-1884c9d46336":
	                mesh.geometry.name = "geometry_Plasma";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Plasma");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Plasma";
	                break;

	            case "ad1ad437-76e2-450d-a23a-e17f8310b960":
	                mesh.geometry.name = "geometry_Rainbow";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Rainbow");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Rainbow";
	                break;

	            case "faaa4d44-fcfb-4177-96be-753ac0421ba3":
	                mesh.geometry.name = "geometry_ShinyHull";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("ShinyHull");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_ShinyHull";
	                break;

	            case "70d79cca-b159-4f35-990c-f02193947fe8":
	                mesh.geometry.name = "geometry_Smoke";
	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("_tb_unity_normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("_tb_unity_texcoord_1"));
	                shader = await this.tiltShaderLoader.loadAsync("Smoke");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Smoke";
	                break;

	            case "d902ed8b-d0d1-476c-a8de-878a79e3a34c":
	                mesh.geometry.name = "geometry_Snow";
	                
	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("_tb_unity_normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("_tb_unity_texcoord_1"));
	                shader = await this.tiltShaderLoader.loadAsync("Snow");
	                mesh.material = shader;
	                mesh.material.name = "material_Snow";
	                break;

	            case "accb32f5-4509-454f-93f8-1df3fd31df1b":
	                mesh.geometry.name = "geometry_SoftHighlighter";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("SoftHighlighter");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_SoftHighlighter";
	                break;

	            case "cf7f0059-7aeb-53a4-2b67-c83d863a9ffa":
	                mesh.geometry.name = "geometry_Spikes";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Spikes");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Spikes";
	                break;

	            case "8dc4a70c-d558-4efd-a5ed-d4e860f40dc3":
	            case "7a1c8107-50c5-4b70-9a39-421576d6617e":
	                mesh.geometry.name = "geometry_Splatter";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Splatter");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Splatter";
	                break;

	            case "0eb4db27-3f82-408d-b5a1-19ebd7d5b711":
	                mesh.geometry.name = "geometry_Stars";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("_tb_unity_normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("_tb_unity_texcoord_1"));
	                shader = await this.tiltShaderLoader.loadAsync("Stars");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Stars";
	                break;

	            case "44bb800a-fbc3-4592-8426-94ecb05ddec3":
	                mesh.geometry.name = "geometry_Streamers";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Streamers");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Streamers";
	                break;

	            case "0077f88c-d93a-42f3-b59b-b31c50cdb414":
	                mesh.geometry.name = "geometry_Taffy";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Taffy");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Taffy";
	                break;

	            case "b468c1fb-f254-41ed-8ec9-57030bc5660c":
	            case "c8ccb53d-ae13-45ef-8afb-b730d81394eb":
	                mesh.geometry.name = "geometry_TaperedFlat";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("TaperedFlat");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_TaperedFlat";
	                break;

	            case "d90c6ad8-af0f-4b54-b422-e0f92abe1b3c":
	            case "1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0":
	                mesh.geometry.name = "geometry_TaperedMarker";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("TaperedMarker");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_TaperedMarker";
	                break;

	            case "75b32cf0-fdd6-4d89-a64b-e2a00b247b0f":
	            case "fdf0326a-c0d1-4fed-b101-9db0ff6d071f":
	                mesh.geometry.name = "geometry_ThickPaint";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("ThickPaint");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_ThickPaint";
	                break;

	            case "4391385a-df73-4396-9e33-31e4e4930b27":
	                mesh.geometry.name = "geometry_Toon";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                shader = await this.tiltShaderLoader.loadAsync("Toon");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Toon";
	                break;

	            case "a8fea537-da7c-4d4b-817f-24f074725d6d":
	                mesh.geometry.name = "geometry_UnlitHull";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                shader = await this.tiltShaderLoader.loadAsync("UnlitHull");
	                mesh.material = shader;
	                mesh.material.name = "material_UnlitHull";
	                break;

	            case "d229d335-c334-495a-a801-660ac8a87360":
	                mesh.geometry.name = "geometry_VelvetInk";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("VelvetInk");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_VelvetInk";
	                break;

	            case "10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab":
	                mesh.geometry.name = "geometry_Waveform";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("Waveform");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_Waveform";
	                break;

	            case "b67c0e81-ce6d-40a8-aeb0-ef036b081aa3":
	            case "dea67637-cd1a-27e4-c9b1-52f4bbcb84e5":
	                mesh.geometry.name = "geometry_WetPaint";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("WetPaint");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_WetPaint";
	                break;

	            case "5347acf0-a8e2-47b6-8346-30c70719d763":
	            case "e814fef1-97fd-7194-4a2f-50c2bb918be2":
	                mesh.geometry.name = "geometry_WigglyGraphite";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("_tb_unity_texcoord_0"));
	                shader = await this.tiltShaderLoader.loadAsync("WigglyGraphite");
	                shader.lights = true;
	                shader.uniformsNeedUpdate = true;
	                mesh.material = shader;
	                mesh.material.name = "material_WigglyGraphite";
	                break;

	            case "4391385a-cf83-4396-9e33-31e4e4930b27":
	                mesh.geometry.name = "geometry_Wire";

	                mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                shader = await this.tiltShaderLoader.loadAsync("Wire");
	                mesh.material = shader;
	                mesh.material.name = "material_Wire";
	                break;
	            default:
	                console.warn(`Could not find brush with guid ${guid}!`);
	        }
	        
	        mesh.onBeforeRender = (renderer, scene, camera, geometry, material, group) => {
	            if (material.uniforms["u_time"]) {
	                const elapsedTime = this.clock.getElapsedTime();
	                // _Time from https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html
	                const time = new Vector4(elapsedTime/20, elapsedTime, elapsedTime*2, elapsedTime*3);

	                material.uniforms["u_time"].value = time;
	            }

	            if (material.uniforms["cameraPosition"]) {
	                material.uniforms["cameraPosition"].value = camera.position;
	            }

	            if(material?.uniforms?.directionalLights?.value) {
	                // Main Light
	                if(material.uniforms.directionalLights.value[0]) {
	                    
	                    // Color
	                    if(material.uniforms.u_SceneLight_0_color) {
	                        const color = material.uniforms.directionalLights.value[0].color;
	                        material.uniforms.u_SceneLight_0_color.value = new Vector4(color.r, color.g, color.b, 1);
	                    }
	                }

	                // Shadow Light
	                if(material.uniforms.directionalLights.value[1]) {
	    
	                    // Color
	                    if(material.uniforms.u_SceneLight_1_color) {
	                        const color = material.uniforms.directionalLights.value[1].color;
	                        material.uniforms.u_SceneLight_1_color.value = new Vector4(color.r, color.g, color.b, 1);
	                    }
	                }
	            }

	            // Ambient Light
	            // if(material?.uniforms?.ambientLightColor?.value) {
	            //     if(material.uniforms.u_ambient_light_color) {
	            //         const colorArray = material.uniforms.ambientLightColor.value;
	            //         material.uniforms.u_ambient_light_color.value = new Vector4(colorArray[0], colorArray[1], colorArray[2], 1);
	            //     }
	            // }
	        };
	    }
	}

	/*!
	fflate - fast JavaScript compression/decompression
	<https://101arrowz.github.io/fflate>
	Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
	version 0.6.9
	*/
	var durl = function (c) { return URL.createObjectURL(new Blob([c], { type: 'text/javascript' })); };
	try {
	    URL.revokeObjectURL(durl(''));
	}
	catch (e) {
	    // We're in Deno or a very old browser
	    durl = function (c) { return 'data:application/javascript;charset=UTF-8,' + encodeURI(c); };
	}

	// aliases for shorter compressed code (most minifers don't do this)
	var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
	// fixed length extra bits
	var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
	// fixed distance extra bits
	// see fleb note
	var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
	// code length index map
	var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
	// get base, reverse index map from extra bits
	var freb = function (eb, start) {
	    var b = new u16(31);
	    for (var i = 0; i < 31; ++i) {
	        b[i] = start += 1 << eb[i - 1];
	    }
	    // numbers here are at max 18 bits
	    var r = new u32(b[30]);
	    for (var i = 1; i < 30; ++i) {
	        for (var j = b[i]; j < b[i + 1]; ++j) {
	            r[j] = ((j - b[i]) << 5) | i;
	        }
	    }
	    return [b, r];
	};
	var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
	// we can ignore the fact that the other numbers are wrong; they never happen anyway
	fl[28] = 258, revfl[258] = 28;
	var _b = freb(fdeb, 0), fd = _b[0];
	// map of value to reverse (assuming 16 bits)
	var rev = new u16(32768);
	for (var i = 0; i < 32768; ++i) {
	    // reverse table algorithm from SO
	    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);
	    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);
	    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);
	    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;
	}
	// create huffman tree from u8 "map": index -> code length for code index
	// mb (max bits) must be at most 15
	// TODO: optimize/split up?
	var hMap = (function (cd, mb, r) {
	    var s = cd.length;
	    // index
	    var i = 0;
	    // u16 "map": index -> # of codes with bit length = index
	    var l = new u16(mb);
	    // length of cd must be 288 (total # of codes)
	    for (; i < s; ++i)
	        ++l[cd[i] - 1];
	    // u16 "map": index -> minimum code for bit length = index
	    var le = new u16(mb);
	    for (i = 0; i < mb; ++i) {
	        le[i] = (le[i - 1] + l[i - 1]) << 1;
	    }
	    var co;
	    if (r) {
	        // u16 "map": index -> number of actual bits, symbol for code
	        co = new u16(1 << mb);
	        // bits to remove for reverser
	        var rvb = 15 - mb;
	        for (i = 0; i < s; ++i) {
	            // ignore 0 lengths
	            if (cd[i]) {
	                // num encoding both symbol and bits read
	                var sv = (i << 4) | cd[i];
	                // free bits
	                var r_1 = mb - cd[i];
	                // start value
	                var v = le[cd[i] - 1]++ << r_1;
	                // m is end value
	                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
	                    // every 16 bit value starting with the code yields the same result
	                    co[rev[v] >>> rvb] = sv;
	                }
	            }
	        }
	    }
	    else {
	        co = new u16(s);
	        for (i = 0; i < s; ++i) {
	            if (cd[i]) {
	                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);
	            }
	        }
	    }
	    return co;
	});
	// fixed length tree
	var flt = new u8(288);
	for (var i = 0; i < 144; ++i)
	    flt[i] = 8;
	for (var i = 144; i < 256; ++i)
	    flt[i] = 9;
	for (var i = 256; i < 280; ++i)
	    flt[i] = 7;
	for (var i = 280; i < 288; ++i)
	    flt[i] = 8;
	// fixed distance tree
	var fdt = new u8(32);
	for (var i = 0; i < 32; ++i)
	    fdt[i] = 5;
	// fixed length map
	var flrm = /*#__PURE__*/ hMap(flt, 9, 1);
	// fixed distance map
	var fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
	// find max of array
	var max = function (a) {
	    var m = a[0];
	    for (var i = 1; i < a.length; ++i) {
	        if (a[i] > m)
	            m = a[i];
	    }
	    return m;
	};
	// read d, starting at bit p and mask with m
	var bits = function (d, p, m) {
	    var o = (p / 8) | 0;
	    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;
	};
	// read d, starting at bit p continuing for at least 16 bits
	var bits16 = function (d, p) {
	    var o = (p / 8) | 0;
	    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));
	};
	// get end of byte
	var shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };
	// typed array slice - allows garbage collector to free original reference,
	// while being more compatible than .slice
	var slc = function (v, s, e) {
	    if (s == null || s < 0)
	        s = 0;
	    if (e == null || e > v.length)
	        e = v.length;
	    // can't use .constructor in case user-supplied
	    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
	    n.set(v.subarray(s, e));
	    return n;
	};
	// expands raw DEFLATE data
	var inflt = function (dat, buf, st) {
	    // source length
	    var sl = dat.length;
	    if (!sl || (st && !st.l && sl < 5))
	        return buf || new u8(0);
	    // have to estimate size
	    var noBuf = !buf || st;
	    // no state
	    var noSt = !st || st.i;
	    if (!st)
	        st = {};
	    // Assumes roughly 33% compression ratio average
	    if (!buf)
	        buf = new u8(sl * 3);
	    // ensure buffer can fit at least l elements
	    var cbuf = function (l) {
	        var bl = buf.length;
	        // need to increase size to fit
	        if (l > bl) {
	            // Double or set to necessary, whichever is greater
	            var nbuf = new u8(Math.max(bl * 2, l));
	            nbuf.set(buf);
	            buf = nbuf;
	        }
	    };
	    //  last chunk         bitpos           bytes
	    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
	    // total bits
	    var tbts = sl * 8;
	    do {
	        if (!lm) {
	            // BFINAL - this is only 1 when last chunk is next
	            st.f = final = bits(dat, pos, 1);
	            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
	            var type = bits(dat, pos + 1, 3);
	            pos += 3;
	            if (!type) {
	                // go to end of byte boundary
	                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
	                if (t > sl) {
	                    if (noSt)
	                        throw 'unexpected EOF';
	                    break;
	                }
	                // ensure size
	                if (noBuf)
	                    cbuf(bt + l);
	                // Copy over uncompressed data
	                buf.set(dat.subarray(s, t), bt);
	                // Get new bitpos, update byte count
	                st.b = bt += l, st.p = pos = t * 8;
	                continue;
	            }
	            else if (type == 1)
	                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
	            else if (type == 2) {
	                //  literal                            lengths
	                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
	                var tl = hLit + bits(dat, pos + 5, 31) + 1;
	                pos += 14;
	                // length+distance tree
	                var ldt = new u8(tl);
	                // code length tree
	                var clt = new u8(19);
	                for (var i = 0; i < hcLen; ++i) {
	                    // use index map to get real code
	                    clt[clim[i]] = bits(dat, pos + i * 3, 7);
	                }
	                pos += hcLen * 3;
	                // code lengths bits
	                var clb = max(clt), clbmsk = (1 << clb) - 1;
	                // code lengths map
	                var clm = hMap(clt, clb, 1);
	                for (var i = 0; i < tl;) {
	                    var r = clm[bits(dat, pos, clbmsk)];
	                    // bits read
	                    pos += r & 15;
	                    // symbol
	                    var s = r >>> 4;
	                    // code length to copy
	                    if (s < 16) {
	                        ldt[i++] = s;
	                    }
	                    else {
	                        //  copy   count
	                        var c = 0, n = 0;
	                        if (s == 16)
	                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
	                        else if (s == 17)
	                            n = 3 + bits(dat, pos, 7), pos += 3;
	                        else if (s == 18)
	                            n = 11 + bits(dat, pos, 127), pos += 7;
	                        while (n--)
	                            ldt[i++] = c;
	                    }
	                }
	                //    length tree                 distance tree
	                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
	                // max length bits
	                lbt = max(lt);
	                // max dist bits
	                dbt = max(dt);
	                lm = hMap(lt, lbt, 1);
	                dm = hMap(dt, dbt, 1);
	            }
	            else
	                throw 'invalid block type';
	            if (pos > tbts) {
	                if (noSt)
	                    throw 'unexpected EOF';
	                break;
	            }
	        }
	        // Make sure the buffer can hold this + the largest possible addition
	        // Maximum chunk size (practically, theoretically infinite) is 2^17;
	        if (noBuf)
	            cbuf(bt + 131072);
	        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
	        var lpos = pos;
	        for (;; lpos = pos) {
	            // bits read, code
	            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
	            pos += c & 15;
	            if (pos > tbts) {
	                if (noSt)
	                    throw 'unexpected EOF';
	                break;
	            }
	            if (!c)
	                throw 'invalid length/literal';
	            if (sym < 256)
	                buf[bt++] = sym;
	            else if (sym == 256) {
	                lpos = pos, lm = null;
	                break;
	            }
	            else {
	                var add = sym - 254;
	                // no extra bits needed if less
	                if (sym > 264) {
	                    // index
	                    var i = sym - 257, b = fleb[i];
	                    add = bits(dat, pos, (1 << b) - 1) + fl[i];
	                    pos += b;
	                }
	                // dist
	                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
	                if (!d)
	                    throw 'invalid distance';
	                pos += d & 15;
	                var dt = fd[dsym];
	                if (dsym > 3) {
	                    var b = fdeb[dsym];
	                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;
	                }
	                if (pos > tbts) {
	                    if (noSt)
	                        throw 'unexpected EOF';
	                    break;
	                }
	                if (noBuf)
	                    cbuf(bt + 131072);
	                var end = bt + add;
	                for (; bt < end; bt += 4) {
	                    buf[bt] = buf[bt - dt];
	                    buf[bt + 1] = buf[bt + 1 - dt];
	                    buf[bt + 2] = buf[bt + 2 - dt];
	                    buf[bt + 3] = buf[bt + 3 - dt];
	                }
	                bt = end;
	            }
	        }
	        st.l = lm, st.p = lpos, st.b = bt;
	        if (lm)
	            final = 1, st.m = lbt, st.d = dm, st.n = dbt;
	    } while (!final);
	    return bt == buf.length ? buf : slc(buf, 0, bt);
	};
	// empty
	var et = /*#__PURE__*/ new u8(0);
	// read 2 bytes
	var b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };
	// read 4 bytes
	var b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };
	var b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };
	/**
	 * Expands DEFLATE data with no wrapper
	 * @param data The data to decompress
	 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
	 * @returns The decompressed version of the data
	 */
	function inflateSync(data, out) {
	    return inflt(data, out);
	}
	// text decoder
	var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
	// text decoder stream
	var tds = 0;
	try {
	    td.decode(et, { stream: true });
	    tds = 1;
	}
	catch (e) { }
	// decode UTF8
	var dutf8 = function (d) {
	    for (var r = '', i = 0;;) {
	        var c = d[i++];
	        var eb = (c > 127) + (c > 223) + (c > 239);
	        if (i + eb > d.length)
	            return [r, slc(d, i - 1)];
	        if (!eb)
	            r += String.fromCharCode(c);
	        else if (eb == 3) {
	            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,
	                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));
	        }
	        else if (eb & 1)
	            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));
	        else
	            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));
	    }
	};
	/**
	 * Converts a Uint8Array to a string
	 * @param dat The data to decode to string
	 * @param latin1 Whether or not to interpret the data as Latin-1. This should
	 *               not need to be true unless encoding to binary string.
	 * @returns The original UTF-8/Latin-1 string
	 */
	function strFromU8(dat, latin1) {
	    if (latin1) {
	        var r = '';
	        for (var i = 0; i < dat.length; i += 16384)
	            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
	        return r;
	    }
	    else if (td)
	        return td.decode(dat);
	    else {
	        var _a = dutf8(dat), out = _a[0], ext = _a[1];
	        if (ext.length)
	            throw 'invalid utf-8 data';
	        return out;
	    }
	}
	// skip local zip header
	var slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };
	// read zip header
	var zh = function (d, b, z) {
	    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
	    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];
	    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
	};
	// read zip64 extra field
	var z64e = function (d, b) {
	    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
	        ;
	    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
	};
	/**
	 * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better
	 * performance with more than one file.
	 * @param data The raw compressed ZIP file
	 * @returns The decompressed files
	 */
	function unzipSync(data) {
	    var files = {};
	    var e = data.length - 22;
	    for (; b4(data, e) != 0x6054B50; --e) {
	        if (!e || data.length - e > 65558)
	            throw 'invalid zip file';
	    }
	    var c = b2(data, e + 8);
	    if (!c)
	        return {};
	    var o = b4(data, e + 16);
	    var z = o == 4294967295;
	    if (z) {
	        e = b4(data, e - 12);
	        if (b4(data, e) != 0x6064B50)
	            throw 'invalid zip file';
	        c = b4(data, e + 32);
	        o = b4(data, e + 48);
	    }
	    for (var i = 0; i < c; ++i) {
	        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
	        o = no;
	        if (!c_2)
	            files[fn] = slc(data, b, b + sc);
	        else if (c_2 == 8)
	            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));
	        else
	            throw 'unknown compression type ' + c_2;
	    }
	    return files;
	}

	/*!
	 * three-icosa
	 * https://github.com/icosa-gallery/three-icosa
	 * Copyright (c) 2021-2022 Icosa Gallery
	 * Released under the Apache 2.0 Licence.
	 */

	// Copyright 2021-2022 Icosa Gallery

	class TiltShaderLoader extends Loader {
	    constructor( manager ) {
	        super( manager );
	        
	        this.loadedMaterials = {};
	    }
	    
	    async load(brushName, onLoad, onProgress, onError ) {
	        const scope = this;

	        const isAlreadyLoaded = this.loadedMaterials[brushName];
	        
	        if (isAlreadyLoaded !== undefined) {
	            onLoad( scope.parse( isAlreadyLoaded ) );
	            return;
	        }
	        
			const loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'text' );
			loader.setWithCredentials( this.withCredentials );

	        const textureLoader = new TextureLoader(this.manager);
	        textureLoader.setPath(this.path);
	        textureLoader.setWithCredentials( this.withCredentials );

	        const materialParams = tiltBrushMaterialParams[brushName];

	        materialParams.vertexShader = await loader.loadAsync(materialParams.vertexShader);
	        materialParams.fragmentShader = await loader.loadAsync(materialParams.fragmentShader);

	        if (materialParams.uniforms.u_MainTex) {
	            const mainTex = await textureLoader.loadAsync(materialParams.uniforms.u_MainTex.value);
	            mainTex.name = `${brushName}_MainTex`;
	            mainTex.wrapS = RepeatWrapping;
	            mainTex.wrapT = RepeatWrapping;
	            mainTex.flipY = false;
	            materialParams.uniforms.u_MainTex.value = mainTex;
	        }

	        if (materialParams.uniforms.u_BumpMap) {
	            const bumpMap = await textureLoader.loadAsync(materialParams.uniforms.u_BumpMap.value);
	            bumpMap.name = `${brushName}_BumpMap`;
	            bumpMap.wrapS = RepeatWrapping;
	            bumpMap.wrapT = RepeatWrapping;
	            bumpMap.flipY = false;
	            materialParams.uniforms.u_BumpMap.value = bumpMap;
	        }

	        if (materialParams.uniforms.u_AlphaMask) {
	            const alphaMask = await textureLoader.loadAsync(materialParams.uniforms.u_AlphaMask.value);
	            alphaMask.name = `${brushName}_AlphaMask`;
	            alphaMask.wrapS = RepeatWrapping;
	            alphaMask.wrapT = RepeatWrapping;
	            alphaMask.flipY = false;
	            materialParams.uniforms.u_AlphaMask.value = alphaMask;
	        }

	        // inject three.js lighting uniforms
	        for(var lightType in UniformsLib.lights)
	        {
	            materialParams.uniforms[lightType] = UniformsLib.lights[lightType];
	        }

	        let rawMaterial = new RawShaderMaterial(materialParams);
	        this.loadedMaterials[brushName] = rawMaterial;
	        onLoad( scope.parse( rawMaterial ) );
	    }

	    parse( rawMaterial ) {
	        return rawMaterial;
	    }

	    lookupMaterial(nameOrGuid) {
	        const name = this.lookupMaterialName(nameOrGuid);
	        return tiltBrushMaterialParams[name];
	    }

	    lookupMaterialName(nameOrGuid) {
	        switch(nameOrGuid) {
	            case "BlocksBasic:":
	            case "0e87b49c-6546-3a34-3a44-8a556d7d6c3e":
	                return "BlocksBasic";

	            case "BlocksGem":
	            case "232998f8-d357-47a2-993a-53415df9be10":
	                return "BlocksGem";

	            case "BlocksGlass":
	            case "3d813d82-5839-4450-8ddc-8e889ecd96c7":
	                return "BlocksGlass";

	            case "Bubbles":
	            case "89d104cd-d012-426b-b5b3-bbaee63ac43c":
	                return "Bubbles";

	            case "CelVinyl":
	            case "700f3aa8-9a7c-2384-8b8a-ea028905dd8c":
	                return "CelVinyl";

	            case "ChromaticWave":
	            case "0f0ff7b2-a677-45eb-a7d6-0cd7206f4816":
	                return "ChromaticWave";

	            case "CoarseBristles":
	            case "1161af82-50cf-47db-9706-0c3576d43c43":
	            case "79168f10-6961-464a-8be1-57ed364c5600":
	                return "CoarseBristles";
	                
	            case "Comet":
	            case "1caa6d7d-f015-3f54-3a4b-8b5354d39f81":
	                return "Comet";
	            
	            case "DiamondHull":
	            case "c8313697-2563-47fc-832e-290f4c04b901":
	                return "DiamondHull";
	            
	            case "Disco":
	            case "4391aaaa-df73-4396-9e33-31e4e4930b27":
	                return "Disco";
	            
	            case "DotMarker":
	            case "d1d991f2-e7a0-4cf1-b328-f57e915e6260":
	                return "DotMarker";
	            
	            case "Dots":
	            case "6a1cf9f9-032c-45ec-9b1d-a6680bee30f7":
	                return "Dots";

	            case "DoubleTaperedFlat":
	            case "0d3889f3-3ede-470c-8af4-f44813306126":
	                return "DoubleTaperedFlat";
	            
	            case "DoubleTaperedMarker":
	            case "0d3889f3-3ede-470c-8af4-de4813306126":
	                return "DoubleTaperedMarker";
	            
	            case "DuctTape":
	            case "d0262945-853c-4481-9cbd-88586bed93cb":
	            case "3ca16e2f-bdcd-4da2-8631-dcef342f40f1":
	                return "DuctTape";
	            
	            case "Electricity":
	            case "f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51":
	                return "Electricity";

	            case "Embers":
	            case "02ffb866-7fb2-4d15-b761-1012cefb1360":
	                return "Embers";
	            
	            case "EnvironmentDiffuse":
	            case "0ad58bbd-42bc-484e-ad9a-b61036ff4ce7": 
	                return "EnvironmentDiffuse";
	            
	            case "EnvironmentDiffuseLightMap":
	            case "d01d9d6c-9a61-4aba-8146-5891fafb013b":
	                return "EnvironmentDiffuseLightMap";

	            case "Fire":
	            case "cb92b597-94ca-4255-b017-0e3f42f12f9e":
	                return "Fire";

	            case "2d35bcf0-e4d8-452c-97b1-3311be063130":
	            case "280c0a7a-aad8-416c-a7d2-df63d129ca70":
	            case "55303bc4-c749-4a72-98d9-d23e68e76e18":
	            case "Flat":
	                return "Flat";
	            
	            case "cf019139-d41c-4eb0-a1d0-5cf54b0a42f3":
	            case "geometry_Highlighter":
	                return "Highlighter";
	            
	            case "Hypercolor":
	            case "dce872c2-7b49-4684-b59b-c45387949c5c":
	            case "e8ef32b1-baa8-460a-9c2c-9cf8506794f5":
	                return "Hypercolor";
	            
	            case "HyperGrid":
	            case "6a1cf9f9-032c-45ec-9b6e-a6680bee32e9":
	                return "HyperGrid";

	            case "Icing":
	            case "2f212815-f4d3-c1a4-681a-feeaf9c6dc37":
	                return "Icing";
	            
	            case "Ink":
	            case "f5c336cf-5108-4b40-ade9-c687504385ab":
	            case "c0012095-3ffd-4040-8ee1-fc180d346eaa":
	                return "Ink";

	            case "Leaves":
	            case "4a76a27a-44d8-4bfe-9a8c-713749a499b0":
	            case "ea19de07-d0c0-4484-9198-18489a3c1487":
	                return "Leaves";

	            case "Light":
	            case "2241cd32-8ba2-48a5-9ee7-2caef7e9ed62":
	                return "Light";

	            case "LightWire":
	            case "4391aaaa-df81-4396-9e33-31e4e4930b27":
	                return "LightWire";
	            
	            case "Lofted":
	            case "d381e0f5-3def-4a0d-8853-31e9200bcbda":
	                return "Lofted";

	            case "Marker":
	            case "429ed64a-4e97-4466-84d3-145a861ef684":
	                return "Marker";
	            
	            case "MatteHull":
	            case "79348357-432d-4746-8e29-0e25c112e3aa":
	                return "MatteHull";

	            case "NeonPulse":
	            case "b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6":
	                return "NeonPulse";

	            case "OilPaint":
	            case "f72ec0e7-a844-4e38-82e3-140c44772699":
	            case "c515dad7-4393-4681-81ad-162ef052241b":
	                return "OilPaint";

	            case "Paper":
	            case "f1114e2e-eb8d-4fde-915a-6e653b54e9f5":
	            case "759f1ebd-20cd-4720-8d41-234e0da63716":
	                return "Paper";
	            
	            case "PbrTemplate":
	            case "f86a096c-2f4f-4f9d-ae19-81b99f2944e0":
	                return "PbrTemplate";
	            
	            case "PbrTransparentTemplate":
	            case "19826f62-42ac-4a9e-8b77-4231fbd0cfbf":
	                return "PbrTransparentTemplate";
	            
	            case "Petal":
	            case "e0abbc80-0f80-e854-4970-8924a0863dcc":
	                return "Petal";

	            case "Plasma":
	            case "c33714d1-b2f9-412e-bd50-1884c9d46336":
	                return "Plasma";
	            
	            case "Rainbow":
	            case "ad1ad437-76e2-450d-a23a-e17f8310b960":
	                return "Rainbow";

	            case "ShinyHull":
	            case "faaa4d44-fcfb-4177-96be-753ac0421ba3":
	                return "ShinyHull";

	            case "Smoke":
	            case "70d79cca-b159-4f35-990c-f02193947fe8":
	                return "Smoke";
	            
	            case "Snow":
	            case "d902ed8b-d0d1-476c-a8de-878a79e3a34c":
	                return "Snow";

	            case "SoftHighlighter":
	            case "accb32f5-4509-454f-93f8-1df3fd31df1b":
	                return "SoftHighlighter";
	            
	            case "Spikes":
	            case "cf7f0059-7aeb-53a4-2b67-c83d863a9ffa":
	                return "Spikes";
	            
	            case "Splatter":
	            case "8dc4a70c-d558-4efd-a5ed-d4e860f40dc3":
	            case "7a1c8107-50c5-4b70-9a39-421576d6617e":
	                return "Splatter";
	            
	            case "Stars":
	            case "0eb4db27-3f82-408d-b5a1-19ebd7d5b711":
	                return "Stars";

	            case "Streamers":
	            case "44bb800a-fbc3-4592-8426-94ecb05ddec3":
	                return "Streamers";
	            
	            case "Taffy":
	            case "0077f88c-d93a-42f3-b59b-b31c50cdb414":
	                return "Taffy";

	            case "TaperedFlat":
	            case "b468c1fb-f254-41ed-8ec9-57030bc5660c":
	            case "c8ccb53d-ae13-45ef-8afb-b730d81394eb":
	                return "TaperedFlat";

	            case "TaperedMarker":
	            case "d90c6ad8-af0f-4b54-b422-e0f92abe1b3c":
	            case "1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0":
	                return "TaperedMarker";

	            case "ThickPaint":
	            case "75b32cf0-fdd6-4d89-a64b-e2a00b247b0f":
	            case "fdf0326a-c0d1-4fed-b101-9db0ff6d071f":
	                return "ThickPaint";
	            
	            case "Toon":
	            case "4391385a-df73-4396-9e33-31e4e4930b27":
	                return "Toon";

	            case "UnlitHull":
	            case "a8fea537-da7c-4d4b-817f-24f074725d6d":
	                return "UnlitHull";
	            
	            case "VelvetInk":
	            case "d229d335-c334-495a-a801-660ac8a87360":
	                return "VelvetInk";

	            case "Waveform":
	            case "10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab":
	                return "Waveform";

	            case "WetPaint":
	            case "b67c0e81-ce6d-40a8-aeb0-ef036b081aa3":
	            case "dea67637-cd1a-27e4-c9b1-52f4bbcb84e5":
	                return "WetPaint";

	            case "WigglyGraphite":
	            case "5347acf0-a8e2-47b6-8346-30c70719d763":
	            case "e814fef1-97fd-7194-4a2f-50c2bb918be2":
	                return "WigglyGraphite";

	            case "wire":
	            case "4391385a-cf83-4396-9e33-31e4e4930b27":
	                return "Wire";
	        }    }
	}

	const tiltBrushMaterialParams = {
	    "BlocksBasic" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Shininess: { value: 0.2 },
	            u_SpecColor: { value: new Vector3(0.1960784, 0.1960784, 0.1960784) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "BlocksBasic-0e87b49c-6546-3a34-3a44-8a556d7d6c3e/BlocksBasic-0e87b49c-6546-3a34-3a44-8a556d7d6c3e-v10.0-vertex.glsl",
	        fragmentShader: "BlocksBasic-0e87b49c-6546-3a34-3a44-8a556d7d6c3e/BlocksBasic-0e87b49c-6546-3a34-3a44-8a556d7d6c3e-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "BlocksGem" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: {value: new Vector4(0.3922, 0.3922, 0.3922, 1)},
	            u_SceneLight_0_color: {value: new Vector4(0.7780, 0.8157, 0.9914, 1)},
	            u_SceneLight_1_color: {value: new Vector4(0.4282, 0.4212, 0.3459, 1)},
	            u_Color: { value: new Vector4(1, 1, 1, 1) },
	            u_Shininess: { value: 0.9 },
	            u_RimIntensity: { value: 0.5 },
	            u_RimPower: { value: 2 },
	            u_Frequency: { value: 2 },
	            u_Jitter: { value: 1 },
	            u_fogColor: {value: new Vector3(0.0196, 0.0196, 0.0196)},
	            u_fogDensity: {value: 0 }
	        },
	        vertexShader: "BlocksGem-232998f8-d357-47a2-993a-53415df9be10/BlocksGem-232998f8-d357-47a2-993a-53415df9be10-v10.0-vertex.glsl",
	        fragmentShader: "BlocksGem-232998f8-d357-47a2-993a-53415df9be10/BlocksGem-232998f8-d357-47a2-993a-53415df9be10-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "BlocksGlass" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Color: { value: new Vector4(1, 1, 1, 1) },
	            u_Shininess: { value: 0.8 },
	            u_RimIntensity: { value: 0.7 },
	            u_RimPower: { value: 4 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "BlocksGlass-3d813d82-5839-4450-8ddc-8e889ecd96c7/BlocksGlass-3d813d82-5839-4450-8ddc-8e889ecd96c7-v10.0-vertex.glsl",
	        fragmentShader: "BlocksGlass-3d813d82-5839-4450-8ddc-8e889ecd96c7/BlocksGlass-3d813d82-5839-4450-8ddc-8e889ecd96c7-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Bubbles" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Bubbles-89d104cd-d012-426b-b5b3-bbaee63ac43c/Bubbles-89d104cd-d012-426b-b5b3-bbaee63ac43c-v10.0-MainTex.png" },
	        },
	        vertexShader: "Bubbles-89d104cd-d012-426b-b5b3-bbaee63ac43c/Bubbles-89d104cd-d012-426b-b5b3-bbaee63ac43c-v10.0-vertex.glsl",
	        fragmentShader: "Bubbles-89d104cd-d012-426b-b5b3-bbaee63ac43c/Bubbles-89d104cd-d012-426b-b5b3-bbaee63ac43c-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "CelVinyl" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_Cutoff: { value: 0.554 },
	            u_MainTex: { value: "CelVinyl-700f3aa8-9a7c-2384-8b8a-ea028905dd8c/CelVinyl-700f3aa8-9a7c-2384-8b8a-ea028905dd8c-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "CelVinyl-700f3aa8-9a7c-2384-8b8a-ea028905dd8c/CelVinyl-700f3aa8-9a7c-2384-8b8a-ea028905dd8c-v10.0-vertex.glsl",
	        fragmentShader: "CelVinyl-700f3aa8-9a7c-2384-8b8a-ea028905dd8c/CelVinyl-700f3aa8-9a7c-2384-8b8a-ea028905dd8c-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "ChromaticWave" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_time: { value: new Vector4() },
	            u_EmissionGain: { value: 0.45 },
	        },
	        vertexShader: "ChromaticWave-0f0ff7b2-a677-45eb-a7d6-0cd7206f4816/ChromaticWave-0f0ff7b2-a677-45eb-a7d6-0cd7206f4816-v10.0-vertex.glsl",
	        fragmentShader: "ChromaticWave-0f0ff7b2-a677-45eb-a7d6-0cd7206f4816/ChromaticWave-0f0ff7b2-a677-45eb-a7d6-0cd7206f4816-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201
	    },
	    "CoarseBristles" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_MainTex: { value: "CoarseBristles-1161af82-50cf-47db-9706-0c3576d43c43/CoarseBristles-1161af82-50cf-47db-9706-0c3576d43c43-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.25 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "CoarseBristles-1161af82-50cf-47db-9706-0c3576d43c43/CoarseBristles-1161af82-50cf-47db-9706-0c3576d43c43-v10.0-vertex.glsl",
	        fragmentShader: "CoarseBristles-1161af82-50cf-47db-9706-0c3576d43c43/CoarseBristles-1161af82-50cf-47db-9706-0c3576d43c43-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Comet" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81/Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81-v10.0-MainTex.png" },
	            u_AlphaMask: { value: "Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81/Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81-v10.0-AlphaMask.png" },
	            u_AlphaMask_TexelSize: { value: new Vector4(0.0156, 1, 64, 1)},
	            u_time: { value: new Vector4() },
	            u_Speed: { value: 1 },
	            u_EmissionGain: { value: 0.5 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81/Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81-v10.0-vertex.glsl",
	        fragmentShader: "Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81/Comet-1caa6d7d-f015-3f54-3a4b-8b5354d39f81-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "DiamondHull" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_MainTex: { value: "DiamondHull-c8313697-2563-47fc-832e-290f4c04b901/DiamondHull-c8313697-2563-47fc-832e-290f4c04b901-v10.0-MainTex.png" },
	            u_time: { value: new Vector4() },
	            cameraPosition: { value: new Vector3() },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "DiamondHull-c8313697-2563-47fc-832e-290f4c04b901/DiamondHull-c8313697-2563-47fc-832e-290f4c04b901-v10.0-vertex.glsl",
	        fragmentShader: "DiamondHull-c8313697-2563-47fc-832e-290f4c04b901/DiamondHull-c8313697-2563-47fc-832e-290f4c04b901-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201,
	    },
	    "Disco" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_time: { value: new Vector4() },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Shininess: { value: 0.65 },
	            u_SpecColor: { value: new Vector3(0.5147059, 0.5147059, 0.5147059) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "Disco-4391aaaa-df73-4396-9e33-31e4e4930b27/Disco-4391aaaa-df73-4396-9e33-31e4e4930b27-v10.0-vertex.glsl",
	        fragmentShader: "Disco-4391aaaa-df73-4396-9e33-31e4e4930b27/Disco-4391aaaa-df73-4396-9e33-31e4e4930b27-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "DotMarker" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "DotMarker-d1d991f2-e7a0-4cf1-b328-f57e915e6260/DotMarker-d1d991f2-e7a0-4cf1-b328-f57e915e6260-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "DotMarker-d1d991f2-e7a0-4cf1-b328-f57e915e6260/DotMarker-d1d991f2-e7a0-4cf1-b328-f57e915e6260-v10.0-vertex.glsl",
	        fragmentShader: "DotMarker-d1d991f2-e7a0-4cf1-b328-f57e915e6260/DotMarker-d1d991f2-e7a0-4cf1-b328-f57e915e6260-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0,
	        
	    },
	    "Dots" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Dots-6a1cf9f9-032c-45ec-9b1d-a6680bee30f7/Dots-6a1cf9f9-032c-45ec-9b1d-a6680bee30f7-v10.0-MainTex.png" },
	            u_TintColor: { value: new Vector4(1, 1, 1, 1) },
	            u_EmissionGain: { value: 300 },
	            u_BaseGain: { value: 0.4 }
	        },
	        vertexShader: "Dots-6a1cf9f9-032c-45ec-9b1d-a6680bee30f7/Dots-6a1cf9f9-032c-45ec-9b1d-a6680bee30f7-v10.0-vertex.glsl",
	        fragmentShader: "Dots-6a1cf9f9-032c-45ec-9b1d-a6680bee30f7/Dots-6a1cf9f9-032c-45ec-9b1d-a6680bee30f7-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "DoubleTaperedFlat" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Shininess: { value: 0.1500 },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "DoubleTaperedFlat-0d3889f3-3ede-470c-8af4-f44813306126/DoubleTaperedFlat-0d3889f3-3ede-470c-8af4-f44813306126-v10.0-vertex.glsl",
	        fragmentShader: "DoubleTaperedFlat-0d3889f3-3ede-470c-8af4-f44813306126/DoubleTaperedFlat-0d3889f3-3ede-470c-8af4-f44813306126-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "DoubleTaperedMarker" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "DoubleTaperedMarker-0d3889f3-3ede-470c-8af4-de4813306126/DoubleTaperedMarker-0d3889f3-3ede-470c-8af4-de4813306126-v10.0-vertex.glsl",
	        fragmentShader: "DoubleTaperedMarker-0d3889f3-3ede-470c-8af4-de4813306126/DoubleTaperedMarker-0d3889f3-3ede-470c-8af4-de4813306126-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "DuctTape" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.5372549, 0.5372549, 0.5372549) },
	            u_Shininess: { value: 0.414 },
	            u_MainTex: { value: "DuctTape-3ca16e2f-bdcd-4da2-8631-dcef342f40f1/DuctTape-3ca16e2f-bdcd-4da2-8631-dcef342f40f1-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.2 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "DuctTape-3ca16e2f-bdcd-4da2-8631-dcef342f40f1/DuctTape-3ca16e2f-bdcd-4da2-8631-dcef342f40f1-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "DuctTape-d0262945-853c-4481-9cbd-88586bed93cb/DuctTape-d0262945-853c-4481-9cbd-88586bed93cb-v10.0-vertex.glsl",
	        fragmentShader: "DuctTape-d0262945-853c-4481-9cbd-88586bed93cb/DuctTape-d0262945-853c-4481-9cbd-88586bed93cb-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Electricity" : {
	        uniforms: {
	            u_time: { value: new Vector4() },
	            u_DisplacementIntensity: { value: 2.0 },
	            u_EmissionGain: { value: 0.2 }
	        },
	        vertexShader: "Electricity-f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51/Electricity-f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51-v10.0-vertex.glsl",
	        fragmentShader: "Electricity-f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51/Electricity-f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Embers" : {
	        uniforms: {
	            u_time: { value: new Vector4() },
	            u_ScrollRate: { value: 0.6 },
	            u_ScrollDistance: { value: new Vector3(-0.2, 0.6, 0) },
	            u_ScrollJitterIntensity: { value: 0.03 },
	            u_ScrollJitterFrequency: { value: 5 },
	            u_TintColor: { value: new Vector4(1, 1, 1, 1) },
	            u_MainTex: { value: "Embers-02ffb866-7fb2-4d15-b761-1012cefb1360/Embers-02ffb866-7fb2-4d15-b761-1012cefb1360-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "Embers-02ffb866-7fb2-4d15-b761-1012cefb1360/Embers-02ffb866-7fb2-4d15-b761-1012cefb1360-v10.0-vertex.glsl",
	        fragmentShader: "Embers-02ffb866-7fb2-4d15-b761-1012cefb1360/Embers-02ffb866-7fb2-4d15-b761-1012cefb1360-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "EnvironmentDiffuse" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.1500 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "EnvironmentDiffuse-0ad58bbd-42bc-484e-ad9a-b61036ff4ce7/EnvironmentDiffuse-0ad58bbd-42bc-484e-ad9a-b61036ff4ce7-v1.0-vertex.glsl",
	        fragmentShader: "EnvironmentDiffuse-0ad58bbd-42bc-484e-ad9a-b61036ff4ce7/EnvironmentDiffuse-0ad58bbd-42bc-484e-ad9a-b61036ff4ce7-v1.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "EnvironmentDiffuseLightMap" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.1500 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "EnvironmentDiffuseLightMap-d01d9d6c-9a61-4aba-8146-5891fafb013b/EnvironmentDiffuseLightMap-d01d9d6c-9a61-4aba-8146-5891fafb013b-v1.0-vertex.glsl",
	        fragmentShader: "EnvironmentDiffuseLightMap-d01d9d6c-9a61-4aba-8146-5891fafb013b/EnvironmentDiffuseLightMap-d01d9d6c-9a61-4aba-8146-5891fafb013b-v1.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Fire" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Fire-cb92b597-94ca-4255-b017-0e3f42f12f9e/Fire-cb92b597-94ca-4255-b017-0e3f42f12f9e-v10.0-MainTex.png" },
	            u_time: { value: new Vector4() },
	            u_EmissionGain: { value: 0.5 }
	        },
	        vertexShader: "Fire-cb92b597-94ca-4255-b017-0e3f42f12f9e/Fire-cb92b597-94ca-4255-b017-0e3f42f12f9e-v10.0-vertex.glsl",
	        fragmentShader: "Fire-cb92b597-94ca-4255-b017-0e3f42f12f9e/Fire-cb92b597-94ca-4255-b017-0e3f42f12f9e-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201
	    },
	    "Flat" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "Flat-2d35bcf0-e4d8-452c-97b1-3311be063130/Flat-2d35bcf0-e4d8-452c-97b1-3311be063130-v10.0-vertex.glsl",
	        fragmentShader: "Flat-2d35bcf0-e4d8-452c-97b1-3311be063130/Flat-2d35bcf0-e4d8-452c-97b1-3311be063130-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201,
	    },
	    "Highlighter" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Highlighter-cf019139-d41c-4eb0-a1d0-5cf54b0a42f3/Highlighter-cf019139-d41c-4eb0-a1d0-5cf54b0a42f3-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.12 }
	        },
	        vertexShader: "Highlighter-cf019139-d41c-4eb0-a1d0-5cf54b0a42f3/Highlighter-cf019139-d41c-4eb0-a1d0-5cf54b0a42f3-v10.0-vertex.glsl",
	        fragmentShader: "Highlighter-cf019139-d41c-4eb0-a1d0-5cf54b0a42f3/Highlighter-cf019139-d41c-4eb0-a1d0-5cf54b0a42f3-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Hypercolor" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Shininess: { value: 0.5 },
	            u_SpecColor: { value: new Vector3(0.2745098, 0.2745098, 0.2745098) },
	            u_MainTex: { value: "Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c/Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c-v10.0-MainTex.png" },
	            u_time: { value: new Vector4() },
	            u_Cutoff: { value: 0.5 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c/Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c/Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c-v10.0-vertex.glsl",
	        fragmentShader: "Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c/Hypercolor-dce872c2-7b49-4684-b59b-c45387949c5c-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "HyperGrid" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_TintColor: { value: new Vector4(1, 1, 1, 1) },
	            u_MainTex: { value: "HyperGrid-6a1cf9f9-032c-45ec-9b6e-a6680bee32e9/HyperGrid-6a1cf9f9-032c-45ec-9b6e-a6680bee32e9-v10.0-MainTex.png" }
	        },
	        vertexShader: "HyperGrid-6a1cf9f9-032c-45ec-9b6e-a6680bee32e9/HyperGrid-6a1cf9f9-032c-45ec-9b6e-a6680bee32e9-v10.0-vertex.glsl",
	        fragmentShader: "HyperGrid-6a1cf9f9-032c-45ec-9b6e-a6680bee32e9/HyperGrid-6a1cf9f9-032c-45ec-9b6e-a6680bee32e9-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Icing" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.2352941, 0.2352941, 0.2352941) },
	            u_Shininess: { value: 0.1500 },
	            u_Cutoff: { value: 0.5 },
	            u_MainTex: { value: "Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37/Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37-v10.0-BumpMap.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37/Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37/Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37-v10.0-vertex.glsl",
	        fragmentShader: "Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37/Icing-2f212815-f4d3-c1a4-681a-feeaf9c6dc37-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Ink" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.2352941, 0.2352941, 0.2352941) },
	            u_Shininess: { value: 0.4 },
	            u_Cutoff: { value: 0.5 },
	            u_MainTex: { value: "Ink-c0012095-3ffd-4040-8ee1-fc180d346eaa/Ink-c0012095-3ffd-4040-8ee1-fc180d346eaa-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "Ink-c0012095-3ffd-4040-8ee1-fc180d346eaa/Ink-c0012095-3ffd-4040-8ee1-fc180d346eaa-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "Ink-f5c336cf-5108-4b40-ade9-c687504385ab/Ink-f5c336cf-5108-4b40-ade9-c687504385ab-v10.0-vertex.glsl",
	        fragmentShader: "Ink-f5c336cf-5108-4b40-ade9-c687504385ab/Ink-f5c336cf-5108-4b40-ade9-c687504385ab-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Leaves" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.395 },
	            u_Cutoff: { value: 0.5 },
	            u_MainTex: { value: "Leaves-ea19de07-d0c0-4484-9198-18489a3c1487/Leaves-ea19de07-d0c0-4484-9198-18489a3c1487-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "Leaves-ea19de07-d0c0-4484-9198-18489a3c1487/Leaves-ea19de07-d0c0-4484-9198-18489a3c1487-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "Leaves-ea19de07-d0c0-4484-9198-18489a3c1487/Leaves-ea19de07-d0c0-4484-9198-18489a3c1487-v10.0-vertex.glsl",
	        fragmentShader: "Leaves-ea19de07-d0c0-4484-9198-18489a3c1487/Leaves-ea19de07-d0c0-4484-9198-18489a3c1487-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Light" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Light-2241cd32-8ba2-48a5-9ee7-2caef7e9ed62/Light-2241cd32-8ba2-48a5-9ee7-2caef7e9ed62-v10.0-MainTex.png" },
	            u_EmissionGain: { value: 0.45 },
	        },
	        vertexShader: "Light-2241cd32-8ba2-48a5-9ee7-2caef7e9ed62/Light-2241cd32-8ba2-48a5-9ee7-2caef7e9ed62-v10.0-vertex.glsl",
	        fragmentShader: "Light-2241cd32-8ba2-48a5-9ee7-2caef7e9ed62/Light-2241cd32-8ba2-48a5-9ee7-2caef7e9ed62-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201,
	    },
	    "LightWire" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Shininess: { value: 0.81 },
	            u_SpecColor: { value: new Vector3(0.3455882, 0.3455882, 0.3455882) },
	            u_time: { value: new Vector4() },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_MainTex: { value: "LightWire-4391aaaa-df81-4396-9e33-31e4e4930b27/LightWire-4391aaaa-df81-4396-9e33-31e4e4930b27-v10.0-MainTex.png"}
	        },
	        vertexShader: "LightWire-4391aaaa-df81-4396-9e33-31e4e4930b27/LightWire-4391aaaa-df81-4396-9e33-31e4e4930b27-v10.0-vertex.glsl",
	        fragmentShader: "LightWire-4391aaaa-df81-4396-9e33-31e4e4930b27/LightWire-4391aaaa-df81-4396-9e33-31e4e4930b27-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Lofted" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "Lofted-d381e0f5-3def-4a0d-8853-31e9200bcbda/Lofted-d381e0f5-3def-4a0d-8853-31e9200bcbda-v10.0-vertex.glsl",
	        fragmentShader: "Lofted-d381e0f5-3def-4a0d-8853-31e9200bcbda/Lofted-d381e0f5-3def-4a0d-8853-31e9200bcbda-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Marker" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Marker-429ed64a-4e97-4466-84d3-145a861ef684/Marker-429ed64a-4e97-4466-84d3-145a861ef684-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.067 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "Marker-429ed64a-4e97-4466-84d3-145a861ef684/Marker-429ed64a-4e97-4466-84d3-145a861ef684-v10.0-vertex.glsl",
	        fragmentShader: "Marker-429ed64a-4e97-4466-84d3-145a861ef684/Marker-429ed64a-4e97-4466-84d3-145a861ef684-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0,
	        
	    },
	    "MatteHull" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "MatteHull-79348357-432d-4746-8e29-0e25c112e3aa/MatteHull-79348357-432d-4746-8e29-0e25c112e3aa-v10.0-vertex.glsl",
	        fragmentShader: "MatteHull-79348357-432d-4746-8e29-0e25c112e3aa/MatteHull-79348357-432d-4746-8e29-0e25c112e3aa-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0,
	    },
	    "NeonPulse" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_time: { value: new Vector4() },
	            u_EmissionGain: { value: 0.5 },
	        },
	        vertexShader: "NeonPulse-b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6/NeonPulse-b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6-v10.0-vertex.glsl",
	        fragmentShader: "NeonPulse-b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6/NeonPulse-b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201,
	    },
	    "OilPaint": {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.2352941, 0.2352941, 0.2352941) },
	            u_Shininess: { value: 0.4 },
	            u_Cutoff: { value: 0.5 },
	            u_MainTex: { value: "OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699/OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699/OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0020, 0.0020, 512, 512) },
	        },
	        vertexShader: "OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699/OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699-v10.0-vertex.glsl",
	        fragmentShader: "OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699/OilPaint-f72ec0e7-a844-4e38-82e3-140c44772699-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Paper" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.145 },
	            u_Cutoff: { value: 0.16 },
	            u_MainTex: { value: "Paper-759f1ebd-20cd-4720-8d41-234e0da63716/Paper-759f1ebd-20cd-4720-8d41-234e0da63716-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "Paper-759f1ebd-20cd-4720-8d41-234e0da63716/Paper-759f1ebd-20cd-4720-8d41-234e0da63716-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "Paper-f1114e2e-eb8d-4fde-915a-6e653b54e9f5/Paper-f1114e2e-eb8d-4fde-915a-6e653b54e9f5-v10.0-vertex.glsl",
	        fragmentShader: "Paper-f1114e2e-eb8d-4fde-915a-6e653b54e9f5/Paper-f1114e2e-eb8d-4fde-915a-6e653b54e9f5-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "PbrTemplate" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.1500 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "PbrTemplate-f86a096c-2f4f-4f9d-ae19-81b99f2944e0/PbrTemplate-f86a096c-2f4f-4f9d-ae19-81b99f2944e0-v1.0-vertex.glsl",
	        fragmentShader: "PbrTemplate-f86a096c-2f4f-4f9d-ae19-81b99f2944e0/PbrTemplate-f86a096c-2f4f-4f9d-ae19-81b99f2944e0-v1.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "PbrTransparentTemplate" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.1500 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "PbrTransparentTemplate-19826f62-42ac-4a9e-8b77-4231fbd0cfbf/PbrTransparentTemplate-19826f62-42ac-4a9e-8b77-4231fbd0cfbf-v1.0-vertex.glsl",
	        fragmentShader: "PbrTransparentTemplate-19826f62-42ac-4a9e-8b77-4231fbd0cfbf/PbrTransparentTemplate-19826f62-42ac-4a9e-8b77-4231fbd0cfbf-v1.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Petal" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.01 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "Petal-e0abbc80-0f80-e854-4970-8924a0863dcc/Petal-e0abbc80-0f80-e854-4970-8924a0863dcc-v10.0-vertex.glsl",
	        fragmentShader: "Petal-e0abbc80-0f80-e854-4970-8924a0863dcc/Petal-e0abbc80-0f80-e854-4970-8924a0863dcc-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    // How did an experimental brush end up here?
	    "Plasma" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Plasma-c33714d1-b2f9-412e-bd50-1884c9d46336/Plasma-c33714d1-b2f9-412e-bd50-1884c9d46336-v10.0-MainTex.png" },
	            u_time: { value: new Vector4() }
	        },
	        vertexShader: "Plasma-c33714d1-b2f9-412e-bd50-1884c9d46336/Plasma-c33714d1-b2f9-412e-bd50-1884c9d46336-v10.0-vertex.glsl",
	        fragmentShader: "Plasma-c33714d1-b2f9-412e-bd50-1884c9d46336/Plasma-c33714d1-b2f9-412e-bd50-1884c9d46336-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Rainbow" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_time: { value: new Vector4() },
	            u_EmissionGain: { value: 0.65 }
	        },
	        vertexShader: "Rainbow-ad1ad437-76e2-450d-a23a-e17f8310b960/Rainbow-ad1ad437-76e2-450d-a23a-e17f8310b960-v10.0-vertex.glsl",
	        fragmentShader: "Rainbow-ad1ad437-76e2-450d-a23a-e17f8310b960/Rainbow-ad1ad437-76e2-450d-a23a-e17f8310b960-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201,
	    },
	    "ShinyHull" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.1985294, 0.1985294, 0.1985294) },
	            u_Shininess: { value: 0.7430 },
	            u_Cutoff: { value: 0.5 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "ShinyHull-faaa4d44-fcfb-4177-96be-753ac0421ba3/ShinyHull-faaa4d44-fcfb-4177-96be-753ac0421ba3-v10.0-vertex.glsl",
	        fragmentShader: "ShinyHull-faaa4d44-fcfb-4177-96be-753ac0421ba3/ShinyHull-faaa4d44-fcfb-4177-96be-753ac0421ba3-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Smoke": {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_TintColor: { value: new Vector4(1, 1, 1, 1) },
	            u_MainTex: { value: "Smoke-70d79cca-b159-4f35-990c-f02193947fe8/Smoke-70d79cca-b159-4f35-990c-f02193947fe8-v10.0-MainTex.png" }
	        },
	        vertexShader: "Smoke-70d79cca-b159-4f35-990c-f02193947fe8/Smoke-70d79cca-b159-4f35-990c-f02193947fe8-v10.0-vertex.glsl",
	        fragmentShader: "Smoke-70d79cca-b159-4f35-990c-f02193947fe8/Smoke-70d79cca-b159-4f35-990c-f02193947fe8-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Snow" : {
	        uniforms: {
	            u_time: { value: new Vector4() },
	            u_ScrollRate: { value: 0.2 },
	            u_ScrollDistance: { value: new Vector3(0, -0.3, 0) },
	            u_ScrollJitterIntensity: { value: 0.01 },
	            u_ScrollJitterFrequency: { value: 12 },
	            u_TintColor: { value: new Vector4(1, 1, 1, 1) },
	            u_MainTex: { value: "Snow-d902ed8b-d0d1-476c-a8de-878a79e3a34c/Snow-d902ed8b-d0d1-476c-a8de-878a79e3a34c-v10.0-MainTex.png" },
	        },
	        vertexShader: "Snow-d902ed8b-d0d1-476c-a8de-878a79e3a34c/Snow-d902ed8b-d0d1-476c-a8de-878a79e3a34c-v10.0-vertex.glsl",
	        fragmentShader: "Snow-d902ed8b-d0d1-476c-a8de-878a79e3a34c/Snow-d902ed8b-d0d1-476c-a8de-878a79e3a34c-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "SoftHighlighter" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "SoftHighlighter-accb32f5-4509-454f-93f8-1df3fd31df1b/SoftHighlighter-accb32f5-4509-454f-93f8-1df3fd31df1b-v10.0-MainTex.png" },
	        },
	        vertexShader: "SoftHighlighter-accb32f5-4509-454f-93f8-1df3fd31df1b/SoftHighlighter-accb32f5-4509-454f-93f8-1df3fd31df1b-v10.0-vertex.glsl",
	        fragmentShader: "SoftHighlighter-accb32f5-4509-454f-93f8-1df3fd31df1b/SoftHighlighter-accb32f5-4509-454f-93f8-1df3fd31df1b-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 5,
	        blendDstAlpha: 201,
	        blendDst: 201,
	        blendEquationAlpha: 100,
	        blendEquation: 100,
	        blendSrcAlpha: 201,
	        blendSrc: 201,
	    },
	    "Spikes" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "Spikes-cf7f0059-7aeb-53a4-2b67-c83d863a9ffa/Spikes-cf7f0059-7aeb-53a4-2b67-c83d863a9ffa-v10.0-vertex.glsl",
	        fragmentShader: "Spikes-cf7f0059-7aeb-53a4-2b67-c83d863a9ffa/Spikes-cf7f0059-7aeb-53a4-2b67-c83d863a9ffa-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Splatter" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_MainTex: { value: "Splatter-7a1c8107-50c5-4b70-9a39-421576d6617e/Splatter-7a1c8107-50c5-4b70-9a39-421576d6617e-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.2 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "Splatter-7a1c8107-50c5-4b70-9a39-421576d6617e/Splatter-7a1c8107-50c5-4b70-9a39-421576d6617e-v10.0-vertex.glsl",
	        fragmentShader: "Splatter-7a1c8107-50c5-4b70-9a39-421576d6617e/Splatter-7a1c8107-50c5-4b70-9a39-421576d6617e-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Stars" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_time: { value: new Vector4() },
	            u_SparkleRate: { value: 5.3 },
	            u_MainTex: { value: "Stars-0eb4db27-3f82-408d-b5a1-19ebd7d5b711/Stars-0eb4db27-3f82-408d-b5a1-19ebd7d5b711-v10.0-MainTex.png" },
	        },
	        vertexShader: "Stars-0eb4db27-3f82-408d-b5a1-19ebd7d5b711/Stars-0eb4db27-3f82-408d-b5a1-19ebd7d5b711-v10.0-vertex.glsl",
	        fragmentShader: "Stars-0eb4db27-3f82-408d-b5a1-19ebd7d5b711/Stars-0eb4db27-3f82-408d-b5a1-19ebd7d5b711-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Streamers" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Streamers-44bb800a-fbc3-4592-8426-94ecb05ddec3/Streamers-44bb800a-fbc3-4592-8426-94ecb05ddec3-v10.0-MainTex.png" },
	            u_EmissionGain: { value: 0.4 },
	            u_time: { value: new Vector4() },
	        },
	        vertexShader: "Streamers-44bb800a-fbc3-4592-8426-94ecb05ddec3/Streamers-44bb800a-fbc3-4592-8426-94ecb05ddec3-v10.0-vertex.glsl",
	        fragmentShader: "Streamers-44bb800a-fbc3-4592-8426-94ecb05ddec3/Streamers-44bb800a-fbc3-4592-8426-94ecb05ddec3-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Taffy" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "Taffy-0077f88c-d93a-42f3-b59b-b31c50cdb414/Taffy-0077f88c-d93a-42f3-b59b-b31c50cdb414-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "Taffy-0077f88c-d93a-42f3-b59b-b31c50cdb414/Taffy-0077f88c-d93a-42f3-b59b-b31c50cdb414-v10.0-vertex.glsl",
	        fragmentShader: "Taffy-0077f88c-d93a-42f3-b59b-b31c50cdb414/Taffy-0077f88c-d93a-42f3-b59b-b31c50cdb414-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "TaperedFlat" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_MainTex: { value: "TaperedFlat-b468c1fb-f254-41ed-8ec9-57030bc5660c/TaperedFlat-b468c1fb-f254-41ed-8ec9-57030bc5660c-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.067 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "TaperedFlat-b468c1fb-f254-41ed-8ec9-57030bc5660c/TaperedFlat-b468c1fb-f254-41ed-8ec9-57030bc5660c-v10.0-vertex.glsl",
	        fragmentShader: "TaperedFlat-b468c1fb-f254-41ed-8ec9-57030bc5660c/TaperedFlat-b468c1fb-f254-41ed-8ec9-57030bc5660c-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "TaperedMarker" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "TaperedMarker-d90c6ad8-af0f-4b54-b422-e0f92abe1b3c/TaperedMarker-d90c6ad8-af0f-4b54-b422-e0f92abe1b3c-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "TaperedMarker-d90c6ad8-af0f-4b54-b422-e0f92abe1b3c/TaperedMarker-d90c6ad8-af0f-4b54-b422-e0f92abe1b3c-v10.0-vertex.glsl",
	        fragmentShader: "TaperedMarker-d90c6ad8-af0f-4b54-b422-e0f92abe1b3c/TaperedMarker-d90c6ad8-af0f-4b54-b422-e0f92abe1b3c-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "TaperedMarker_Flat" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0, 0, 0) },
	            u_Shininess: { value: 0.1500 },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_MainTex: { value: "TaperedMarker_Flat-1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0/TaperedMarker_Flat-1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0-v10.0-MainTex.png" },
	            u_Cutoff: { value: 0.2 }
	        },
	        vertexShader: "TaperedMarker_Flat-1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0/TaperedMarker_Flat-1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0-v10.0-vertex.glsl",
	        fragmentShader: "TaperedMarker_Flat-1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0/TaperedMarker_Flat-1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "ThickPaint" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.2352941, 0.2352941, 0.2352941) },
	            u_Shininess: { value: 0.4 },
	            u_Cutoff: { value: 0.5 },
	            u_MainTex: { value: "ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f/ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f/ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f/ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f-v10.0-vertex.glsl",
	        fragmentShader: "ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f/ThickPaint-75b32cf0-fdd6-4d89-a64b-e2a00b247b0f-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Toon" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "Toon-4391385a-df73-4396-9e33-31e4e4930b27/Toon-4391385a-df73-4396-9e33-31e4e4930b27-v10.0-vertex.glsl",
	        fragmentShader: "Toon-4391385a-df73-4396-9e33-31e4e4930b27/Toon-4391385a-df73-4396-9e33-31e4e4930b27-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0,
	    },
	    "UnlitHull" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "UnlitHull-a8fea537-da7c-4d4b-817f-24f074725d6d/UnlitHull-a8fea537-da7c-4d4b-817f-24f074725d6d-v10.0-vertex.glsl",
	        fragmentShader: "UnlitHull-a8fea537-da7c-4d4b-817f-24f074725d6d/UnlitHull-a8fea537-da7c-4d4b-817f-24f074725d6d-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0,
	    },
	    "VelvetInk" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_MainTex: { value: "VelvetInk-d229d335-c334-495a-a801-660ac8a87360/VelvetInk-d229d335-c334-495a-a801-660ac8a87360-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "VelvetInk-d229d335-c334-495a-a801-660ac8a87360/VelvetInk-d229d335-c334-495a-a801-660ac8a87360-v10.0-vertex.glsl",
	        fragmentShader: "VelvetInk-d229d335-c334-495a-a801-660ac8a87360/VelvetInk-d229d335-c334-495a-a801-660ac8a87360-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "Waveform" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_EmissionGain: { value: 0.5178571 },
	            u_time: { value: new Vector4() },
	            u_MainTex: { value: "Waveform-10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab/Waveform-10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab-v10.0-MainTex.png" },
	        },
	        vertexShader: "Waveform-10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab/Waveform-10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab-v10.0-vertex.glsl",
	        fragmentShader: "Waveform-10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab/Waveform-10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab-v10.0-fragment.glsl",
	        side: 2,
	        transparent: true,
	        depthFunc: 2,
	        depthWrite: false,
	        depthTest: true,
	        blending: 2
	    },
	    "WetPaint" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_SpecColor: { value: new Vector3(0.1397059, 0.1397059, 0.1397059) },
	            u_Shininess: { value: 0.85 },
	            u_Cutoff: { value: 0.3 },
	            u_MainTex: { value: "WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3/WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	            u_BumpMap: { value: "WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3/WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3-v10.0-BumpMap.png" },
	            u_BumpMap_TexelSize: { value: new Vector4(0.0010, 0.0078, 1024, 128) },
	        },
	        vertexShader: "WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3/WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3-v10.0-vertex.glsl",
	        fragmentShader: "WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3/WetPaint-b67c0e81-ce6d-40a8-aeb0-ef036b081aa3-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "WigglyGraphite" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_time: { value: new Vector4() },
	            u_ambient_light_color: { value: new Vector4(0.3922, 0.3922, 0.3922, 1) },
	            u_SceneLight_0_color: { value: new Vector4(0.7780, 0.8157, 0.9914, 1) },
	            u_SceneLight_1_color: { value: new Vector4(0.4282, 0.4212, 0.3459, 1) },
	            u_Cutoff: { value: 0.5 },
	            u_MainTex: { value: "WigglyGraphite-5347acf0-a8e2-47b6-8346-30c70719d763/WigglyGraphite-5347acf0-a8e2-47b6-8346-30c70719d763-v10.0-MainTex.png" },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 },
	        },
	        vertexShader: "WigglyGraphite-5347acf0-a8e2-47b6-8346-30c70719d763/WigglyGraphite-5347acf0-a8e2-47b6-8346-30c70719d763-v10.0-vertex.glsl",
	        fragmentShader: "WigglyGraphite-5347acf0-a8e2-47b6-8346-30c70719d763/WigglyGraphite-5347acf0-a8e2-47b6-8346-30c70719d763-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0
	    },
	    "Wire" : {
	        uniforms: {
	            u_SceneLight_0_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_SceneLight_1_matrix: { value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
	            u_fogColor: { value: new Vector3(0.0196, 0.0196, 0.0196) },
	            u_fogDensity: { value: 0 }
	        },
	        vertexShader: "Wire-4391385a-cf83-4396-9e33-31e4e4930b27/Wire-4391385a-cf83-4396-9e33-31e4e4930b27-v10.0-vertex.glsl",
	        fragmentShader: "Wire-4391385a-cf83-4396-9e33-31e4e4930b27/Wire-4391385a-cf83-4396-9e33-31e4e4930b27-v10.0-fragment.glsl",
	        side: 2,
	        transparent: false,
	        depthFunc: 2,
	        depthWrite: true,
	        depthTest: true,
	        blending: 0,
	    },
	};

	/*!
	 * three-tiltloader
	 * https://github.com/icosa-gallery/three-tiltloader
	 * Copyright (c) 2021-2022 Icosa Gallery
	 * Released under the Apache 2.0 Licence.
	 */

	// Adapted from initial TiltLoader implementation in three.js r128

	class TiltLoader extends Loader {
		constructor(manager) {
			super(manager);
			this.tiltShaderLoader = new TiltShaderLoader(manager);
		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;

			const loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
			loader.setWithCredentials( this.withCredentials );

			loader.load( url, function ( buffer ) {

				try {

					onLoad( scope.parse( buffer ) );

				} catch ( e ) {

					if ( onError ) {

						onError( e );

					} else {

						console.error( e );

					}

					scope.manager.itemError( url );

				}

			}, onProgress, onError );

		}

		async parse( buffer ) {

			const group = new Group();
			// https://docs.google.com/document/d/11ZsHozYn9FnWG7y3s3WAyKIACfbfwb4PbaS8cZ_xjvo/edit#

			const zip = unzipSync( new Uint8Array( buffer.slice( 16 ) ) );

			/*
			const thumbnail = zip[ 'thumbnail.png' ].buffer;
			const img = document.createElement( 'img' );
			img.src = URL.createObjectURL( new Blob( [ thumbnail ] ) );
			document.body.appendChild( img );
			*/

			const metadata = JSON.parse( strFromU8( zip[ 'metadata.json' ] ) );

			/*
			const blob = new Blob( [ zip[ 'data.sketch' ].buffer ], { type: 'application/octet-stream' } );
			window.open( URL.createObjectURL( blob ) );
			*/

			const data = new DataView( zip[ 'data.sketch' ].buffer );

			const num_strokes = data.getInt32( 16, true );

			const brushes = {};

			let offset = 20;

			for ( let i = 0; i < num_strokes; i ++ ) {

				const brush_index = data.getInt32( offset, true );

				const brush_color = [
					data.getFloat32( offset + 4, true ),
					data.getFloat32( offset + 8, true ),
					data.getFloat32( offset + 12, true ),
					data.getFloat32( offset + 16, true )
				];
				const brush_size = data.getFloat32( offset + 20, true );
				const stroke_mask = data.getUint32( offset + 24, true );
				const controlpoint_mask = data.getUint32( offset + 28, true );

				let offset_stroke_mask = 0;
				let offset_controlpoint_mask = 0;

				for ( let j = 0; j < 4; j ++ ) {

					// TOFIX: I don't understand these masks yet

					const byte = 1 << j;
					if ( ( stroke_mask & byte ) > 0 ) offset_stroke_mask += 4;
					if ( ( controlpoint_mask & byte ) > 0 ) offset_controlpoint_mask += 4;

				}

				// console.log( { brush_index, brush_color, brush_size, stroke_mask, controlpoint_mask } );
				// console.log( offset_stroke_mask, offset_controlpoint_mask );

				offset = offset + 28 + offset_stroke_mask + 4; // TOFIX: This is wrong

				const num_control_points = data.getInt32( offset, true );

				// console.log( { num_control_points } );

				const positions = new Float32Array( num_control_points * 3 );
				const quaternions = new Float32Array( num_control_points * 4 );

				offset = offset + 4;

				for ( let j = 0, k = 0; j < positions.length; j += 3, k += 4 ) {

					positions[ j + 0 ] = data.getFloat32( offset + 0, true );
					positions[ j + 1 ] = data.getFloat32( offset + 4, true );
					positions[ j + 2 ] = data.getFloat32( offset + 8, true );

					quaternions[ k + 0 ] = data.getFloat32( offset + 12, true );
					quaternions[ k + 1 ] = data.getFloat32( offset + 16, true );
					quaternions[ k + 2 ] = data.getFloat32( offset + 20, true );
					quaternions[ k + 3 ] = data.getFloat32( offset + 24, true );

					offset = offset + 28 + offset_controlpoint_mask; // TOFIX: This is wrong

				}

				if ( brush_index in brushes === false ) {

					brushes[ brush_index ] = [];

				}

				brushes[ brush_index ].push( [ positions, quaternions, brush_size, brush_color ] );

			}

			const clock = new Clock();

			for ( const brush_index in brushes ) {

				const geometry = new StrokeGeometry( brushes[ brush_index ] );
				const materialName = this.tiltShaderLoader.lookupMaterialName(metadata.BrushIndex[ brush_index ]);

				const material = await this.tiltShaderLoader.loadAsync(materialName);
				const mesh = new Mesh( geometry, material );

				mesh.onBeforeRender = (renderer, scene, camera, geometry, material, group) => {
					if(material.uniforms["u_time"]) {
						const elapsedTime = clock.getElapsedTime();
						// _Time from https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html
	                	const time = new Vector4(elapsedTime/20, elapsedTime, elapsedTime*2, elapsedTime*3);

						material.uniforms["u_time"].value = time;
					}

					if (material.uniforms["cameraPosition"]) {
	                    material.uniforms["cameraPosition"].value = camera.position;
	                }
				};

				group.add( mesh );
			}

			return group;

		}

		setBrushPath(path) {
			// Quick repair of path if required
			if (path.slice(path.length - 1) !== "/") {
				path += "/";
			}

			this.tiltShaderLoader.setPath(path);
		}

	}

	class StrokeGeometry extends BufferGeometry {

		constructor( strokes ) {

			super();

			const vertices = [];
			const colors = [];
			const uvs = [];

			const position = new Vector3();
			const prevPosition = new Vector3();

			const quaternion = new Quaternion();
			const prevQuaternion = new Quaternion();

			const vector1 = new Vector3();
			const vector2 = new Vector3();
			const vector3 = new Vector3();
			const vector4 = new Vector3();

			// size = size / 2;

			for ( const k in strokes ) {

				const stroke = strokes[ k ];
				const positions = stroke[ 0 ];
				const quaternions = stroke[ 1 ];
				const size = stroke[ 2 ];
				const color = stroke[ 3 ];

				prevPosition.fromArray( positions, 0 );
				prevQuaternion.fromArray( quaternions, 0 );

				for ( let i = 3, j = 4, l = positions.length; i < l; i += 3, j += 4 ) {

					position.fromArray( positions, i );
					quaternion.fromArray( quaternions, j );

					vector1.set( - size, 0, 0 );
					vector1.applyQuaternion( quaternion );
					vector1.add( position );

					vector2.set( size, 0, 0 );
					vector2.applyQuaternion( quaternion );
					vector2.add( position );

					vector3.set( size, 0, 0 );
					vector3.applyQuaternion( prevQuaternion );
					vector3.add( prevPosition );

					vector4.set( - size, 0, 0 );
					vector4.applyQuaternion( prevQuaternion );
					vector4.add( prevPosition );

					vertices.push( vector1.x, vector1.y, - vector1.z, 1 );
					vertices.push( vector2.x, vector2.y, - vector2.z, 1 );
					vertices.push( vector4.x, vector4.y, - vector4.z, 1 );

					vertices.push( vector2.x, vector2.y, - vector2.z, 1 );
					vertices.push( vector3.x, vector3.y, - vector3.z, 1 );
					vertices.push( vector4.x, vector4.y, - vector4.z, 1 );

					prevPosition.copy( position );
					prevQuaternion.copy( quaternion );

					colors.push( ...color );
					colors.push( ...color );
					colors.push( ...color );

					colors.push( ...color );
					colors.push( ...color );
					colors.push( ...color );

					const p1 = i / l;
					const p2 = ( i - 3 ) / l;

					uvs.push( p1, 0 );
					uvs.push( p1, 1 );
					uvs.push( p2, 0 );

					uvs.push( p1, 1 );
					uvs.push( p2, 1 );
					uvs.push( p2, 0 );

				}

			}

			this.setAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 4 ) );
			this.setAttribute( 'color', new BufferAttribute( new Float32Array( colors ), 4 ) );
			this.setAttribute( 'uv', new BufferAttribute( new Float32Array( uvs ), 2 ) );

			this.setAttribute('a_position', this.getAttribute('position'));
			this.setAttribute('a_color', this.getAttribute('color'));
			this.setAttribute("a_texcoord0", this.getAttribute("uv"));
			//this.setAttribute("_tb_unity_texcoord_0", this.getAttribute("uv"));
		}

	}

	function styleInject(css, ref) {
	  if ( ref === void 0 ) ref = {};
	  var insertAt = ref.insertAt;

	  if (!css || typeof document === 'undefined') { return; }

	  var head = document.head || document.getElementsByTagName('head')[0];
	  var style = document.createElement('style');
	  style.type = 'text/css';

	  if (insertAt === 'top') {
	    if (head.firstChild) {
	      head.insertBefore(style, head.firstChild);
	    } else {
	      head.appendChild(style);
	    }
	  } else {
	    head.appendChild(style);
	  }

	  if (style.styleSheet) {
	    style.styleSheet.cssText = css;
	  } else {
	    style.appendChild(document.createTextNode(css));
	  }
	}

	var css_248z = "#icosa-viewer {\n  margin: 0;\n  height: 100%; }\n\n#c {\n  width: 100%;\n  height: 100%;\n  display: block;\n  cursor: grab; }\n\n#c.grabbed {\n  cursor: grabbing; }\n\n.control-panel {\n  display: block;\n  opacity: 1;\n  position: absolute;\n  right: 12px;\n  bottom: 12px;\n  border: 0;\n  z-index: 5;\n  color: white; }\n\n.panel-button {\n  border: 0;\n  padding: 0;\n  cursor: pointer;\n  display: block;\n  width: 24px;\n  height: 24px;\n  outline: none;\n  overflow: hidden;\n  position: relative; }\n\n.fullscreen-button {\n  background: url(\"data:image/svg+xml,%3Csvg xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 height%3D%2224px%22 viewBox%3D%220 0 24 24%22 width%3D%2224px%22 fill%3D%22%23FFFFFF%22%3E%3Cpath d%3D%22M0 0h24v24H0V0z%22 fill%3D%22none%22%2F%3E%3Cpath d%3D%22M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z%22%2F%3E%3C%2Fsvg%3E\"); }\n\n.fullscreen-button.fullscreen {\n  background: url(\"data:image/svg+xml,%3Csvg xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 height%3D%2224px%22 viewBox%3D%220 0 24 24%22 width%3D%2224px%22 fill%3D%22%23FFFFFF%22%3E%3Cpath d%3D%22M0 0h24v24H0V0z%22 fill%3D%22none%22%2F%3E%3Cpath d%3D%22M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z%22%2F%3E%3C%2Fsvg%3E\"); }\n\n#loadscreen {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  background-color: #1d222e;\n  z-index: 5;\n  opacity: 1;\n  transition: 1s opacity; }\n\n#loadscreen.fade-out {\n  opacity: 0; }\n\n#loadscreen.loaded {\n  z-index: -5; }\n\n.loadlogo {\n  width: 256px;\n  height: 256px;\n  margin: 0;\n  display: inline-block;\n  background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAGAAAAAEACAYAAACJyVIoAAAgAElEQVR4XuzdCZhdVZUv8P/a595bqSQkgQAqqAg4oDhjCyi8joIMDt22drQVRUSkFUUGbSZFCwdmQgRRiQgRZbIUFFSQtjWOjEEgkBDIPFZSc9Wdzzl7vW+f4Q5F6KfPQKrq/O/3KVCpVJ39O3udYQ9rCfihAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClDgHxaQf/gn8AdQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABSgAFgBgJ6AABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKbAcBFgDYDoj8ERSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABFgBgH6AABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKbAcBFgDYDoj8ERSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABFgBgH6AABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKbAcBFgDYDoj8ERSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABFgBgH6AABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKbAcBFgDYDoj8ERSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABFgBgH6AABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKbAcBFgDYDoj8ERSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABFgBgH6AABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKbAcBFgDYDoj8ERSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABFgBgH6AABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKbAcBFgDYDoj8ERSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABFgBgH6AABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKbAcBFgDYDoj8ERSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABFgBgH6AABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEAB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2dG20UzxHvJ/0jEQSIhAc/z3j7aNDhL/CbnzNBOBmc9/8n8nukdQACDBt3/VD1aljt16rOns7NQJZqDpCCRSgPhP5G2n0QhEAsQ/HQGB5AoQ/8m997QcAeKfPoBAcgVWrVqVOvZY5v+S2wNoeZIFiP+VIlf6AAAKX0lEQVQk333annQBG/93HXusEdb/kt4VaH8SBVatSgnxn8Q7T5sRECH+6QUIJFcgiv+7jHQK+/+S2wtoeXIFUrYcoAjxn9wuQMsTLJDq7Oxk/3+COwBNT7QA8Z/o20/jEy5A/Ce8A9D85ArY/b93bWX9P7k9gJYnWYD4T/Ldp+1JFyD+k94DaH+SBYj/JN992p50AeI/6T2A9idZgPhP8t2n7UkXIP6T3gNof5IFyP+T5LtP25MuQPwnvQeIUACAPoAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAwPMgQAGA5wGRX4EAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAUA6AMIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCDwPAhQAeB4Q+RUIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCFAAgD6AAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggMDzIEABgOcBkV+BAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAAFAOgDCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgg8DwIUAHgeEPkVCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAghQAIA+gAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIDA8yBAAYDnAZFfgQACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAABQDoAwgggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIPA8CFAB4HhD5FQgggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIUACAPoAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAwPMgQAGA5wGRX4EAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAUA6AMIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCDwPAhQAeB4Q+RUIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCFAAgD6AAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggMDzIEABgOcBkV+BAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAAFAOgDCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgg8DwIUAHgeEPkVCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgj8fw1fSd0/eeqEAAAAAElFTkSuQmCC\");\n  animation: load-anim 1s steps(24) infinite; }\n\n@keyframes load-anim {\n  100% {\n    background-position: -6144px; } }\n";
	styleInject(css_248z);

	/*!
	 * hold-event
	 * https://github.com/yomotsu/hold-event
	 * (c) 2020 @yomotsu
	 * Released under the MIT License.
	 */
	var HOLD_EVENT_TYPE;
	(function (HOLD_EVENT_TYPE) {
	    HOLD_EVENT_TYPE["HOLD_START"] = "holdStart";
	    HOLD_EVENT_TYPE["HOLD_END"] = "holdEnd";
	    HOLD_EVENT_TYPE["HOLDING"] = "holding";
	})(HOLD_EVENT_TYPE || (HOLD_EVENT_TYPE = {}));

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics = function(d, b) {
	    extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics(d, b);
	};

	function __extends(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var EventDispatcher = (function () {
	    function EventDispatcher() {
	        this._listeners = {};
	    }
	    EventDispatcher.prototype.addEventListener = function (type, listener) {
	        var listeners = this._listeners;
	        if (listeners[type] === undefined)
	            listeners[type] = [];
	        if (listeners[type].indexOf(listener) === -1)
	            listeners[type].push(listener);
	    };
	    EventDispatcher.prototype.removeEventListener = function (type, listener) {
	        var listeners = this._listeners;
	        var listenerArray = listeners[type];
	        if (listenerArray !== undefined) {
	            var index = listenerArray.indexOf(listener);
	            if (index !== -1)
	                listenerArray.splice(index, 1);
	        }
	    };
	    EventDispatcher.prototype.dispatchEvent = function (event) {
	        var listeners = this._listeners;
	        var listenerArray = listeners[event.type];
	        if (listenerArray !== undefined) {
	            event.target = this;
	            var array = listenerArray.slice(0);
	            for (var i = 0, l = array.length; i < l; i++) {
	                array[i].call(this, event);
	            }
	        }
	    };
	    return EventDispatcher;
	}());

	var Hold = (function (_super) {
	    __extends(Hold, _super);
	    function Hold(holdIntervalDelay) {
	        if (holdIntervalDelay === void 0) { holdIntervalDelay = 100; }
	        var _this = _super.call(this) || this;
	        _this.holdIntervalDelay = 100;
	        _this._enabled = true;
	        _this._holding = false;
	        _this._intervalId = -1;
	        _this._deltaTime = 0;
	        _this._elapsedTime = 0;
	        _this._lastTime = 0;
	        _this._holdStart = function (event) {
	            if (!_this._enabled)
	                return;
	            if (_this._holding)
	                return;
	            _this._deltaTime = 0;
	            _this._elapsedTime = 0;
	            _this._lastTime = performance.now();
	            _this.dispatchEvent({
	                type: HOLD_EVENT_TYPE.HOLD_START,
	                deltaTime: _this._deltaTime,
	                elapsedTime: _this._elapsedTime,
	                originalEvent: event,
	            });
	            _this._holding = true;
	            _this._intervalId = window.setInterval(function () {
	                var now = performance.now();
	                _this._deltaTime = now - _this._lastTime;
	                _this._elapsedTime += _this._deltaTime;
	                _this._lastTime = performance.now();
	                _this.dispatchEvent({
	                    type: HOLD_EVENT_TYPE.HOLDING,
	                    deltaTime: _this._deltaTime,
	                    elapsedTime: _this._elapsedTime,
	                });
	            }, _this.holdIntervalDelay);
	        };
	        _this._holdEnd = function (event) {
	            if (!_this._enabled)
	                return;
	            if (!_this._holding)
	                return;
	            var now = performance.now();
	            _this._deltaTime = now - _this._lastTime;
	            _this._elapsedTime += _this._deltaTime;
	            _this._lastTime = performance.now();
	            _this.dispatchEvent({
	                type: HOLD_EVENT_TYPE.HOLD_END,
	                deltaTime: _this._deltaTime,
	                elapsedTime: _this._elapsedTime,
	                originalEvent: event,
	            });
	            window.clearInterval(_this._intervalId);
	            _this._holding = false;
	        };
	        _this.holdIntervalDelay = holdIntervalDelay;
	        return _this;
	    }
	    Object.defineProperty(Hold.prototype, "enabled", {
	        get: function () {
	            return this._enabled;
	        },
	        set: function (enabled) {
	            if (this._enabled === enabled)
	                return;
	            this._enabled = enabled;
	            if (!this._enabled)
	                this._holdEnd();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Hold;
	}(EventDispatcher));

	((function (_super) {
	    __extends(ElementHold, _super);
	    function ElementHold(element, holdIntervalDelay) {
	        if (holdIntervalDelay === void 0) { holdIntervalDelay = 100; }
	        var _this = _super.call(this, holdIntervalDelay) || this;
	        _this._holdStart = _this._holdStart.bind(_this);
	        _this._holdEnd = _this._holdEnd.bind(_this);
	        var onPointerDown = _this._holdStart;
	        var onPointerUp = _this._holdEnd;
	        element.addEventListener('mousedown', onPointerDown);
	        document.addEventListener('mouseup', onPointerUp);
	        window.addEventListener('blur', _this._holdEnd);
	        return _this;
	    }
	    return ElementHold;
	})(Hold));

	var KeyboardKeyHold = (function (_super) {
	    __extends(KeyboardKeyHold, _super);
	    function KeyboardKeyHold(keyCode, holdIntervalDelay) {
	        if (holdIntervalDelay === void 0) { holdIntervalDelay = 100; }
	        var _this = _super.call(this, holdIntervalDelay) || this;
	        _this._holdStart = _this._holdStart.bind(_this);
	        _this._holdEnd = _this._holdEnd.bind(_this);
	        var onKeydown = function (event) {
	            if (isInputEvent(event))
	                return;
	            if (event.keyCode !== keyCode)
	                return;
	            _this._holdStart(event);
	        };
	        var onKeyup = function (event) {
	            if (event.keyCode !== keyCode)
	                return;
	            _this._holdEnd(event);
	        };
	        document.addEventListener('keydown', onKeydown);
	        document.addEventListener('keyup', onKeyup);
	        window.addEventListener('blur', _this._holdEnd);
	        return _this;
	    }
	    return KeyboardKeyHold;
	}(Hold));
	function isInputEvent(event) {
	    var target = event.target;
	    return (target.tagName === 'INPUT' ||
	        target.tagName === 'SELECT' ||
	        target.tagName === 'TEXTAREA' ||
	        target.isContentEditable);
	}

	function setupNavigation(cameraControls) {
	    const KEYCODE = {
	        W: 87,
	        A: 65,
	        S: 83,
	        D: 68,
	        Q: 81,
	        E: 69,
	        ARROW_LEFT: 37,
	        ARROW_UP: 38,
	        ARROW_RIGHT: 39,
	        ARROW_DOWN: 40,
	    };
	    const wKey = new KeyboardKeyHold(KEYCODE.W, 1);
	    const aKey = new KeyboardKeyHold(KEYCODE.A, 1);
	    const sKey = new KeyboardKeyHold(KEYCODE.S, 1);
	    const dKey = new KeyboardKeyHold(KEYCODE.D, 1);
	    const qKey = new KeyboardKeyHold(KEYCODE.Q, 1);
	    const eKey = new KeyboardKeyHold(KEYCODE.E, 1);
	    aKey.addEventListener('holding', function (event) { cameraControls.truck(-0.01 * (event === null || event === void 0 ? void 0 : event.deltaTime), 0, true); });
	    dKey.addEventListener('holding', function (event) { cameraControls.truck(0.01 * (event === null || event === void 0 ? void 0 : event.deltaTime), 0, true); });
	    wKey.addEventListener('holding', function (event) { cameraControls.forward(0.01 * (event === null || event === void 0 ? void 0 : event.deltaTime), true); });
	    sKey.addEventListener('holding', function (event) { cameraControls.forward(-0.01 * (event === null || event === void 0 ? void 0 : event.deltaTime), true); });
	    qKey.addEventListener('holding', function (event) { cameraControls.truck(0, 0.01 * (event === null || event === void 0 ? void 0 : event.deltaTime), true); });
	    eKey.addEventListener('holding', function (event) { cameraControls.truck(0, -0.01 * (event === null || event === void 0 ? void 0 : event.deltaTime), true); });
	    const leftKey = new KeyboardKeyHold(KEYCODE.ARROW_LEFT, 1);
	    const rightKey = new KeyboardKeyHold(KEYCODE.ARROW_RIGHT, 1);
	    const upKey = new KeyboardKeyHold(KEYCODE.ARROW_UP, 1);
	    const downKey = new KeyboardKeyHold(KEYCODE.ARROW_DOWN, 1);
	    leftKey.addEventListener('holding', function (event) { cameraControls.rotate(0.1 * MathUtils.DEG2RAD * (event === null || event === void 0 ? void 0 : event.deltaTime), 0, true); });
	    rightKey.addEventListener('holding', function (event) { cameraControls.rotate(-0.1 * MathUtils.DEG2RAD * (event === null || event === void 0 ? void 0 : event.deltaTime), 0, true); });
	    upKey.addEventListener('holding', function (event) { cameraControls.rotate(0, -0.05 * MathUtils.DEG2RAD * (event === null || event === void 0 ? void 0 : event.deltaTime), true); });
	    downKey.addEventListener('holding', function (event) { cameraControls.rotate(0, 0.05 * MathUtils.DEG2RAD * (event === null || event === void 0 ? void 0 : event.deltaTime), true); });
	}

	const subsetOfTHREE = {
	    MOUSE: MOUSE,
	    Vector2: Vector2,
	    Vector3: Vector3,
	    Vector4: Vector4,
	    Quaternion: Quaternion,
	    Matrix4: Matrix4,
	    Spherical: Spherical,
	    Box3: Box3,
	    Sphere: Sphere,
	    Raycaster: Raycaster,
	    MathUtils: {
	        DEG2RAD: MathUtils.DEG2RAD,
	        clamp: MathUtils.clamp,
	    },
	};

	// Adapted from original GLTF 1.0 Loader in three.js r86

	class LegacyGLTFLoader extends Loader {


	    load ( url, onLoad, onProgress, onError ) {

	        var scope = this;

	        var resourcePath;

	        if ( this.resourcePath !== '' ) {

	            resourcePath = this.resourcePath;

	        } else if ( this.path !== '' ) {

	            resourcePath = this.path;

	        } else {

	            resourcePath = LoaderUtils.extractUrlBase( url );

	        }

	        var loader = new FileLoader( scope.manager );

	        loader.setPath( this.path );
	        loader.setResponseType( 'arraybuffer' );

	        loader.load( url, function ( data ) {

	            scope.parse( data, resourcePath, onLoad );

	        }, onProgress, onError );

	    }

	    parse ( data, path, callback ) {

	        var content;
	        var extensions = {};

	        var magic = LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

	        if ( magic === BINARY_EXTENSION_HEADER_DEFAULTS.magic ) {

	            extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );
	            content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

	        } else {

	            content = LoaderUtils.decodeText( new Uint8Array( data ) );

	        }

	        var json = JSON.parse( content );

	        if ( json.extensionsUsed && json.extensionsUsed.indexOf( EXTENSIONS.KHR_MATERIALS_COMMON ) >= 0 ) {

	            extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] = new GLTFMaterialsCommonExtension( json );

	        }

	        var parser = new GLTFParser( json, extensions, {

	            crossOrigin: this.crossOrigin,
	            manager: this.manager,
	            path: path || this.resourcePath || ''

	        } );

	        parser.parse( function ( scene, scenes, cameras, animations ) {

	            var glTF = {
	                "scene": scene,
	                "scenes": scenes,
	                "cameras": cameras,
	                "animations": animations
	            };

	            callback( glTF );

	        } );
	    }
	}

	function GLTFRegistry() {

	    var objects = {};

	    return	{

	        get: function ( key ) {

	            return objects[ key ];

	        },

	        add: function ( key, object ) {

	            objects[ key ] = object;

	        },

	        remove: function ( key ) {

	            delete objects[ key ];

	        },

	        removeAll: function () {

	            objects = {};

	        },

	        update: function ( scene, camera ) {

	            for ( var name in objects ) {

	                var object = objects[ name ];

	                if ( object.update ) {

	                    object.update( scene, camera );

	                }

	            }

	        }

	    };

	}

	class GLTFShader {
	    constructor ( targetNode, allNodes ) {

	        var boundUniforms = {};

	        // bind each uniform to its source node

	        var uniforms = targetNode.material.uniforms;

	        for ( var uniformId in uniforms ) {

	            var uniform = uniforms[ uniformId ];

	            if ( uniform.semantic ) {

	                var sourceNodeRef = uniform.node;

	                var sourceNode = targetNode;

	                if ( sourceNodeRef ) {

	                    sourceNode = allNodes[ sourceNodeRef ];

	                }

	                boundUniforms[ uniformId ] = {
	                    semantic: uniform.semantic,
	                    sourceNode: sourceNode,
	                    targetNode: targetNode,
	                    uniform: uniform
	                };

	            }

	        }

	        this.boundUniforms = boundUniforms;
	        this._m4 = new Matrix4();
	    }

	    update ( scene, camera ) {

			var boundUniforms = this.boundUniforms;

			for ( var name in boundUniforms ) {

				var boundUniform = boundUniforms[ name ];

				switch ( boundUniform.semantic ) {

					case "MODELVIEW":

						var m4 = boundUniform.uniform.value;
						m4.multiplyMatrices( camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld );
						break;

					case "MODELVIEWINVERSETRANSPOSE":

						var m3 = boundUniform.uniform.value;
						this._m4.multiplyMatrices( camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld );
						m3.getNormalMatrix( this._m4 );
						break;

					case "PROJECTION":

						var m4 = boundUniform.uniform.value;
						m4.copy( camera.projectionMatrix );
						break;

					case "JOINTMATRIX":

						var m4v = boundUniform.uniform.value;

						for ( var mi = 0; mi < m4v.length; mi ++ ) {

							// So it goes like this:
							// SkinnedMesh world matrix is already baked into MODELVIEW;
							// transform joints to local space,
							// then transform using joint's inverse
							m4v[ mi ]
								.getInverse( boundUniform.sourceNode.matrixWorld )
								.multiply( boundUniform.targetNode.skeleton.bones[ mi ].matrixWorld )
								.multiply( boundUniform.targetNode.skeleton.boneInverses[ mi ] )
								.multiply( boundUniform.targetNode.bindMatrix );

						}

						break;

					default :

						console.warn( "Unhandled shader semantic: " + boundUniform.semantic );
						break;

				}

			}
	    }


	}

	var EXTENSIONS = {
	    KHR_BINARY_GLTF: 'KHR_binary_glTF',
	    KHR_MATERIALS_COMMON: 'KHR_materials_common'
	};

	function GLTFMaterialsCommonExtension( json ) {

	    this.name = EXTENSIONS.KHR_MATERIALS_COMMON;

	    this.lights = {};

	    var extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] ) || {};
	    var lights = extension.lights || {};

	    for ( var lightId in lights ) {

	        var light = lights[ lightId ];
	        var lightNode;

	        var lightParams = light[ light.type ];
	        var color = new Color().fromArray( lightParams.color );

	        switch ( light.type ) {

	            case "directional":
	                lightNode = new DirectionalLight( color );
	                lightNode.position.set( 0, 0, 1 );
	                break;

	            case "point":
	                lightNode = new PointLight( color );
	                break;

	            case "spot":
	                lightNode = new SpotLight( color );
	                lightNode.position.set( 0, 0, 1 );
	                break;

	            case "ambient":
	                lightNode = new AmbientLight( color );
	                break;

	        }

	        if ( lightNode ) {

	            this.lights[ lightId ] = lightNode;

	        }

	    }
	}

	var BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';

	var BINARY_EXTENSION_HEADER_DEFAULTS = { magic: 'glTF', version: 1, contentFormat: 0 };

	var BINARY_EXTENSION_HEADER_LENGTH = 20;

	class GLTFBinaryExtension {
	    constructor( data ) {

	        this.name = EXTENSIONS.KHR_BINARY_GLTF;

	        var headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

	        var header = {
	            magic: LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
	            version: headerView.getUint32( 4, true ),
	            length: headerView.getUint32( 8, true ),
	            contentLength: headerView.getUint32( 12, true ),
	            contentFormat: headerView.getUint32( 16, true )
	        };

	        for ( var key in BINARY_EXTENSION_HEADER_DEFAULTS ) {

	            var value = BINARY_EXTENSION_HEADER_DEFAULTS[ key ];

	            if ( header[ key ] !== value ) {

	                throw new Error( 'Unsupported glTF-Binary header: Expected "%s" to be "%s".', key, value );

	            }

	        }

	        var contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH, header.contentLength );

	        this.header = header;
	        this.content = LoaderUtils.decodeText( contentArray );
	        this.body = data.slice( BINARY_EXTENSION_HEADER_LENGTH + header.contentLength, header.length );
	    }

	    loadShader ( shader, bufferViews ) {

			var bufferView = bufferViews[ shader.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].bufferView ];
			var array = new Uint8Array( bufferView );

			return LoaderUtils.decodeText( array );

		};
	}

	var WEBGL_CONSTANTS = {
	    FLOAT: 5126,
	    //FLOAT_MAT2: 35674,
	    FLOAT_MAT3: 35675,
	    FLOAT_MAT4: 35676,
	    FLOAT_VEC2: 35664,
	    FLOAT_VEC3: 35665,
	    FLOAT_VEC4: 35666,
	    LINEAR: 9729,
	    REPEAT: 10497,
	    SAMPLER_2D: 35678,
	    TRIANGLES: 4,
	    LINES: 1,
	    UNSIGNED_BYTE: 5121,
	    UNSIGNED_SHORT: 5123,

	    VERTEX_SHADER: 35633,
	    FRAGMENT_SHADER: 35632
	};

	var WEBGL_TYPE = {
	    5126: Number,
	    //35674: Matrix2,
	    35675: Matrix3,
	    35676: Matrix4,
	    35664: Vector2,
	    35665: Vector3,
	    35666: Vector4,
	    35678: Texture
	};

	var WEBGL_COMPONENT_TYPES = {
	    5120: Int8Array,
	    5121: Uint8Array,
	    5122: Int16Array,
	    5123: Uint16Array,
	    5125: Uint32Array,
	    5126: Float32Array
	};

	var WEBGL_FILTERS = {
	    9728: NearestFilter,
	    9729: LinearFilter,
	    9984: NearestMipmapNearestFilter,
	    9985: LinearMipmapNearestFilter,
	    9986: NearestMipmapLinearFilter,
	    9987: LinearMipmapLinearFilter
	};

	var WEBGL_WRAPPINGS = {
	    33071: ClampToEdgeWrapping,
	    33648: MirroredRepeatWrapping,
	    10497: RepeatWrapping
	};

	var WEBGL_TEXTURE_FORMATS = {
	    6406: AlphaFormat,
	    6407: RGBFormat,
	    6408: RGBAFormat,
	    6409: LuminanceFormat,
	    6410: LuminanceAlphaFormat
	};

	var WEBGL_TEXTURE_DATATYPES = {
	    5121: UnsignedByteType,
	    32819: UnsignedShort4444Type,
	    32820: UnsignedShort5551Type
	};

	var WEBGL_SIDES = {
	    1028: BackSide, // Culling front
	    1029: FrontSide // Culling back
	    //1032: NoSide   // Culling front and back, what to do?
	};

	var WEBGL_DEPTH_FUNCS = {
	    512: NeverDepth,
	    513: LessDepth,
	    514: EqualDepth,
	    515: LessEqualDepth,
	    516: GreaterEqualDepth,
	    517: NotEqualDepth,
	    518: GreaterEqualDepth,
	    519: AlwaysDepth
	};

	var WEBGL_BLEND_EQUATIONS = {
	    32774: AddEquation,
	    32778: SubtractEquation,
	    32779: ReverseSubtractEquation
	};

	var WEBGL_BLEND_FUNCS = {
	    0: ZeroFactor,
	    1: OneFactor,
	    768: SrcColorFactor,
	    769: OneMinusSrcColorFactor,
	    770: SrcAlphaFactor,
	    771: OneMinusSrcAlphaFactor,
	    772: DstAlphaFactor,
	    773: OneMinusDstAlphaFactor,
	    774: DstColorFactor,
	    775: OneMinusDstColorFactor,
	    776: SrcAlphaSaturateFactor
	    // The followings are not supported by js yet
	    //32769: CONSTANT_COLOR,
	    //32770: ONE_MINUS_CONSTANT_COLOR,
	    //32771: CONSTANT_ALPHA,
	    //32772: ONE_MINUS_CONSTANT_COLOR
	};

	var WEBGL_TYPE_SIZES = {
	    'SCALAR': 1,
	    'VEC2': 2,
	    'VEC3': 3,
	    'VEC4': 4,
	    'MAT2': 4,
	    'MAT3': 9,
	    'MAT4': 16
	};

	var PATH_PROPERTIES = {
	    scale: 'scale',
	    translation: 'position',
	    rotation: 'quaternion'
	};

	var INTERPOLATION = {
	    LINEAR: InterpolateLinear,
	    STEP: InterpolateDiscrete
	};

	var STATES_ENABLES = {
	    2884: 'CULL_FACE',
	    2929: 'DEPTH_TEST',
	    3042: 'BLEND',
	    3089: 'SCISSOR_TEST',
	    32823: 'POLYGON_OFFSET_FILL',
	    32926: 'SAMPLE_ALPHA_TO_COVERAGE'
	};

	function _each( object, callback, thisObj ) {

	    if ( ! object ) {

	        return Promise.resolve();

	    }

	    var results;
	    var fns = [];

	    if ( Object.prototype.toString.call( object ) === '[object Array]' ) {

	        results = [];

	        var length = object.length;

	        for ( var idx = 0; idx < length; idx ++ ) {

	            var value = callback.call( thisObj || this, object[ idx ], idx );

	            if ( value ) {

	                fns.push( value );

	                if ( value instanceof Promise ) {

	                    value.then( function ( key, value ) {

	                        results[ key ] = value;

	                    }.bind( this, idx ) );

	                } else {

	                    results[ idx ] = value;

	                }

	            }

	        }

	    } else {

	        results = {};

	        for ( var key in object ) {

	            if ( object.hasOwnProperty( key ) ) {

	                var value = callback.call( thisObj || this, object[ key ], key );

	                if ( value ) {

	                    fns.push( value );

	                    if ( value instanceof Promise ) {

	                        value.then( function ( key, value ) {

	                            results[ key ] = value;

	                        }.bind( this, key ) );

	                    } else {

	                        results[ key ] = value;

	                    }

	                }

	            }

	        }

	    }

	    return Promise.all( fns ).then( function () {

	        return results;

	    } );

	}

	function resolveURL( url, path ) {

	    // Invalid URL
	    if ( typeof url !== 'string' || url === '' )
	        return '';

	    // Absolute URL http://,https://,//
	    if ( /^(https?:)?\/\//i.test( url ) ) {

	        return url;

	    }

	    // Data URI
	    if ( /^data:.*,.*$/i.test( url ) ) {

	        return url;

	    }

	    // Blob URL
	    if ( /^blob:.*$/i.test( url ) ) {

	        return url;

	    }

	    // Relative URL
	    return ( path || '' ) + url;

	}

	// js seems too dependent on attribute names so globally
	// replace those in the shader code
	function replaceTHREEShaderAttributes( shaderText, technique ) {

	    // Expected technique attributes
	    var attributes = {};

	    for ( var attributeId in technique.attributes ) {

	        var pname = technique.attributes[ attributeId ];

	        var param = technique.parameters[ pname ];
	        var atype = param.type;
	        var semantic = param.semantic;

	        attributes[ attributeId ] = {
	            type: atype,
	            semantic: semantic
	        };

	    }

	    // Figure out which attributes to change in technique

	    var shaderParams = technique.parameters;
	    var shaderAttributes = technique.attributes;
	    var params = {};

	    for ( var attributeId in attributes ) {

	        var pname = shaderAttributes[ attributeId ];
	        var shaderParam = shaderParams[ pname ];
	        var semantic = shaderParam.semantic;
	        if ( semantic ) {

	            params[ attributeId ] = shaderParam;

	        }

	    }

	    for ( var pname in params ) {

	        var param = params[ pname ];
	        var semantic = param.semantic;

	        var regEx = new RegExp( "\\b" + pname + "\\b", "g" );

	        switch ( semantic ) {

	            case "POSITION":

	                shaderText = shaderText.replace( regEx, 'position' );
	                break;

	            case "NORMAL":

	                shaderText = shaderText.replace( regEx, 'normal' );
	                break;

	            case 'TEXCOORD_0':
	            case 'TEXCOORD0':
	            case 'TEXCOORD':

	                shaderText = shaderText.replace( regEx, 'uv' );
	                break;

	            case 'TEXCOORD_1':

	                shaderText = shaderText.replace( regEx, 'uv2' );
	                break;

	            case 'COLOR_0':
	            case 'COLOR0':
	            case 'COLOR':

	                shaderText = shaderText.replace( regEx, 'color' );
	                break;

	            case "WEIGHT":

	                shaderText = shaderText.replace( regEx, 'skinWeight' );
	                break;

	            case "JOINT":

	                shaderText = shaderText.replace( regEx, 'skinIndex' );
	                break;

	        }

	    }

	    return shaderText;

	}

	function createDefaultMaterial() {

	    return new MeshPhongMaterial( {
	        color: 0x00000,
	        emissive: 0x888888,
	        specular: 0x000000,
	        shininess: 0,
	        transparent: false,
	        depthTest: true,
	        side: FrontSide
	    } );

	}

	class DeferredShaderMaterial {
	    constructor( params ) {
	        this.isDeferredShaderMaterial = true;

	        this.params = params;
	    }

	    create() {

	        var uniforms = UniformsUtils.clone( this.params.uniforms );

	        for ( var uniformId in this.params.uniforms ) {

	            var originalUniform = this.params.uniforms[ uniformId ];

	            if ( originalUniform.value instanceof Texture ) {

	                uniforms[ uniformId ].value = originalUniform.value;
	                uniforms[ uniformId ].value.needsUpdate = true;

	            }

	            uniforms[ uniformId ].semantic = originalUniform.semantic;
	            uniforms[ uniformId ].node = originalUniform.node;

	        }

	        this.params.uniforms = uniforms;

	        return new RawShaderMaterial( this.params );
	    }
	}

	class GLTFParser {
	    constructor( json, extensions, options ) {
	        this.json = json || {};
	        this.extensions = extensions || {};
	        this.options = options || {};

	        // loader object cache
	        this.cache = new GLTFRegistry();
	    }

	    _withDependencies( dependencies ) {

			var _dependencies = {};

			for ( var i = 0; i < dependencies.length; i ++ ) {

				var dependency = dependencies[ i ];
				var fnName = "load" + dependency.charAt( 0 ).toUpperCase() + dependency.slice( 1 );

				var cached = this.cache.get( dependency );

				if ( cached !== undefined ) {

					_dependencies[ dependency ] = cached;

				} else if ( this[ fnName ] ) {

					var fn = this[ fnName ]();
					this.cache.add( dependency, fn );

					_dependencies[ dependency ] = fn;

				}

			}

			return _each( _dependencies, function ( dependency ) {

				return dependency;

			} );

		};

		parse( callback ) {

			var json = this.json;

			// Clear the loader cache
			this.cache.removeAll();

			// Fire the callback on complete
			this._withDependencies( [

				"scenes",
				"cameras",
				"animations"

			] ).then( function ( dependencies ) {

				var scenes = [];

				for ( var name in dependencies.scenes ) {

					scenes.push( dependencies.scenes[ name ] );

				}

				var scene = json.scene !== undefined ? dependencies.scenes[ json.scene ] : scenes[ 0 ];

				var cameras = [];

				for ( var name in dependencies.cameras ) {

					var camera = dependencies.cameras[ name ];
					cameras.push( camera );

				}

				var animations = [];

				for ( var name in dependencies.animations ) {

					animations.push( dependencies.animations[ name ] );

				}

				callback( scene, scenes, cameras, animations );

			} );

		};

		loadShaders() {

			var json = this.json;
			var extensions = this.extensions;
			var options = this.options;

			return this._withDependencies( [

				"bufferViews"

			] ).then( function ( dependencies ) {

				return _each( json.shaders, function ( shader ) {

					if ( shader.extensions && shader.extensions[ EXTENSIONS.KHR_BINARY_GLTF ] ) {

						return extensions[ EXTENSIONS.KHR_BINARY_GLTF ].loadShader( shader, dependencies.bufferViews );

					}

					return new Promise( function ( resolve ) {

						var loader = new FileLoader( options.manager );
						loader.setResponseType( 'text' );
						loader.load( resolveURL( shader.uri, options.path ), function ( shaderText ) {

							resolve( shaderText );

						} );

					} );

				} );

			} );

		};

		loadBuffers() {
			var json = this.json;
			var extensions = this.extensions;
			var options = this.options;

			return _each( json.buffers, function ( buffer, name ) {

				if ( name === BINARY_EXTENSION_BUFFER_NAME ) {

					return extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body;

				}

				if ( buffer.type === 'arraybuffer' || buffer.type === undefined ) {

					return new Promise( function ( resolve ) {

						var loader = new FileLoader( options.manager );
						loader.setResponseType( 'arraybuffer' );
						loader.load( resolveURL( buffer.uri, options.path ), function ( buffer ) {

							resolve( buffer );

						} );

					} );

				} else {

					console.warn( 'THREE.LegacyGLTFLoader: ' + buffer.type + ' buffer type is not supported' );

				}

			} );

		};

		loadBufferViews() {

			var json = this.json;

			return this._withDependencies( [

				"buffers"

			] ).then( function ( dependencies ) {

				return _each( json.bufferViews, function ( bufferView ) {

					var arraybuffer = dependencies.buffers[ bufferView.buffer ];

					var byteLength = bufferView.byteLength !== undefined ? bufferView.byteLength : 0;

					return arraybuffer.slice( bufferView.byteOffset, bufferView.byteOffset + byteLength );

				} );

			} );

		};

		loadAccessors() {

			var json = this.json;

			return this._withDependencies( [

				"bufferViews"

			] ).then( function ( dependencies ) {

				return _each( json.accessors, function ( accessor ) {

					var arraybuffer = dependencies.bufferViews[ accessor.bufferView ];
					var itemSize = WEBGL_TYPE_SIZES[ accessor.type ];
					var TypedArray = WEBGL_COMPONENT_TYPES[ accessor.componentType ];

					// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
					var elementBytes = TypedArray.BYTES_PER_ELEMENT;
					var itemBytes = elementBytes * itemSize;

					// The buffer is not interleaved if the stride is the item size in bytes.
					if ( accessor.byteStride && accessor.byteStride !== itemBytes ) {

						// Use the full buffer if it's interleaved.
						var array = new TypedArray( arraybuffer );

						// Integer parameters to IB/IBA are in array elements, not bytes.
						var ib = new InterleavedBuffer( array, accessor.byteStride / elementBytes );

						return new InterleavedBufferAttribute( ib, itemSize, accessor.byteOffset / elementBytes );

					} else {

						array = new TypedArray( arraybuffer, accessor.byteOffset, accessor.count * itemSize );

						return new BufferAttribute( array, itemSize );

					}

				} );

			} );

		};

		loadTextures() {

			var json = this.json;
			var options = this.options;

			return this._withDependencies( [

				"bufferViews"

			] ).then( function ( dependencies ) {

				return _each( json.textures, function ( texture ) {

					if ( texture.source ) {

						return new Promise( function ( resolve ) {

							var source = json.images[ texture.source ];
							var sourceUri = source.uri;
							var isObjectURL = false;

							if ( source.extensions && source.extensions[ EXTENSIONS.KHR_BINARY_GLTF ] ) {

								var metadata = source.extensions[ EXTENSIONS.KHR_BINARY_GLTF ];
								var bufferView = dependencies.bufferViews[ metadata.bufferView ];
								var blob = new Blob( [ bufferView ], { type: metadata.mimeType } );
								sourceUri = URL.createObjectURL( blob );
								isObjectURL = true;

							}

							var textureLoader = options.manager.getHandler( sourceUri );

							if ( textureLoader === null ) {

								textureLoader = new TextureLoader( options.manager );

							}

							textureLoader.setCrossOrigin( options.crossOrigin );

							textureLoader.load( resolveURL( sourceUri, options.path ), function ( _texture ) {

								if ( isObjectURL ) URL.revokeObjectURL( sourceUri );

								_texture.flipY = false;

								if ( texture.name !== undefined ) _texture.name = texture.name;

								_texture.format = texture.format !== undefined ? WEBGL_TEXTURE_FORMATS[ texture.format ] : RGBAFormat;

								if ( texture.internalFormat !== undefined && _texture.format !== WEBGL_TEXTURE_FORMATS[ texture.internalFormat ] ) {

									console.warn( 'THREE.LegacyGLTFLoader: Three.js doesn\'t support texture internalFormat which is different from texture format. ' +
																'internalFormat will be forced to be the same value as format.' );

								}

								_texture.type = texture.type !== undefined ? WEBGL_TEXTURE_DATATYPES[ texture.type ] : UnsignedByteType;

								if ( texture.sampler ) {

									var sampler = json.samplers[ texture.sampler ];

									_texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
									_texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || NearestMipmapLinearFilter;
									_texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
									_texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;

								}

								resolve( _texture );

							}, undefined, function () {

								if ( isObjectURL ) URL.revokeObjectURL( sourceUri );

								resolve();

							} );

						} );

					}

				} );

			} );

		};

	    loadMaterials() {

			var json = this.json;

			return this._withDependencies( [

				"shaders",
				"textures"

			] ).then( function ( dependencies ) {

				return _each( json.materials, function ( material ) {

					var materialType;
					var materialValues = {};
					var materialParams = {};

					var khr_material;

					if ( material.extensions && material.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] ) {

						khr_material = material.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ];

					}

					if ( khr_material ) {

						// don't copy over unused values to avoid material warning spam
						var keys = [ 'ambient', 'emission', 'transparent', 'transparency', 'doubleSided' ];

						switch ( khr_material.technique ) {

							case 'BLINN' :
							case 'PHONG' :
								materialType = MeshPhongMaterial;
								keys.push( 'diffuse', 'specular', 'shininess' );
								break;

							case 'LAMBERT' :
								materialType = MeshLambertMaterial;
								keys.push( 'diffuse' );
								break;

							case 'CONSTANT' :
							default :
								materialType = MeshBasicMaterial;
								break;

						}

						keys.forEach( function ( v ) {

							if ( khr_material.values[ v ] !== undefined ) materialValues[ v ] = khr_material.values[ v ];

						} );

						if ( khr_material.doubleSided || materialValues.doubleSided ) {

							materialParams.side = DoubleSide;

						}

						if ( khr_material.transparent || materialValues.transparent ) {

							materialParams.transparent = true;
							materialParams.opacity = ( materialValues.transparency !== undefined ) ? materialValues.transparency : 1;

						}

					} else if ( material.technique === undefined ) {

						materialType = MeshPhongMaterial;

						Object.assign( materialValues, material.values );

					} else {

						materialType = DeferredShaderMaterial;

						var technique = json.techniques[ material.technique ];

						materialParams.uniforms = {};

						var program = json.programs[ technique.program ];

						if ( program ) {

							materialParams.fragmentShader = dependencies.shaders[ program.fragmentShader ];

							if ( ! materialParams.fragmentShader ) {

								console.warn( "ERROR: Missing fragment shader definition:", program.fragmentShader );
								materialType = MeshPhongMaterial;

							}

							var vertexShader = dependencies.shaders[ program.vertexShader ];

							if ( ! vertexShader ) {

								console.warn( "ERROR: Missing vertex shader definition:", program.vertexShader );
								materialType = MeshPhongMaterial;

							}

							// IMPORTANT: FIX VERTEX SHADER ATTRIBUTE DEFINITIONS
							materialParams.vertexShader = replaceTHREEShaderAttributes( vertexShader, technique );

							var uniforms = technique.uniforms;

							for ( var uniformId in uniforms ) {

								var pname = uniforms[ uniformId ];
								var shaderParam = technique.parameters[ pname ];

								var ptype = shaderParam.type;

								if ( WEBGL_TYPE[ ptype ] ) {

									var pcount = shaderParam.count;
									var value;

									if ( material.values !== undefined ) value = material.values[ pname ];

									var uvalue = new WEBGL_TYPE[ ptype ]();
									var usemantic = shaderParam.semantic;
									var unode = shaderParam.node;

									switch ( ptype ) {

										case WEBGL_CONSTANTS.FLOAT:

											uvalue = shaderParam.value;

											if ( pname == "transparency" ) {

												materialParams.transparent = true;

											}

											if ( value !== undefined ) {

												uvalue = value;

											}

											break;

										case WEBGL_CONSTANTS.FLOAT_VEC2:
										case WEBGL_CONSTANTS.FLOAT_VEC3:
										case WEBGL_CONSTANTS.FLOAT_VEC4:
										case WEBGL_CONSTANTS.FLOAT_MAT3:

											if ( shaderParam && shaderParam.value ) {

												uvalue.fromArray( shaderParam.value );

											}

											if ( value ) {

												uvalue.fromArray( value );

											}

											break;

										case WEBGL_CONSTANTS.FLOAT_MAT2:

											// what to do?
											console.warn( "FLOAT_MAT2 is not a supported uniform type" );
											break;

										case WEBGL_CONSTANTS.FLOAT_MAT4:

											if ( pcount ) {

												uvalue = new Array( pcount );

												for ( var mi = 0; mi < pcount; mi ++ ) {

													uvalue[ mi ] = new WEBGL_TYPE[ ptype ]();

												}

												if ( shaderParam && shaderParam.value ) {

													var m4v = shaderParam.value;
													uvalue.fromArray( m4v );

												}

												if ( value ) {

													uvalue.fromArray( value );

												}

											} else {

												if ( shaderParam && shaderParam.value ) {

													var m4 = shaderParam.value;
													uvalue.fromArray( m4 );

												}

												if ( value ) {

													uvalue.fromArray( value );

												}

											}

											break;

										case WEBGL_CONSTANTS.SAMPLER_2D:

											if ( value !== undefined ) {

												uvalue = dependencies.textures[ value ];

											} else if ( shaderParam.value !== undefined ) {

												uvalue = dependencies.textures[ shaderParam.value ];

											} else {

												uvalue = null;

											}

											break;

									}

									materialParams.uniforms[ uniformId ] = {
										value: uvalue,
										semantic: usemantic,
										node: unode
									};

								} else {

									throw new Error( "Unknown shader uniform param type: " + ptype );

								}

							}

							var states = technique.states || {};
							var enables = states.enable || [];
							var functions = states.functions || {};

							var enableCullFace = false;
							var enableDepthTest = false;
							var enableBlend = false;

							for ( var i = 0, il = enables.length; i < il; i ++ ) {

								var enable = enables[ i ];

								switch ( STATES_ENABLES[ enable ] ) {

									case 'CULL_FACE':

										enableCullFace = true;

										break;

									case 'DEPTH_TEST':

										enableDepthTest = true;

										break;

									case 'BLEND':

										enableBlend = true;

										break;

									// TODO: implement
									case 'SCISSOR_TEST':
									case 'POLYGON_OFFSET_FILL':
									case 'SAMPLE_ALPHA_TO_COVERAGE':

										break;

									default:

										throw new Error( "Unknown technique.states.enable: " + enable );

								}

							}

							if ( enableCullFace ) {

								materialParams.side = functions.cullFace !== undefined ? WEBGL_SIDES[ functions.cullFace ] : FrontSide;

							} else {

								materialParams.side = DoubleSide;

							}

							materialParams.depthTest = enableDepthTest;
							materialParams.depthFunc = functions.depthFunc !== undefined ? WEBGL_DEPTH_FUNCS[ functions.depthFunc ] : LessDepth;
							materialParams.depthWrite = functions.depthMask !== undefined ? functions.depthMask[ 0 ] : true;

							materialParams.blending = enableBlend ? CustomBlending : NoBlending;
							materialParams.transparent = enableBlend;

							var blendEquationSeparate = functions.blendEquationSeparate;

							if ( blendEquationSeparate !== undefined ) {

								materialParams.blendEquation = WEBGL_BLEND_EQUATIONS[ blendEquationSeparate[ 0 ] ];
								materialParams.blendEquationAlpha = WEBGL_BLEND_EQUATIONS[ blendEquationSeparate[ 1 ] ];

							} else {

								materialParams.blendEquation = AddEquation;
								materialParams.blendEquationAlpha = AddEquation;

							}

							var blendFuncSeparate = functions.blendFuncSeparate;

							if ( blendFuncSeparate !== undefined ) {

								materialParams.blendSrc = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 0 ] ];
								materialParams.blendDst = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 1 ] ];
								materialParams.blendSrcAlpha = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 2 ] ];
								materialParams.blendDstAlpha = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 3 ] ];

							} else {

								materialParams.blendSrc = OneFactor;
								materialParams.blendDst = ZeroFactor;
								materialParams.blendSrcAlpha = OneFactor;
								materialParams.blendDstAlpha = ZeroFactor;

							}

						}

					}

					if ( Array.isArray( materialValues.diffuse ) ) {

						materialParams.color = new Color().fromArray( materialValues.diffuse );

					} else if ( typeof ( materialValues.diffuse ) === 'string' ) {

						materialParams.map = dependencies.textures[ materialValues.diffuse ];

					}

					delete materialParams.diffuse;

					if ( typeof ( materialValues.reflective ) === 'string' ) {

						materialParams.envMap = dependencies.textures[ materialValues.reflective ];

					}

					if ( typeof ( materialValues.bump ) === 'string' ) {

						materialParams.bumpMap = dependencies.textures[ materialValues.bump ];

					}

					if ( Array.isArray( materialValues.emission ) ) {

						if ( materialType === MeshBasicMaterial ) {

							materialParams.color = new Color().fromArray( materialValues.emission );

						} else {

							materialParams.emissive = new Color().fromArray( materialValues.emission );

						}

					} else if ( typeof ( materialValues.emission ) === 'string' ) {

						if ( materialType === MeshBasicMaterial ) {

							materialParams.map = dependencies.textures[ materialValues.emission ];

						} else {

							materialParams.emissiveMap = dependencies.textures[ materialValues.emission ];

						}

					}

					if ( Array.isArray( materialValues.specular ) ) {

						materialParams.specular = new Color().fromArray( materialValues.specular );

					} else if ( typeof ( materialValues.specular ) === 'string' ) {

						materialParams.specularMap = dependencies.textures[ materialValues.specular ];

					}

					if ( materialValues.shininess !== undefined ) {

						materialParams.shininess = materialValues.shininess;

					}

					var _material = new materialType( materialParams );
					if ( material.name !== undefined ) _material.name = material.name;

					return _material;

				} );

			} );

		};

		loadMeshes() {

			var json = this.json;

			return this._withDependencies( [

				"accessors",
				"materials"

			] ).then( function ( dependencies ) {

				return _each( json.meshes, function ( mesh ) {

					var group = new Group();
					if ( mesh.name !== undefined ) group.name = mesh.name;

					if ( mesh.extras ) group.userData = mesh.extras;

					var primitives = mesh.primitives || [];

					for ( var name in primitives ) {

						var primitive = primitives[ name ];

						if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === undefined ) {

							var geometry = new BufferGeometry();

							var attributes = primitive.attributes;

							for ( var attributeId in attributes ) {

								var attributeEntry = attributes[ attributeId ];

								if ( ! attributeEntry ) return;

								var bufferAttribute = dependencies.accessors[ attributeEntry ];

								switch ( attributeId ) {

									case 'POSITION':
										geometry.setAttribute( 'position', bufferAttribute );
										break;

									case 'NORMAL':
										geometry.setAttribute( 'normal', bufferAttribute );
										break;

									case 'TEXCOORD_0':
									case 'TEXCOORD0':
									case 'TEXCOORD':
										geometry.setAttribute( 'uv', bufferAttribute );
										break;

									case 'TEXCOORD_1':
										geometry.setAttribute( 'uv2', bufferAttribute );
										break;

									case 'COLOR_0':
									case 'COLOR0':
									case 'COLOR':
										geometry.setAttribute( 'color', bufferAttribute );
										break;

									case 'WEIGHT':
										geometry.setAttribute( 'skinWeight', bufferAttribute );
										break;

									case 'JOINT':
										geometry.setAttribute( 'skinIndex', bufferAttribute );
										break;

									default:

										if ( ! primitive.material ) break;

										var material = json.materials[ primitive.material ];

										if ( ! material.technique ) break;

										var parameters = json.techniques[ material.technique ].parameters || {};

										for ( var attributeName in parameters ) {

											if ( parameters[ attributeName ][ 'semantic' ] === attributeId ) {

												geometry.setAttribute( attributeName, bufferAttribute );

											}

										}

								}

							}

							if ( primitive.indices ) {

								geometry.setIndex( dependencies.accessors[ primitive.indices ] );

							}

							var material = dependencies.materials !== undefined ? dependencies.materials[ primitive.material ] : createDefaultMaterial();

							var meshNode = new Mesh( geometry, material );
							meshNode.castShadow = true;
							meshNode.name = ( name === "0" ? group.name : group.name + name );

							if ( primitive.extras ) meshNode.userData = primitive.extras;

							group.add( meshNode );

						} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

							var geometry = new BufferGeometry();

							var attributes = primitive.attributes;

							for ( var attributeId in attributes ) {

								var attributeEntry = attributes[ attributeId ];

								if ( ! attributeEntry ) return;

								var bufferAttribute = dependencies.accessors[ attributeEntry ];

								switch ( attributeId ) {

									case 'POSITION':
										geometry.setAttribute( 'position', bufferAttribute );
										break;

									case 'COLOR_0':
									case 'COLOR0':
									case 'COLOR':
										geometry.setAttribute( 'color', bufferAttribute );
										break;

								}

							}

							var material = dependencies.materials[ primitive.material ];

							var meshNode;

							if ( primitive.indices ) {

								geometry.setIndex( dependencies.accessors[ primitive.indices ] );

								meshNode = new LineSegments( geometry, material );

							} else {

								meshNode = new Line( geometry, material );

							}

							meshNode.name = ( name === "0" ? group.name : group.name + name );

							if ( primitive.extras ) meshNode.userData = primitive.extras;

							group.add( meshNode );

						} else {

							console.warn( "Only triangular and line primitives are supported" );

						}

					}

					return group;

				} );

			} );

		};

		loadCameras() {

			var json = this.json;

			return _each( json.cameras, function ( camera ) {

				if ( camera.type == "perspective" && camera.perspective ) {

					var yfov = camera.perspective.yfov;
					var aspectRatio = camera.perspective.aspectRatio !== undefined ? camera.perspective.aspectRatio : 1;

					// According to COLLADA spec...
					// aspectRatio = xfov / yfov
					var xfov = yfov * aspectRatio;

					var _camera = new PerspectiveCamera( MathUtils.radToDeg( xfov ), aspectRatio, camera.perspective.znear || 1, camera.perspective.zfar || 2e6 );
					if ( camera.name !== undefined ) _camera.name = camera.name;

					if ( camera.extras ) _camera.userData = camera.extras;

					return _camera;

				} else if ( camera.type == "orthographic" && camera.orthographic ) {

					var _camera = new OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, camera.orthographic.znear, camera.orthographic.zfar );
					if ( camera.name !== undefined ) _camera.name = camera.name;

					if ( camera.extras ) _camera.userData = camera.extras;

					return _camera;

				}

			} );

		};

		loadSkins() {

			var json = this.json;

			return this._withDependencies( [

				"accessors"

			] ).then( function ( dependencies ) {

				return _each( json.skins, function ( skin ) {

					var bindShapeMatrix = new Matrix4();

					if ( skin.bindShapeMatrix !== undefined ) bindShapeMatrix.fromArray( skin.bindShapeMatrix );

					var _skin = {
						bindShapeMatrix: bindShapeMatrix,
						jointNames: skin.jointNames,
						inverseBindMatrices: dependencies.accessors[ skin.inverseBindMatrices ]
					};

					return _skin;

				} );

			} );

		};

		loadAnimations() {

			var json = this.json;

			return this._withDependencies( [

				"accessors",
				"nodes"

			] ).then( function ( dependencies ) {

				return _each( json.animations, function ( animation, animationId ) {

					var tracks = [];

					for ( var channelId in animation.channels ) {

						var channel = animation.channels[ channelId ];
						var sampler = animation.samplers[ channel.sampler ];

						if ( sampler ) {

							var target = channel.target;
							var name = target.id;
							var input = animation.parameters !== undefined ? animation.parameters[ sampler.input ] : sampler.input;
							var output = animation.parameters !== undefined ? animation.parameters[ sampler.output ] : sampler.output;

							var inputAccessor = dependencies.accessors[ input ];
							var outputAccessor = dependencies.accessors[ output ];

							var node = dependencies.nodes[ name ];

							if ( node ) {

								node.updateMatrix();
								node.matrixAutoUpdate = true;

								var TypedKeyframeTrack = PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.rotation
									? QuaternionKeyframeTrack
									: VectorKeyframeTrack;

								var targetName = node.name ? node.name : node.uuid;
								var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;

								// KeyframeTrack.optimize() will modify given 'times' and 'values'
								// buffers before creating a truncated copy to keep. Because buffers may
								// be reused by other tracks, make copies here.
								tracks.push( new TypedKeyframeTrack(
									targetName + '.' + PATH_PROPERTIES[ target.path ],
									AnimationUtils.arraySlice( inputAccessor.array, 0 ),
									AnimationUtils.arraySlice( outputAccessor.array, 0 ),
									interpolation
								) );

							}

						}

					}

					var name = animation.name !== undefined ? animation.name : "animation_" + animationId;

					return new AnimationClip( name, undefined, tracks );

				} );

			} );

		};

		loadNodes() {

			var json = this.json;
			var extensions = this.extensions;
			var scope = this;

			return _each( json.nodes, function ( node ) {

				var matrix = new Matrix4();

				var _node;

				if ( node.jointName ) {

					_node = new Bone();
					_node.name = node.name !== undefined ? node.name : node.jointName;
					_node.jointName = node.jointName;

				} else {

					_node = new Object3D();
					if ( node.name !== undefined ) _node.name = node.name;

				}

				if ( node.extras ) _node.userData = node.extras;

				if ( node.matrix !== undefined ) {

					matrix.fromArray( node.matrix );
					_node.applyMatrix4( matrix );

				} else {

					if ( node.translation !== undefined ) {

						_node.position.fromArray( node.translation );

					}

					if ( node.rotation !== undefined ) {

						_node.quaternion.fromArray( node.rotation );

					}

					if ( node.scale !== undefined ) {

						_node.scale.fromArray( node.scale );

					}

				}

				return _node;

			} ).then( function ( __nodes ) {

				return scope._withDependencies( [

					"meshes",
					"skins",
					"cameras"

				] ).then( function ( dependencies ) {

					return _each( __nodes, function ( _node, nodeId ) {

						var node = json.nodes[ nodeId ];

						if ( node.meshes !== undefined ) {

							for ( var meshId in node.meshes ) {

								var mesh = node.meshes[ meshId ];
								var group = dependencies.meshes[ mesh ];

								if ( group === undefined ) {

									console.warn( 'LegacyGLTFLoader: Couldn\'t find node "' + mesh + '".' );
									continue;

								}

								for ( var childrenId in group.children ) {

									var child = group.children[ childrenId ];

									// clone Mesh to add to _node

									var originalMaterial = child.material;
									var originalGeometry = child.geometry;
									var originalUserData = child.userData;
									var originalName = child.name;

									var material;

									if ( originalMaterial.isDeferredShaderMaterial ) {

										originalMaterial = material = originalMaterial.create();

									} else {

										material = originalMaterial;

									}

									switch ( child.type ) {

										case 'LineSegments':
											child = new LineSegments( originalGeometry, material );
											break;

										case 'LineLoop':
											child = new LineLoop( originalGeometry, material );
											break;

										case 'Line':
											child = new Line( originalGeometry, material );
											break;

										default:
											child = new Mesh( originalGeometry, material );

									}

									child.castShadow = true;
									child.userData = originalUserData;
									child.name = originalName;

									var skinEntry;

									if ( node.skin ) {

										skinEntry = dependencies.skins[ node.skin ];

									}

									// Replace Mesh with SkinnedMesh in library
									if ( skinEntry ) {

										var getJointNode = function ( jointId ) {

											var keys = Object.keys( __nodes );

											for ( var i = 0, il = keys.length; i < il; i ++ ) {

												var n = __nodes[ keys[ i ] ];

												if ( n.jointName === jointId ) return n;

											}

											return null;

										};

										var geometry = originalGeometry;
										var material = originalMaterial;
										material.skinning = true;

										child = new SkinnedMesh( geometry, material );
										child.castShadow = true;
										child.userData = originalUserData;
										child.name = originalName;

										var bones = [];
										var boneInverses = [];

										for ( var i = 0, l = skinEntry.jointNames.length; i < l; i ++ ) {

											var jointId = skinEntry.jointNames[ i ];
											var jointNode = getJointNode( jointId );

											if ( jointNode ) {

												bones.push( jointNode );

												var m = skinEntry.inverseBindMatrices.array;
												var mat = new Matrix4().fromArray( m, i * 16 );
												boneInverses.push( mat );

											} else {

												console.warn( "WARNING: joint: '" + jointId + "' could not be found" );

											}

										}

										child.bind( new Skeleton( bones, boneInverses ), skinEntry.bindShapeMatrix );

										var buildBoneGraph = function ( parentJson, parentObject, property ) {

											var children = parentJson[ property ];

											if ( children === undefined ) return;

											for ( var i = 0, il = children.length; i < il; i ++ ) {

												var nodeId = children[ i ];
												var bone = __nodes[ nodeId ];
												var boneJson = json.nodes[ nodeId ];

												if ( bone !== undefined && bone.isBone === true && boneJson !== undefined ) {

													parentObject.add( bone );
													buildBoneGraph( boneJson, bone, 'children' );

												}

											}

										};

										buildBoneGraph( node, child, 'skeletons' );

									}

									_node.add( child );

								}

							}

						}

						if ( node.camera !== undefined ) {

							var camera = dependencies.cameras[ node.camera ];

							_node.add( camera );

						}

						if ( node.extensions
								 && node.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ]
								 && node.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ].light ) {

							var extensionLights = extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ].lights;
							var light = extensionLights[ node.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ].light ];

							_node.add( light );

						}

						return _node;

					} );

				} );

			} );

		};

		loadScenes() {

			var json = this.json;

			// scene node hierachy builder

			function buildNodeHierachy( nodeId, parentObject, allNodes ) {

				var _node = allNodes[ nodeId ];
				parentObject.add( _node );

				var node = json.nodes[ nodeId ];

				if ( node.children ) {

					var children = node.children;

					for ( var i = 0, l = children.length; i < l; i ++ ) {

						var child = children[ i ];
						buildNodeHierachy( child, _node, allNodes );

					}

				}

			}

			return this._withDependencies( [

				"nodes"

			] ).then( function ( dependencies ) {

				return _each( json.scenes, function ( scene ) {

					var _scene = new Scene();
					if ( scene.name !== undefined ) _scene.name = scene.name;

					if ( scene.extras ) _scene.userData = scene.extras;

					var nodes = scene.nodes || [];

					for ( var i = 0, l = nodes.length; i < l; i ++ ) {

						var nodeId = nodes[ i ];
						buildNodeHierachy( nodeId, _scene, dependencies.nodes );

					}

					_scene.traverse( function ( child ) {

						// Register raw material meshes with LegacyGLTFLoader.Shaders
						if ( child.material && child.material.isRawShaderMaterial ) {

							child.gltfShader = new GLTFShader( child, dependencies.nodes );
							child.onBeforeRender = function ( renderer, scene, camera ) {

								this.gltfShader.update( scene, camera );

							};

						}

					} );

					return _scene;

				} );

			} );

		};
	}

	function replaceBrushMaterials(brushPath, model) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const tiltShaderLoader = new TiltShaderLoader$1(DefaultLoadingManager);
	        tiltShaderLoader.setPath(brushPath);
	        const clock = new Clock();
	        model.traverse((object) => __awaiter(this, void 0, void 0, function* () {
	            if (object.type === "Mesh") {
	                const mesh = object;
	                var shader;
	                const targetFilter = "brush_" + mesh.name.split('_')[1];
	                switch (targetFilter) {
	                    case "brush_BlocksBasic":
	                        mesh.geometry.name = "geometry_BlocksBasic";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        shader = yield tiltShaderLoader.loadAsync("BlocksBasic");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_BlocksBasic";
	                        break;
	                    case "brush_BlocksGem":
	                        mesh.geometry.name = "geometry_BlocksGem";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        shader = yield tiltShaderLoader.loadAsync("BlocksGem");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_BlocksGem";
	                        break;
	                    case "brush_BlocksGlass":
	                        mesh.geometry.name = "geometry_BlocksGlass";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        shader = yield tiltShaderLoader.loadAsync("BlocksGlass");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_BlocksGlass";
	                        break;
	                    case "brush_Bubbles":
	                        mesh.geometry.name = "geometry_Bubbles";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("uv2"));
	                        shader = yield tiltShaderLoader.loadAsync("Bubbles");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Bubbles";
	                        break;
	                    case "brush_CelVinyl":
	                        mesh.geometry.name = "geometry_CelVinyl";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("CelVinyl");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_CelVinyl";
	                        break;
	                    case "brush_ChromaticWave":
	                        mesh.geometry.name = "geometry_ChromaticWave";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("ChromaticWave");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_ChromaticWave";
	                        break;
	                    case "brush_CoarseBristles":
	                        mesh.geometry.name = "geometry_CoarseBristles";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("CoarseBristles");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_CoarseBristles";
	                        break;
	                    case "brush_Comet":
	                        mesh.geometry.name = "geometry_Comet";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Comet");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Comet";
	                        break;
	                    case "brush_DiamondHull":
	                        mesh.geometry.name = "geometry_DiamondHull";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("DiamondHull");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_DiamondHull";
	                        break;
	                    case "brush_Disco":
	                        mesh.geometry.name = "geometry_Disco";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Disco");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Disco";
	                        break;
	                    case "brush_DotMarker":
	                        mesh.geometry.name = "geometry_DotMarker";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("DotMarker");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_DotMarker";
	                        break;
	                    case "brush_Dots":
	                        mesh.geometry.name = "geometry_Dots";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("uv2"));
	                        shader = yield tiltShaderLoader.loadAsync("Dots");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Dots";
	                        break;
	                    case "brush_DoubleTaperedFlat":
	                        mesh.geometry.name = "geometry_DoubleTaperedFlat";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("DoubleTaperedFlat");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_DoubleTaperedFlat";
	                        break;
	                    case "brush_DoubleTaperedMarker":
	                        mesh.geometry.name = "geometry_DoubleTaperedMarker";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("DoubleTaperedMarker");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_DoubleTaperedMarker";
	                        break;
	                    case "brush_DuctTape":
	                        mesh.geometry.name = "geometry_DuctTape";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("DuctTape");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_DuctTape";
	                        break;
	                    case "brush_Electricity":
	                        mesh.geometry.name = "geometry_Electricity";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("uv2"));
	                        shader = yield tiltShaderLoader.loadAsync("Electricity");
	                        mesh.material = shader;
	                        mesh.material.name = "material_Electricity";
	                        break;
	                    case "brush_Embers":
	                        mesh.geometry.name = "geometry_Embers";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("uv2"));
	                        shader = yield tiltShaderLoader.loadAsync("Embers");
	                        mesh.material = shader;
	                        mesh.material.name = "material_Embers";
	                        break;
	                    case "brush_EnvironmentDiffuse":
	                        mesh.geometry.name = "geometry_EnvironmentDiffuse";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("EnvironmentDiffuse");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_EnvironmentDiffuse";
	                        break;
	                    case "brush_EnvironmentDiffuseLightMap":
	                        mesh.geometry.name = "geometry_EnvironmentDiffuseLightMap";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("EnvironmentDiffuseLightMap");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_EnvironmentDiffuseLightMap";
	                        break;
	                    case "brush_Fire":
	                        mesh.geometry.name = "geometry_Fire";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Fire");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Fire";
	                        break;
	                    case "brush_Flat":
	                        mesh.geometry.name = "geometry_Flat";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Flat");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Flat";
	                        break;
	                    case "brush_FlatDeprecated":
	                        mesh.geometry.name = "geometry_FlatDeprecated";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("FlatDeprecated");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_FlatDeprecated";
	                        break;
	                    case "brush_Highlighter":
	                        mesh.geometry.name = "geometry_Highlighter";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Highlighter");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Highlighter";
	                        break;
	                    case "brush_Hypercolor":
	                        mesh.geometry.name = "geometry_Hypercolor";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Hypercolor");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Hypercolor";
	                        break;
	                    case "brush_HyperGrid":
	                        mesh.geometry.name = "geometry_HyperGrid";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("uv2"));
	                        shader = yield tiltShaderLoader.loadAsync("HyperGrid");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_HyperGrid";
	                        break;
	                    case "brush_Icing":
	                        mesh.geometry.name = "geometry_Icing";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Icing");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Icing";
	                        break;
	                    case "brush_Ink":
	                        mesh.geometry.name = "geometry_Ink";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Ink");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Ink";
	                        break;
	                    case "brush_Leaves":
	                        mesh.geometry.name = "geometry_Leaves";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Leaves");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Leaves";
	                        break;
	                    case "brush_Light":
	                        mesh.geometry.name = "geometry_Light";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Light");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Light";
	                        break;
	                    case "brush_LightWire":
	                        mesh.geometry.name = "geometry_LightWire";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("LightWire");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_LightWire";
	                        break;
	                    case "brush_Lofted":
	                        mesh.geometry.name = "geometry_Lofted";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Lofted");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Lofted";
	                        break;
	                    case "brush_Marker":
	                        mesh.geometry.name = "geometry_Marker";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Marker");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Marker";
	                        break;
	                    case "brush_MatteHull":
	                        mesh.geometry.name = "geometry_MatteHull";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        shader = yield tiltShaderLoader.loadAsync("MatteHull");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_MatteHull";
	                        break;
	                    case "brush_NeonPulse":
	                        mesh.geometry.name = "geometry_NeonPulse";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("NeonPulse");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_NeonPulse";
	                        break;
	                    case "brush_OilPaint":
	                        mesh.geometry.name = "geometry_OilPaint";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("OilPaint");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_OilPaint";
	                        break;
	                    case "brush_Paper":
	                        mesh.geometry.name = "geometry_Paper";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Paper");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Paper";
	                        break;
	                    case "brush_PbrTemplate":
	                        mesh.geometry.name = "geometry_PbrTemplate";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("PbrTemplate");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_PbrTemplate";
	                        break;
	                    case "brush_PbrTransparentTemplate":
	                        mesh.geometry.name = "geometry_PbrTransparentTemplate";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("PbrTransparentTemplate");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_PbrTransparentTemplate";
	                        break;
	                    case "brush_Petal":
	                        mesh.geometry.name = "geometry_Petal";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Petal");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Petal";
	                        break;
	                    case "brush_Plasma":
	                        mesh.geometry.name = "geometry_Plasma";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Plasma");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Plasma";
	                        break;
	                    case "brush_Rainbow":
	                        mesh.geometry.name = "geometry_Rainbow";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Rainbow");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Rainbow";
	                        break;
	                    case "brush_ShinyHull":
	                        mesh.geometry.name = "geometry_ShinyHull";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("ShinyHull");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_ShinyHull";
	                        break;
	                    case "brush_Smoke":
	                        mesh.geometry.name = "geometry_Smoke";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("uv2"));
	                        shader = yield tiltShaderLoader.loadAsync("Smoke");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Smoke";
	                        break;
	                    case "brush_Snow":
	                        mesh.geometry.name = "geometry_Snow";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("uv2"));
	                        shader = yield tiltShaderLoader.loadAsync("Snow");
	                        mesh.material = shader;
	                        mesh.material.name = "material_Snow";
	                        break;
	                    case "brush_SoftHighlighter":
	                        mesh.geometry.name = "geometry_SoftHighlighter";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("SoftHighlighter");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_SoftHighlighter";
	                        break;
	                    case "brush_Spikes":
	                        mesh.geometry.name = "geometry_Spikes";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Spikes");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Spikes";
	                        break;
	                    case "brush_Splatter":
	                        mesh.geometry.name = "geometry_Splatter";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Splatter");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Splatter";
	                        break;
	                    case "brush_Stars":
	                        mesh.geometry.name = "geometry_Stars";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        mesh.geometry.setAttribute("a_texcoord1", mesh.geometry.getAttribute("uv2"));
	                        shader = yield tiltShaderLoader.loadAsync("Stars");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Stars";
	                        break;
	                    case "brush_Streamers":
	                        mesh.geometry.name = "geometry_Streamers";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Streamers");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Streamers";
	                        break;
	                    case "brush_Taffy":
	                        mesh.geometry.name = "geometry_Taffy";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("DiamondHull");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_DiamondHull";
	                        break;
	                    case "brush_TaperedFlat":
	                        mesh.geometry.name = "geometry_TaperedFlat";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("TaperedFlat");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_TaperedFlat";
	                        break;
	                    case "brush_TaperedMarker":
	                        mesh.geometry.name = "geometry_TaperedMarker";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("TaperedMarker");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_TaperedMarker";
	                        break;
	                    case "brush_TaperedMarker_Flat":
	                        mesh.geometry.name = "geometry_Flat";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Flat");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Flat";
	                        break;
	                    case "brush_ThickPaint":
	                        mesh.geometry.name = "geometry_ThickPaint";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("ThickPaint");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_ThickPaint";
	                        break;
	                    case "brush_Toon":
	                        mesh.geometry.name = "geometry_Toon";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        shader = yield tiltShaderLoader.loadAsync("Toon");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Toon";
	                        break;
	                    case "brush_UnlitHull":
	                        mesh.geometry.name = "geometry_UnlitHull";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        shader = yield tiltShaderLoader.loadAsync("UnlitHull");
	                        mesh.material = shader;
	                        mesh.material.name = "material_UnlitHull";
	                        break;
	                    case "brush_VelvetInk":
	                        mesh.geometry.name = "geometry_VelvetInk";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("VelvetInk");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_VelvetInk";
	                        break;
	                    case "brush_Waveform":
	                        mesh.geometry.name = "geometry_Waveform";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("Waveform");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_Waveform";
	                        break;
	                    case "brush_WetPaint":
	                        mesh.geometry.name = "geometry_WetPaint";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("WetPaint");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_WetPaint";
	                        break;
	                    case "brush_WigglyGraphite":
	                        mesh.geometry.name = "geometry_WigglyGraphite";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        mesh.geometry.setAttribute("a_texcoord0", mesh.geometry.getAttribute("uv"));
	                        shader = yield tiltShaderLoader.loadAsync("WigglyGraphite");
	                        shader.uniformsNeedUpdate = true;
	                        mesh.material = shader;
	                        mesh.material.name = "material_WigglyGraphite";
	                        break;
	                    case "brush_Wire":
	                        mesh.geometry.name = "geometry_Wire";
	                        mesh.geometry.setAttribute("a_position", mesh.geometry.getAttribute("position"));
	                        mesh.geometry.setAttribute("a_normal", mesh.geometry.getAttribute("normal"));
	                        mesh.geometry.setAttribute("a_color", mesh.geometry.getAttribute("color"));
	                        shader = yield tiltShaderLoader.loadAsync("Wire");
	                        mesh.material = shader;
	                        mesh.material.name = "material_Wire";
	                        break;
	                }
	                mesh.onBeforeRender = (renderer, scene, camera, geometry, material, group) => {
	                    if (material.uniforms["u_time"]) {
	                        const elapsedTime = clock.getElapsedTime();
	                        const time = new Vector4(elapsedTime / 20, elapsedTime, elapsedTime * 2, elapsedTime * 3);
	                        material.uniforms["u_time"].value = time;
	                    }
	                    if (material.uniforms["cameraPosition"]) {
	                        material.uniforms["cameraPosition"].value = camera.position;
	                    }
	                };
	            }
	        }));
	    });
	}

	class Viewer {
	    constructor(brushPath, frame) {
	        this.sceneColor = new Color("#000000");
	        this.icosa_frame = frame;
	        if (!this.icosa_frame)
	            this.icosa_frame = document.getElementById('icosa-viewer');
	        if (!this.icosa_frame) {
	            this.icosa_frame = document.createElement('div');
	            this.icosa_frame.id = 'icosa-viewer';
	        }
	        const controlPanel = document.createElement('div');
	        controlPanel.classList.add('control-panel');
	        const fullscreenButton = document.createElement('button');
	        fullscreenButton.classList.add('panel-button', 'fullscreen-button');
	        fullscreenButton.onclick = () => { this.toggleFullscreen(fullscreenButton); };
	        controlPanel.appendChild(fullscreenButton);
	        this.icosa_frame.appendChild(controlPanel);
	        const loadscreen = document.createElement('div');
	        loadscreen.id = 'loadscreen';
	        const loadanim = document.createElement('div');
	        loadanim.classList.add('loadlogo');
	        loadscreen.appendChild(loadanim);
	        this.icosa_frame.appendChild(loadscreen);
	        loadscreen.addEventListener('transitionend', function () {
	            const opacity = window.getComputedStyle(loadscreen).opacity;
	            if (parseFloat(opacity) < 0.2) {
	                loadscreen.classList.add('loaded');
	            }
	        });
	        const canvas = document.createElement('canvas');
	        canvas.id = 'c';
	        this.icosa_frame.appendChild(canvas);
	        canvas.onmousedown = () => { canvas.classList.add('grabbed'); };
	        canvas.onmouseup = () => { canvas.classList.remove('grabbed'); };
	        const renderer = new WebGLRenderer({ canvas: canvas });
	        renderer.setPixelRatio(window.devicePixelRatio);
	        renderer.outputEncoding = sRGBEncoding;
	        renderer.xr.enabled = true;
	        this.icosa_frame.appendChild(VRButton.createButton(renderer));
	        const clock = new Clock();
	        const fov = 75;
	        const aspect = 2;
	        const near = 0.1;
	        const far = 1000;
	        const flatCamera = new PerspectiveCamera(fov, aspect, near, far);
	        flatCamera.position.set(10, 10, 10);
	        CameraControls.install({ THREE: subsetOfTHREE });
	        this.cameraControls = new CameraControls(flatCamera, canvas);
	        this.cameraControls.dampingFactor = 0.1;
	        this.cameraControls.polarRotateSpeed = this.cameraControls.azimuthRotateSpeed = 0.5;
	        this.cameraControls.setTarget(0, 0, 0);
	        this.cameraControls.dollyTo(3, true);
	        flatCamera.updateProjectionMatrix();
	        this.sceneCamera = flatCamera;
	        const xrCamera = new PerspectiveCamera(fov, aspect, near, far);
	        xrCamera.updateProjectionMatrix();
	        setupNavigation(this.cameraControls);
	        this.scene = new Scene();
	        const viewer = this;
	        const manager = new LoadingManager();
	        manager.onStart = function () {
	            var _a, _b;
	            (_a = document.getElementById('loadscreen')) === null || _a === void 0 ? void 0 : _a.classList.remove('fade-out');
	            (_b = document.getElementById('loadscreen')) === null || _b === void 0 ? void 0 : _b.classList.remove('loaded');
	        };
	        manager.onLoad = function () {
	            var _a;
	            (_a = document.getElementById('loadscreen')) === null || _a === void 0 ? void 0 : _a.classList.add('fade-out');
	        };
	        this.brushPath = brushPath;
	        this.tiltLoader = new TiltLoader(manager);
	        this.tiltLoader.setBrushPath(this.brushPath);
	        this.gltfLegacyLoader = new LegacyGLTFLoader(manager);
	        this.gltfLoader = new GLTFLoader(manager);
	        this.gltfLoader.register(parser => new GLTFGoogleTiltBrushMaterialExtension(parser, this.brushPath));
	        const dracoLoader = new DRACOLoader();
	        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
	        this.gltfLoader.setDRACOLoader(dracoLoader);
	        function animate() {
	            renderer.setAnimationLoop(render);
	        }
	        function render() {
	            const delta = clock.getDelta();
	            if (renderer.xr.isPresenting) {
	                viewer.sceneCamera = xrCamera;
	            }
	            else {
	                viewer.sceneCamera = flatCamera;
	                const needResize = canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight;
	                if (needResize) {
	                    renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
	                    flatCamera.aspect = canvas.clientWidth / canvas.clientHeight;
	                    flatCamera.updateProjectionMatrix();
	                }
	                viewer.cameraControls.update(delta);
	            }
	            renderer.render(viewer.scene, viewer.sceneCamera);
	        }
	        animate();
	    }
	    toggleFullscreen(controlButton) {
	        var _a, _b;
	        if ((_a = this.icosa_frame) === null || _a === void 0 ? void 0 : _a.requestFullscreen)
	            (_b = this.icosa_frame) === null || _b === void 0 ? void 0 : _b.requestFullscreen();
	        document.onfullscreenchange = () => {
	            if (document.fullscreenElement == null) {
	                controlButton.onclick = () => {
	                    var _a, _b;
	                    if ((_a = this.icosa_frame) === null || _a === void 0 ? void 0 : _a.requestFullscreen)
	                        (_b = this.icosa_frame) === null || _b === void 0 ? void 0 : _b.requestFullscreen();
	                };
	                controlButton.classList.remove('fullscreen');
	            }
	            else {
	                controlButton.onclick = () => {
	                    if (document.exitFullscreen)
	                        document.exitFullscreen();
	                };
	                controlButton.classList.add('fullscreen');
	            }
	        };
	    }
	    initializeScene() {
	        if (!this.loadedModel)
	            return;
	        this.scene.clear();
	        this.scene.background = this.sceneColor;
	        this.scene.add(this.loadedModel);
	        const box = new Box3().setFromObject(this.loadedModel);
	        const boxSize = box.getSize(new Vector3()).length();
	        const boxCenter = box.getCenter(new Vector3());
	        this.cameraControls.minDistance = boxSize * 0.01;
	        this.cameraControls.maxDistance = boxSize;
	        const midDistance = this.cameraControls.minDistance + (this.cameraControls.maxDistance - this.cameraControls.minDistance) / 2;
	        this.cameraControls.setTarget(boxCenter.x, boxCenter.y, boxCenter.z);
	        this.cameraControls.dollyTo(midDistance, true);
	        this.cameraControls.saveState();
	        const ambientLight = new AmbientLight();
	        this.scene.add(ambientLight);
	    }
	    loadGltf(url) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const gltf = yield this.gltfLoader.loadAsync(url);
	            this.loadedModel = gltf.scene;
	            this.initializeScene();
	        });
	    }
	    loadTilt(url) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const tiltData = yield this.tiltLoader.loadAsync(url);
	            this.loadedModel = tiltData;
	            this.initializeScene();
	        });
	    }
	    loadObj(url) {
	    }
	    loadGltf1(url) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const tiltData = yield this.gltfLegacyLoader.loadAsync(url);
	            this.loadedModel = tiltData.scene;
	            yield replaceBrushMaterials(this.brushPath, this.loadedModel);
	            this.initializeScene();
	        });
	    }
	}

	exports.Viewer = Viewer;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
