<!doctype html>
<meta charset="utf-8">
<html>
    <head>
        <title>.gltf/.glb Viewer | Icosa Viewer</title>
        <style>
            html, body {
                height: 100%;
                width: 100%;
                margin: 0;
            }
        </style>
        <script type="importmap" class="es6_modules_map">
            {
                "imports": {
                    "three": "https://cdn.jsdelivr.net/npm/three@0.172.0/build/three.module.js",
                    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.172.0/examples/jsm/",
                    "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.172.0/examples/",
                    "three-icosa": "./three-icosa.module.js",
                    "three-tiltloader": "https://cdn.jsdelivr.net/npm/three-tiltloader@0.4.2-alpha.4/dist/three-tiltloader.module.js",
                    "@sparkjsdev/spark": "https://cdn.jsdelivr.net/npm/@sparkjsdev/spark@0.1.8/dist/spark.module.js"
                }
            }
        </script>
        <link rel="stylesheet" href="css/style.css">
    </head>
    <style>
        .lil-gui {
            --title-background-color: rgba(0,0,0,0.25);
            --background-color: rgba(0,0,0,0.25);
            --widget-color: rgba(1,1,1,0.25);
        }
        .lil-gui.root {
            position: absolute;
            top: 0;
            right: 0;
        }
    </style>
    <style>
        #tree-view {
            padding: 10px;
            background-color: rgba(0,0,0,0.25);
            color: white;
            font-size: 11px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            z-index: 10;
            display: none;
        }
        .tree-node {
            margin: 5px 0;
            white-space: nowrap;
        }
        .tree-content {
            align-items: center;
        }
        #tree-view .toggle-btn {
            display: inline-block;
            cursor: pointer;
            width: 10px;
            text-align: center;
        }
        #tree-view .children {
            margin-left: 10px;
            display: none;
        }

        #tree-view .selected {
            background-color: rgba(255,255,255,0.5);
            color: black;
        }

        #tree-view .expanded > .children {
            display: block;
        }
    </style>
    <body style="margin: 0; background-color: black; display: flex; justify-content: center; align-items: center; height: 100vh;">

        <div id="icosa-wrapper" style="position: relative; width: 80%; height: 80%; display: flex;">
            <div id="tree-view" style="width: 250px; overflow-y: auto; flex-shrink: 0;"></div>
            <div id="icosa-viewer" style="flex-grow: 1; height: 100%;"></div>
        </div>

        <script type="module">
            import { Viewer } from "./icosa-viewer.module.js";
            import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
            import * as THREE from "three";

            let viewer = new Viewer("https://icosa-foundation.github.io/icosa-sketch-assets/");
            // viewer.crossOrigin = "no-cors";
            window.viewer = viewer;
            window.THREE = THREE;

            let urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has("asset")) {
                let assetId = urlParams.get("asset");
                let metadataJson = await fetch(`https://api.icosa.gallery/v1/assets/${assetId}`);
                let json = await metadataJson.json();
                let formats = json.formats || [];
                let presentationParams = json.presentationParams;
                let overrides = {
                    'defaultBackgroundColor': presentationParams?.backgroundColor || "#000000",
                    'camera': presentationParams?.camera,
                    'geometryData': presentationParams?.GOOGLE_geometry_data,
                    'colorSpace': presentationParams?.colorSpace,
                };

                let hasTilt = false;
                for (const format of formats) {
                    if (format?.formatType.includes("TILT")) {
                        hasTilt = true;
                        break;
                    }
                }
                for (const format of formats) {
                    // Skip Internet Archive URLs because they just give CORS errors
                    if (format.root.url.startsWith("https://web.archive.org/")) continue;
                    // Weird special case specific to Icosa Gallery
                    // Our non-Tilt files are currently broken GLTF v1 files but we have an alternate url that does work
                    if (!hasTilt && format?.formatType === "GLTF") {
                        console.log(`Loading Updated variant of GLTF2 ${format.root.url}`);
                        let url = format.root.url.replace(".gltf", "_%28GLTFupdated%29.gltf");
                        await viewer.loadGltf(url, true, overrides);
                        break;

                    } else if (format?.formatType === "GLTF2") {
                        console.log(`Loading GLTF2 ${format.root.url}`);
                        await viewer.loadGltf(format.root.url, true, overrides);
                        break;
                    } else if (format?.formatType === "GLTF") {
                        console.log(`Loading GLTF1 ${format.root.url}`);
                        await viewer.loadGltf1(format.root.url, true, overrides);
                        break;
                    }
                }
            } else {
                // Just some arbitrary values - not matching the actual asset
                let presentationParams = {
                    "camera": {"type": "perspective",
                        "rotation": [-0.1462917120878683, 0.2306854792441933, 0.03510497024615985, 0.9613275121956582],
                        "perspective": {"yfov": 0, "znear": 0.1},
                        "translation": [1.586311936378479, 2.004192590713501, 3.153336048126221],
                        "GOOGLE_camera_settings": null},
                    "colorSpace": "GAMMA", "backgroundColor": "#000000",
                    "GOOGLE_hemi_light": null, "orientingRotation": {"w": 1},
                    "GOOGLE_backgrounds": {"color": [0, 0, 0]},
                    "GOOGLE_lighting_rig": null, "GOOGLE_geometry_data": null,
                    "GOOGLE_scene_rotation": null, "GOOGLE_lights_image_based": null,
                    "GOOGLE_real_world_transform": {"scaling_factor": 1},
                    "GOOGLE_initial_camera_motion": null};
                // let presentationParams = {};
                let overrides = {
                    'defaultBackgroundColor': presentationParams?.backgroundColor || "#000000",
                    'camera': presentationParams.camera,
                    'geometryData': presentationParams.GOOGLE_geometry_data,
                    'colorSpace': presentationParams.colorSpace,
                };

                // await viewer.loadGltf1("https://s3.us-east-005.backblazeb2.com/icosa-gallery/poly/0F3ek3idOaX/sketch.gltf", true, {"camera": presentationParams.camera});
                // await viewer.loadGltf("formats/gltf2/monster-updatedgltf/model.gltf", true, {"camera": presentationParams.camera});
                // await viewer.loadGltf("formats/gltf2/mimic-updated-gltf/sketch.gltf", true, {"camera": presentationParams.camera});
                // await viewer.loadGltf("formats/gltf2/mimic-unknown-glb-b/sketch.glb", true, {"camera": presentationParams.camera});
                await viewer.loadGltf1("formats/gltf1/mimic-polygone-gltf/sketch.gltf", true, overrides);
                // await viewer.loadPly("formats/ply/dolphins_colored.ply", overrides);
                // await viewer.loadStl("formats/stl/colored.stl", overrides);
                // await viewer.loadUsdz("formats/usdz/saeukkang.usdz", overrides);
                // await viewer.loadVox("formats/vox/monu10.vox", overrides);
                await viewer.loadSplat("formats/splats/butterfly.spz", overrides);
            }

            const gui = new GUI({ autoPlace: false });
            const parentDiv = document.getElementById('icosa-viewer');
            parentDiv.appendChild(gui.domElement);

            const guiParams = {
                backgroundColor: '#000000',
                fogColor: '#000000',
                fogDensity: 0,
                // Lighting controls
                ambientLightColor: '#ffffff',
                light0Color: '#ffffff',
                light0RotationX: 0,
                light0RotationY: 0,
                light1Color: '#ffffff',
                light1RotationX: 0,
                light1RotationY: 0,
                // Environment controls
                envScale: 1,
                envTransX: 0,
                envTransY: 0,
                envTransZ: 0,
                // Scene transform controls
                sceneScale: 1,
                sceneTransX: 0,
                sceneTransY: 0,
                sceneTransZ: 0,
                toggleTreeView: () => viewer.toggleTreeView(document.getElementById('tree-view')),
                toggleEnvironment: () => viewer.environmentObject && (viewer.environmentObject.visible = !viewer.environmentObject.visible),
                toggleSky: () => viewer.skyObject && (viewer.skyObject.visible = !viewer.skyObject.visible),
                fogBackground: () => {
                    if (viewer.skyObject && viewer.skyObject.visible) {
                        viewer.skyObject.material.color = new THREE.Color(guiParams.fogColor).multiplyScalar(guiParams.fogDensity);
                        viewer.skyObject.material.fog = true;
                    } else {
                        let bgCol = new THREE.Color(guiParams.backgroundColor);
                        let fogColor = new THREE.Color(guiParams.fogColor).multiplyScalar(guiParams.fogDensity);
                        let foggedBgCol = bgCol.add(fogColor); // Is this correct?
                        viewer.scene.background = foggedBgCol;
                    }
                },
                listCameras: () => {
                    let cameras = [];
                    viewer.scene.traverse((child) => {
                        if (child instanceof THREE.Camera) {
                            cameras.push(child);
                        }
                    });
                    window.cameras = cameras;
                    doLogging(cameras);
                },
                listLights: () => {
                    let lights = [];
                    viewer.scene.traverse((child) => {
                        if (child instanceof THREE.Light) {
                            lights.push(child);
                        }
                    });
                    window.lights = lights;
                    doLogging(lights);
                },
                listOverrides: () => {
                    doLogging(viewer.overrides);
                },
                listSketchMetadata: () => {
                    doLogging(viewer.sketchMetadata);
                },
                frameScene: () => {
                    viewer.frameScene();
                },
                levelCamera: () => {
                    viewer.levelCamera();
                },
                logTargetPoint: () => {
                    let t = viewer.cameraControls.getTarget();
                    doLogging(t);
                },
                debugCameraPositioning: () => {
                    const cameraPos = new THREE.Vector3();
                    const target = new THREE.Vector3();
                    viewer.cameraControls.getPosition(cameraPos);
                    viewer.cameraControls.getTarget(target);

                    // Analyze what actually determined the current camera state
                    const debug = {
                        finalResult: {
                            cameraPosition: cameraPos.toArray(),
                            cameraTarget: target.toArray(),
                            distance: cameraPos.distanceTo(target)
                        },
                        calculationTrace: {}
                    };

                    // Check what overrides were actually used
                    if (viewer.overrides?.camera) {
                        debug.calculationTrace.cameraOverrides = {
                            source: "viewer.overrides.camera",
                            values: viewer.overrides.camera,
                            winner: "✓ These camera overrides were applied"
                        };
                    } else {
                        debug.calculationTrace.cameraOverrides = {
                            source: "viewer.overrides.camera",
                            values: null,
                            winner: "✗ No camera overrides found"
                        };
                    }

                    // Check sketch metadata camera settings
                    if (viewer.sketchMetadata?.CameraTranslation || viewer.sketchMetadata?.CameraRotation) {
                        debug.calculationTrace.sketchMetadata = {
                            source: "viewer.sketchMetadata",
                            translation: viewer.sketchMetadata?.CameraTranslation,
                            rotation: viewer.sketchMetadata?.CameraRotation,
                            winner: viewer.overrides?.camera ? "✗ Overridden by camera overrides" : "✓ These values were used"
                        };
                    } else {
                        debug.calculationTrace.sketchMetadata = {
                            source: "viewer.sketchMetadata",
                            values: null,
                            winner: "✗ No sketch metadata camera found"
                        };
                    }

                    // Check target calculation
                    const geometryData = viewer.overrides?.geometryData;
                    if (geometryData?.visualCenterPoint) {
                        debug.calculationTrace.targetCalculation = {
                            method: "visualCenterPoint from geometryData",
                            value: geometryData.visualCenterPoint,
                            winner: "✓ Target set to visualCenterPoint"
                        };
                    } else if (geometryData?.stats?.centroid) {
                        debug.calculationTrace.targetCalculation = {
                            method: "centroid from geometryData.stats",
                            value: geometryData.stats.centroid,
                            winner: "✓ Target set to centroid"
                        };
                    } else {
                        debug.calculationTrace.targetCalculation = {
                            method: "default (0,0,0)",
                            value: [0, 0, 0],
                            winner: "✓ Target defaulted to origin"
                        };
                    }

                    // Check why target is not at origin as expected
                    debug.calculationTrace.targetCalculationDetailed = {
                        expectedTarget: [0, 0, 0],
                        actualTarget: target.toArray(),
                        explanation: "Target should be [0,0,0] but initCameras() may be overriding it"
                    };

                    if (viewer.modelBoundingBox) {
                        const boxCenter = viewer.modelBoundingBox.getCenter(new THREE.Vector3());
                        debug.calculationTrace.targetCalculationDetailed.boundingBoxCenter = boxCenter.toArray();
                        debug.calculationTrace.targetCalculationDetailed.explanation += ". initCameras() uses bounding box center when no visualCenterPoint exists";
                    }

                    console.log("🎥 Camera Positioning Trace for Current File:", debug);
                    doLogging(debug);
                },
                targetVisualCenterY: () => {
                    let t = viewer.overrides?.geometryData?.visualCenterPoint;
                    var pos = viewer.cameraControls.camera.getWorldPosition(new THREE.Vector3());
                    doLogging([t, pos]);
                    if (t) {viewer.cameraControls.setTarget(t[0], pos.y, t[2])}
                },
                targetVisualCenter: () => {
                    let t = viewer.overrides?.geometryData?.visualCenterPoint;
                    doLogging(t);
                    if (t) {viewer.cameraControls.setTarget(t[0], t[1], t[2])}
                },
                targetBoundingBoxCenter: () => {
                    let t = viewer.modelBoundingBox.getCenter(new THREE.Vector3());
                    doLogging(t);
                    if (t) {viewer.cameraControls.setTarget(t.x, t.y, t.z)}
                },
                targetPivot: () => {
                    let t = viewer.overrides?.camera?.GOOGLE_camera_settings?.pivot;
                    doLogging(t);
                    if (t) {viewer.cameraControls.setTarget(t[0], t[1], t[2])}
                },
                targetOrigin: () => {
                    let t = [0, 0, 0];
                    doLogging(t);
                    viewer.cameraControls.setTarget(t[0], t[1], t[2]);
                },
                wireframe: () => {
                    viewer.scene.traverse((child) => {
                        if (child instanceof THREE.Mesh && child !== viewer.skyObject) {
                            child.material.wireframe = !child.material.wireframe;
                        }
                    });
                },
                captureThumbnail: () => {
                    const dataUrl = viewer.captureThumbnail(512, 512);

                    // Create a temporary link to download the image
                    const link = document.createElement('a');
                    link.download = 'thumbnail.png';
                    link.href = dataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    // Also log the data URL for debugging
                    doLogging({
                        message: "Thumbnail captured",
                        size: "512x512",
                        dataUrl: dataUrl.substring(0, 100) + "..." // Show first 100 chars
                    });
                },
                logInfo: ""
            };

            const toggleTreeView = gui.add(guiParams, 'toggleTreeView').name("Toggle Hierarchy");
            const captureThumbnailBtn = gui.add(guiParams, 'captureThumbnail').name("Capture Thumbnail");

            // Environment controls folder
            const environmentFolder = gui.addFolder('Environment');
            const backgroundColorControl = environmentFolder.addColor(guiParams, 'backgroundColor').name("Background Color").onChange(() => viewer.scene.background = new THREE.Color(guiParams.backgroundColor));
            const fogColorControl = environmentFolder.addColor(guiParams, 'fogColor').name("Fog Color").onChange(() => viewer.scene.fog.color = new THREE.Color(guiParams.fogColor));
            const fogDensityControl = environmentFolder.add(guiParams, 'fogDensity', 0, 1).name("Fog Density").onChange(() => viewer.scene.fog.density = guiParams.fogDensity);
            const fogBackgroundControl = environmentFolder.add(guiParams, "fogBackground").name("Fog Background");
            const toggleEnvironmentControl = environmentFolder.add(guiParams, 'toggleEnvironment').name("Toggle Environment");
            const toggleSkyControl = environmentFolder.add(guiParams, 'toggleSky').name("Toggle Sky");
            const wireframeControl = environmentFolder.add(guiParams, 'wireframe').name("Toggle Wireframe");
            
            // Environment transform controls
            const envTransformFolder = environmentFolder.addFolder('Environment Transform');
            envTransformFolder.close();
            envTransformFolder.add(guiParams, 'envScale', 0.001, 2).name('Scale').onChange(() => {
                if (viewer.environmentObject) {
                    viewer.environmentObject.scale.setScalar(guiParams.envScale);
                    viewer.environmentObject.position.set(guiParams.envTransX, guiParams.envTransY, guiParams.envTransZ);
                }
            });
            envTransformFolder.add(guiParams, 'envTransX', -10, 10).name('Translation X').onChange(() => {
                if (viewer.environmentObject) {
                    viewer.environmentObject.scale.setScalar(guiParams.envScale);
                    viewer.environmentObject.position.set(guiParams.envTransX, guiParams.envTransY, guiParams.envTransZ);
                }
            });
            envTransformFolder.add(guiParams, 'envTransY', -10, 10).name('Translation Y').onChange(() => {
                if (viewer.environmentObject) {
                    viewer.environmentObject.scale.setScalar(guiParams.envScale);
                    viewer.environmentObject.position.set(guiParams.envTransX, guiParams.envTransY, guiParams.envTransZ);
                }
            });
            envTransformFolder.add(guiParams, 'envTransZ', -10, 10).name('Translation Z').onChange(() => {
                if (viewer.environmentObject) {
                    viewer.environmentObject.scale.setScalar(guiParams.envScale);
                    viewer.environmentObject.position.set(guiParams.envTransX, guiParams.envTransY, guiParams.envTransZ);
                }
            });
            
            // Scene transform controls
            const sceneTransformFolder = gui.addFolder('Scene Transform');
            sceneTransformFolder.close();
            // Store references to sketch children (excluding environment)
            let sketchChildren = [];
            if (viewer.loadedModel) {
                viewer.loadedModel.traverse((child) => {
                    if (child !== viewer.environmentObject && child.parent === viewer.loadedModel) {
                        sketchChildren.push(child);
                    }
                });
            }
            
            function applySceneTransform() {
                sketchChildren.forEach((child) => {
                    child.scale.setScalar(guiParams.sceneScale);
                    child.position.set(guiParams.sceneTransX, guiParams.sceneTransY, guiParams.sceneTransZ);
                });
            }
            
            sceneTransformFolder.add(guiParams, 'sceneScale', 0.1, 10).name('Scale').onChange(applySceneTransform);
            sceneTransformFolder.add(guiParams, 'sceneTransX', -10, 10).name('Translation X').onChange(applySceneTransform);
            sceneTransformFolder.add(guiParams, 'sceneTransY', -10, 10).name('Translation Y').onChange(applySceneTransform);
            sceneTransformFolder.add(guiParams, 'sceneTransZ', -10, 10).name('Translation Z').onChange(applySceneTransform);
            
            const sceneInfoFolder = gui.addFolder('Scene Info');
            const listCamerasControl = sceneInfoFolder.add(guiParams, 'listCameras').name("List Cameras");
            const listLightsControl = sceneInfoFolder.add(guiParams, 'listLights').name("List Lights");
            const listOverridesControl = sceneInfoFolder.add(guiParams, 'listOverrides').name("List Overrides");
            const listSketchMetadataControl = sceneInfoFolder.add(guiParams, 'listSketchMetadata').name("List Sketch MetaData");

            const cameraFolder = gui.addFolder( 'Camera' );
            const levelCameraControl = cameraFolder.add(guiParams, 'levelCamera').name("Level Camera");
            const frameSceneControl = cameraFolder.add(guiParams, 'frameScene').name("Frame Scene");
            const logTargetPointControl = cameraFolder.add(guiParams, 'logTargetPoint').name("Log Target Point");
            const debugCameraPositioningControl = cameraFolder.add(guiParams, 'debugCameraPositioning').name("Debug Camera Positioning");

            const cameraTargetFolder = cameraFolder.addFolder( 'Camera Target' );
            cameraTargetFolder.close();
            const targetPivotControl = cameraTargetFolder.add(guiParams, 'targetPivot').name("Target Pivot");
            const targetVisualCenterControl = cameraTargetFolder.add(guiParams, 'targetVisualCenter').name("Target visualCenterPoint");
            const targetVisualCenterYControl = cameraTargetFolder.add(guiParams, 'targetVisualCenterY').name("Target visualCenterPoint Y");
            const targetBoundingBoxCenterControl = cameraTargetFolder.add(guiParams, 'targetBoundingBoxCenter').name("Target Bounding Box Center");
            const targetOriginControl = cameraTargetFolder.add(guiParams, 'targetOrigin').name("Target Origin");

            // Lighting controls folder
            const lightsFolder = gui.addFolder('Lighting');
            
            // Get references to lights after model is loaded
            let ambientLight = null;
            let directionalLight0 = null;
            let directionalLight1 = null;
            
            viewer.scene.traverse((child) => {
                if (child instanceof THREE.AmbientLight) {
                    ambientLight = child;
                } else if (child instanceof THREE.DirectionalLight) {
                    if (!directionalLight0) {
                        directionalLight0 = child;
                    } else if (!directionalLight1) {
                        directionalLight1 = child;
                    }
                }
            });
            
            // Ambient light color control
            if (ambientLight) {
                guiParams.ambientLightColor = '#' + ambientLight.color.getHexString();
                lightsFolder.addColor(guiParams, 'ambientLightColor').name('Ambient Light Color').onChange(() => {
                    ambientLight.color.setHex(parseInt(guiParams.ambientLightColor.replace('#', ''), 16));
                });
            }
            
            // Directional Light 0 controls
            if (directionalLight0) {
                guiParams.light0Color = '#' + directionalLight0.color.getHexString();
                const light0Euler = new THREE.Euler().setFromQuaternion(directionalLight0.quaternion);
                guiParams.light0RotationX = THREE.MathUtils.radToDeg(light0Euler.x);
                guiParams.light0RotationY = THREE.MathUtils.radToDeg(light0Euler.y);
                
                const light0Folder = lightsFolder.addFolder('Light 0');
                light0Folder.close();
                light0Folder.addColor(guiParams, 'light0Color').name('Color').onChange(() => {
                    directionalLight0.color.setHex(parseInt(guiParams.light0Color.replace('#', ''), 16));
                });
                light0Folder.add(guiParams, 'light0RotationX', -180, 180).name('Rotation X').onChange(() => {
                    const euler = new THREE.Euler(
                        THREE.MathUtils.degToRad(guiParams.light0RotationX),
                        THREE.MathUtils.degToRad(guiParams.light0RotationY),
                        0
                    );
                    const direction = new THREE.Vector3(0, 0, 1).applyEuler(euler);
                    directionalLight0.position.copy(direction.multiplyScalar(10));
                    directionalLight0.lookAt(0, 0, 0);
                });
                light0Folder.add(guiParams, 'light0RotationY', -180, 180).name('Rotation Y').onChange(() => {
                    const euler = new THREE.Euler(
                        THREE.MathUtils.degToRad(guiParams.light0RotationX),
                        THREE.MathUtils.degToRad(guiParams.light0RotationY),
                        0
                    );
                    const direction = new THREE.Vector3(0, 0, 1).applyEuler(euler);
                    directionalLight0.position.copy(direction.multiplyScalar(10));
                    directionalLight0.lookAt(0, 0, 0);
                });
            }
            
            // Directional Light 1 controls
            if (directionalLight1) {
                guiParams.light1Color = '#' + directionalLight1.color.getHexString();
                const light1Euler = new THREE.Euler().setFromQuaternion(directionalLight1.quaternion);
                guiParams.light1RotationX = THREE.MathUtils.radToDeg(light1Euler.x);
                guiParams.light1RotationY = THREE.MathUtils.radToDeg(light1Euler.y);
                
                const light1Folder = lightsFolder.addFolder('Light 1');
                light1Folder.close();
                light1Folder.addColor(guiParams, 'light1Color').name('Color').onChange(() => {
                    directionalLight1.color.setHex(parseInt(guiParams.light1Color.replace('#', ''), 16));
                });
                light1Folder.add(guiParams, 'light1RotationX', -180, 180).name('Rotation X').onChange(() => {
                    const euler = new THREE.Euler(
                        THREE.MathUtils.degToRad(guiParams.light1RotationX),
                        THREE.MathUtils.degToRad(guiParams.light1RotationY),
                        0
                    );
                    const direction = new THREE.Vector3(0, 0, 1).applyEuler(euler);
                    directionalLight1.position.copy(direction.multiplyScalar(10));
                    directionalLight1.lookAt(0, 0, 0);
                });
                light1Folder.add(guiParams, 'light1RotationY', -180, 180).name('Rotation Y').onChange(() => {
                    const euler = new THREE.Euler(
                        THREE.MathUtils.degToRad(guiParams.light1RotationX),
                        THREE.MathUtils.degToRad(guiParams.light1RotationY),
                        0
                    );
                    const direction = new THREE.Vector3(0, 0, 1).applyEuler(euler);
                    directionalLight1.position.copy(direction.multiplyScalar(10));
                    directionalLight1.lookAt(0, 0, 0);
                });
            }

            const logInfoControl = gui.add(guiParams, 'logInfo').name('Log Window');
            window.logInfoControl = logInfoControl;
            logInfoControl.domElement.getElementsByClassName("name")[0].style.display = "none";
            let widget = logInfoControl.domElement.getElementsByClassName("widget")[0];
            const logContainer = document.createElement('textarea');
            logContainer.rows = 16;
            logContainer.style.width = "100%";
            logContainer.style.padding = "3px";
            logContainer.style.fontFamily = "monospace";
            logContainer.style.backgroundColor = "black";
            logContainer.style.color = "white";
            logContainer.style.fontSize = "9px";
            logContainer.style.whiteSpace = "pre-wrap";
            logContainer.style.wordWrap = "break-word";
            widget.replaceChild(logContainer, widget.getElementsByTagName("input")[0]);

            function doLogging(data) {
                // Convert arbitrary data to readable text
                console.log(data);
                logContainer.value = JSON.stringify(data, null, 2);
            }

            guiParams.backgroundColor = "#" + (viewer.scene.background?.color?.getHexString() || "000000");
            guiParams.fogColor = "#" + (viewer.scene.fog?.color?.getHexString() || "ffffff");
            guiParams.fogDensity = viewer.scene.fog?.density;
            
            // Initialize environment transform parameters
            if (viewer.environmentObject) {
                guiParams.envScale = viewer.environmentObject.scale.x;
                guiParams.envTransX = viewer.environmentObject.position.x;
                guiParams.envTransY = viewer.environmentObject.position.y;
                guiParams.envTransZ = viewer.environmentObject.position.z;
            }
            
            // Initialize scene transform parameters
            if (viewer.loadedModel) {
                guiParams.sceneScale = viewer.loadedModel.scale.x;
                guiParams.sceneTransX = viewer.loadedModel.position.x;
                guiParams.sceneTransY = viewer.loadedModel.position.y;
                guiParams.sceneTransZ = viewer.loadedModel.position.z;
            }

            if (!viewer.environmentObject) toggleEnvironmentControl.disable();
            if (!viewer.skyObject) toggleSkyControl.disable();
            if (!viewer.overrides?.geometryData?.visualCenterPoint) targetVisualCenterControl.disable();
            if (!viewer.overrides?.geometryData?.visualCenterPoint) targetVisualCenterYControl.disable();
            if (!viewer.overrides?.camera?.GOOGLE_camera_settings?.pivot) targetPivotControl.disable();

        </script>
    </body>
</html>
